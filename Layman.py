
 # -*- coding: utf-8 -*-
"""
/***************************************************************************
 Layman
                                 A QGIS plugin
 Layman
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-02-15
        git sha              : $Format:%H$
        copyright            : (C) 2019 by jan vrobel
        email                : vrobel.jan@seznam.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import base64
import configparser
import copy
import csv
import hashlib
import io
import json
import os
import os.path
import random
import re
import shutil
import tempfile
import threading
import time
import traceback
import unicodedata
import urllib.parse
import webbrowser
import xml.etree.ElementTree as ET
import zipfile
from builtins import object, range, str
from distutils.version import LooseVersion, StrictVersion
from multiprocessing import Process
from os import walk
from pathlib import Path
from typing import Any, Dict, List, Optional, Union
from urllib.request import urlopen
from zipfile import ZipFile

import pandas as pd
import processing
import PyQt5
import qgis.core
import qgis.gui
import qgis.utils
import requests
from owslib.wms import WebMapService
from PyQt5 import QtWidgets
from PyQt5.QtCore import (QByteArray, QCoreApplication, QDir,
                          QFileSystemWatcher, QObject, QRegExp, QSettings,
                          QSize, Qt, QTranslator, QUrl, pyqtSignal,
                          qVersion, QTimer)
from PyQt5.QtGui import (QBrush, QColor, QCursor, QDoubleValidator, QIcon,
                         QPixmap, QRegExpValidator)
from PyQt5.QtNetwork import QNetworkAccessManager, QNetworkRequest
from PyQt5.QtWidgets import (QAbstractItemView, QAction, QApplication,
                             QComboBox, QDialog, QFileDialog, QHBoxLayout,
                             QInputDialog, QLabel, QLineEdit, QListWidgetItem,
                             QMessageBox, QProgressBar, QProgressDialog,
                             QPushButton, QTreeWidget, QTreeWidgetItem,
                             QTreeWidgetItemIterator, QWidget)
from qgis.core import *
from qgis.core import QgsApplication, QgsSettings, QgsUnitTypes
from qgis.gui import QgsMapCanvas
from qgis.PyQt.QtNetwork import (QHttpMultiPart, QHttpPart, QNetworkReply,
                                 QNetworkRequest)
from qgis.utils import iface

from Layman.qfield.cloud_converter import CloudConverter
## forms
from .currentComposition import CurrentComposition
from .dlg_addLayer import AddLayerDialog
from .dlg_addMap import AddMapDialog
from .dlg_addMicka import AddMickaDialog
from .dlg_ConnectionManager import ConnectionManagerDialog
from .dlg_createComposite import CreateCompositeDialog
from .dlg_currentComposition import CurrentCompositionDialog
from .dlg_deleteLayerFromMap import DeleteLayerFromMapDialog
from .dlg_deleteMap import DeleteMapDialog
from .dlg_editMap import EditMapDialog
from .dlg_errMsg import ErrMsgDialog
from .dlg_GetLayers import GetLayersDialog
from .dlg_importLayer import ImportLayerDialog
from .dlg_layerDecision import LayerDecisionDialog
from .dlg_layerProperties import LayerPropertiesDialog
from .dlg_LoginQfield import LoginQfieldDialog
from .dlg_postgrePass import PostgrePasswordDialog
from .dlg_setPermission import SetPermissionDialog
from .dlg_showQProject import ShowQProjectDialog
from .dlg_timeSeries import TimeSeriesDialog
from .dlg_userInfo import UserInfoDialog
from .resources import *


class Layman(QObject):
    """QGIS Plugin Implementation."""
    reprojectionFailed = pyqtSignal(str)
    exportLayerFailed = pyqtSignal(str)
    exportLayerSuccessful = pyqtSignal(str)
    loadComposition = pyqtSignal(str,str,str)
    afterLoadedComposition = pyqtSignal()
    permissionInfo = pyqtSignal(bool,list, int)
    reoderComposition = pyqtSignal(list,set,list)
    showErr = pyqtSignal(list,str,str,Qgis.MessageLevel, str)
    tsSuccess = pyqtSignal()
    processingRaster = pyqtSignal(int,int)
    setPluginLabel = pyqtSignal(str)
    enableWfsButton = pyqtSignal(bool, QPushButton)
    successWrapper = pyqtSignal(list)
    setVisibility = pyqtSignal(QgsMapLayer)
    loadStyle = pyqtSignal(QgsMapLayer)
    emitMessageBox = pyqtSignal(list)
    readCompositionFailed = pyqtSignal()
    onRefreshCurrentForm = pyqtSignal()
    postgisFound = pyqtSignal(bool)
    showExportInfo = pyqtSignal(str)
    cleanTemp =  pyqtSignal(str)





    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        super(Layman, self).__init__()
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        ## init global variables
        self.client_id = None    
        self.client_secret = None
        #self.username = 'browser'    
        self.composite = None
        self.thread1 = None
        self.compositeList = []      
        self.CHUNK_SIZE = 1048576 ## layman client use this value    
        self.URI = None
        self.access_token = None
        self.expires_in = None
        self.refresh_token = None
        self.laymanUsername = ""
        self.authHeader = None
        self.code_verifier = None
        self.code_challenge = None
        self.wrongLayers = False
        self.Agrimail = ""        
        self.liferayServer = None
        self.laymanServer = None     
        self.authCfg =""
        self.authCfg = "957je05"
        self.importedLayer = None
        self.batchLength = 0     
        self.modified = False
        self.stylesToUpdate = set()
        self.done = 0
        self.name = ""
        self.millis = 0
        self.cataloguePosition = 1       
        self.initFiles()
        self.layerServices = {}
        self.compositionDict = {}
        self.crsChangedConnect = False
        self.current = None      
        self.project = QgsProject.instance()
        self.currentLayer = []
        self.currentLayerDict = {}
        self.laymanVersion = None     
        self.isAuthorized = True
        self.selectedWorkspace = None 
        self.noOverrideLayers = list()
        self.processingRequest = False
        self.settings = QgsSettings()
        self.mickaRet = None
        self.crsOld = 'EPSG:4326'
        self.mixedLayers = list()
        self.supportedEpsg = ["EPSG:3857", "EPSG:4326",  "EPSG:5514",  "EPSG:32633",  "EPSG:32634",  "EPSG:3034",  "EPSG:3035",  "EPSG:3059"]
        self.qLogged = False
        self.schemaURl= "https://raw.githubusercontent.com/hslayers/map-compositions/2.0.0/schema.json"
        self.schemaVersion = "2.0.0"
        self.port = "7070"
        self.DPI = self.getDPI()
        self.supportedEPSG = ['EPSG:4326', 'EPSG:3857', 'EPSG:5514', 'EPSG:102067', 'EPSG:32634', 'EPSG:32633', 'EPSG:3034', 'EPSG:3035', 'EPSG:305']      
        self.iface.layerTreeView().currentLayerChanged.connect(lambda: self.layerChanged())
        QgsProject.instance().readProject.connect(lambda: self.projectReaded(False))  
        self.processingList = []
        self.writeState(0)
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt"
        self.watcherState = QFileSystemWatcher()
        self.watcherState.addPath(path)  
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt" 
        self.dependencies = True
        self.recalculateDPI()
        if os.path.isfile(path):
            self.authFileTime =os.path.getmtime(path)        
        else:
            self.authFileTime = 0 
        self.dlgGetLayers= GetLayersDialog()
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]

        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Layman_{}.qm'.format(locale))
        self.locale = locale
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Layman')
        self.toolbar = self.iface.addToolBar(u'Layman')
        self.toolbar.setObjectName(u'Layman')
        QgsApplication.messageLog().messageReceived.connect(self.write_log_message)    
        QgsProject.instance().layerWasAdded.connect(self.on_layers_added)  
        QgsProject.instance().layerRemoved.connect(self.on_layers_removed)  
        self.pluginIsActive = False
        self.dockwidget = None
        self.loggedThrowProject = False
        ## prepare temp dir
        tempDir = tempfile.gettempdir() + os.sep + "atlas"
        try:
            os.mkdir(tempDir)
            print("Directory " , tempDir ,  " Created ")
        except FileExistsError:
            print("Directory " , tempDir ,  " already exists")
            
        self.timer = QTimer()
        self.timer.timeout.connect(self.refreshWfsLayers)
        self.timer.start(10000)             

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Layman', message)

    def rebuildLiferayCache(self):
        QgsApplication.authManager().rebuildCertTrustCache()
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):


        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def connectEvents(self): 
        self.reprojectionFailed.connect(self._onReprojectionFailed)
        self.exportLayerSuccessful.connect(self._onExportLayerSuccessful)
        self.exportLayerFailed.connect(self._onExportLayerFailed)
        self.readCompositionFailed.connect(self._onReadCompositionFailed)
        self.loadComposition.connect(self.readMapJson2)
        self.afterLoadedComposition.connect(self.afterCompositionLoaded)
        self.permissionInfo.connect(self.afterPermissionDone)
        self.reoderComposition.connect(self.reorderGroups) 
        self.showErr.connect(self.showMessageBar)
        self.tsSuccess.connect(self._onSuccessTs)
        self.processingRaster.connect(self.onRasterUpload)
        self.setPluginLabel.connect(self.onSetPluginLabel)
        self.enableWfsButton.connect(self.onWfsButton)
        self.successWrapper.connect(self.onSuccess)
        self.setVisibility.connect(self._setVisibility)
        self.loadStyle.connect(self._loadStyle)
        self.emitMessageBox.connect(self._onEmitMessageBox)
        self.onRefreshCurrentForm.connect(self.on_layers_removed)
        self.postgisFound.connect(self.on_postgis_found)
        self.showExportInfo.connect(self.showExportedCompositionInfo)
        self.cleanTemp.connect(self._cleanTemp)
        
    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""       

        
        self.textbox = QLabel(self.iface.mainWindow())
        # Set width
        self.textbox.setFixedWidth(140)
        # Add textbox to toolbar
        self.txtAction = self.toolbar.addWidget(self.textbox)
        # Set tooltip
        self.txtAction.setToolTip(self.tr(u'Current Row Number'))
        # Set callback        
        self.textbox.setText("Layman")
        self.connectEvents()      
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_1.svg'
        self.menu_Connection = self.add_action(
            icon_path,
            text=self.tr(u'Login'),
            callback=self.run_login,
            enabled_flag=True,
            parent=self.iface.mainWindow())


        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_2.svg'
        self.menu_saveLocalFile = self.add_action(
            icon_path,
            text=self.tr(u'Save as to JSON and SLD'),
            callback=self.saveLocalFile,
            enabled_flag=False,
            parent=self.iface.mainWindow())

        self.first_start = True
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'file.png'
        self.menu_loadJson = self.add_action(
            icon_path,
            text=self.tr(u'Load from JSON'),
            callback=self.loadLocalFile,
            enabled_flag=False,
            parent=self.iface.mainWindow())
        self.first_start = True

        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'layers-up.png'
        self.menu_ImportLayerDialog = self.add_action(
            icon_path,
            text=self.tr(u'Export layer to server'),
            callback=self.run_ImportLayerDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'layers-down.png'
        self.menu_AddLayerDialog = self.add_action(
            icon_path,
            text=self.tr(u'Load layer from server'),
            callback=self.run_AddLayerDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_3.svg'
        self.menu_AddMapDialog = self.add_action(
            icon_path,
            text=self.tr(u'Load map from server'),
            callback=self.run_AddMapDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())      
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'map.png'
        self.menu_CurrentCompositionDialog = self.add_action(
            icon_path,
            text=self.tr(u'Current composition'),
            callback=self.run_CurrentCompositionDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'micka.png'
        self.menu_AddMickaDialog = self.add_action(
            icon_path,
            text=self.tr(u'Browse the metadata catalog'),
            callback=self.run_AddMickaDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_4.svg'
        self.menu_UserInfoDialog = self.add_action(
            icon_path,
            text=self.tr(u'User info'),
            callback=self.run_UserInfoDialog,
            enabled_flag=True,
            parent=self.iface.mainWindow())
    #--------------------------------------------------------------------------
    def refreshCurrentForm(self, layerAdded = None):
        
        self.dlg.treeWidget_layers.clear()
        layerList = list()
        serviceList = list()
        self.instance.refreshComposition()
        composition = self.instance.getComposition()
        for i in reversed(range (0, len(composition['layers']))):                
            layerList.append(self.removeUnacceptableChars(composition['layers'][i]['title']))
            serviceList.append(composition['layers'][i]['className'])

        layers = QgsProject.instance().mapLayers().values()
        
        layersInCanvas = []
        self.layerIds = list()
        layersArr = list()
        layers = self.getLayersOrder()
        print(layers)
        print("xx")
        for layer in layers:
            layersArr.append(layer)

        if layerAdded:
            layersArr.append(layerAdded)
        for layer in layersArr:  
            self.layerIds.append([self.removeUnacceptableChars(layer.name()), layer.id()])
            layerType = layer.type()                
            item = QTreeWidgetItem()
            item.setText(0, layer.name())               
            layersInCanvas.append(self.removeUnacceptableChars(layer.name()))
            print(self.removeUnacceptableChars(layer.name()), layerList)
            print(serviceList)
            if self.removeUnacceptableChars(layer.name()) in layerList:
                i = layerList.index(self.removeUnacceptableChars(layer.name()))

                if serviceList[i] == 'OpenLayers.Layer.Vector':                       
                    item.setText(1, "WFS")
                if serviceList[i] == 'HSLayers.Layer.WMS':                       
                    item.setText(1, "WMS")
                if serviceList[i] == 'XYZ':                        
                    item.setText(1, "XYZ")
                item.setCheckState(0,2)
                if self.locale == "cs":
                    item.setToolTip(0,"Tato vrstva je zobrazena a je součástí načtené kompozice.")
                else:
                    item.setToolTip(0,"This layer is displayed and is part of the loaded composition.")
                if layerType == QgsMapLayer.VectorLayer:
                    layer.editingStopped.connect(self.layerEditStopped)            
            else:
                item.setCheckState(0,0)      
                if self.locale == "cs":
                    item.setToolTip(0,"Tato vrstva není součástí kompozice.")
                else:
                    item.setToolTip(0,"This layer is not part of the composition.")
            
                type = self.getSource(layer)
            
                if isinstance(layer, QgsRasterLayer):
                    item.setText(1, "WMS")
                if isinstance(layer, QgsVectorLayer):                
                    item.setText(1, "WMS")
                if layer.type() == QgsMapLayer.VectorLayer and layer.dataProvider().name() == 'WFS':
                    item.setText(1, "WFS") 
                self.setGuiForItem(item)
                if layerType == QgsMapLayer.VectorLayer:
                    try:
                        layer.editingStopped.disconnect()
                    except:
                        print("connect to stopEditing not exists")

            
            self.dlg.treeWidget_layers.addTopLevelItem(item)
        
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        notActive = set(layerList) - set(layersInCanvas)  
        for layer in notActive:            
            item = QTreeWidgetItem()
            
            if self.locale == "cs":
                item.setText(0,layer + " (Smazána z projektu)")
                item.setFlags(item.flags() & ~Qt.ItemIsUserCheckable)
                item.setData(0, QtCore.Qt.CheckStateRole, None)
            else:
                item.setText(0, layer + " (Removed from canvas)")
                item.setFlags(item.flags() & ~Qt.ItemIsUserCheckable)
                item.setData(0, QtCore.Qt.CheckStateRole, None)
            
            brush = QBrush()
            brush.setColor(QColor(255,17,0))
            item.setForeground(0,brush)
            item.setCheckState(0,0)
            if self.locale == "cs":
                item.setToolTip(0,"Tato vrstva se nevyskytuje v mapovém okně QGIS, ale je obsažena v kompozici.")
            else:
                item.setToolTip(0,"This layer does not appear in the QGIS map window, but is included in the composition.")
     
            self.dlg.treeWidget_layers.addTopLevelItem(item)
            self.layersWasModified()
        urlServer = self.URI.replace("/client", "")
        self.addAvailableServices(layersArr,iterator, notActive)
        return
        
    def addLayerToCurrentForm(self, layer):  
        notActive = set(layerList) - set(layersInCanvas)  
        item = QTreeWidgetItem()
        item.setText(0, layer.name())  
        item.setCheckState(0,0)      
        if self.locale == "cs":
            item.setToolTip(0,"Tato vrstva není součástí kompozice.")
        else:
            item.setToolTip(0,"This layer is not part of the composition.")
            
        type = self.getSource(layer)
            
        if isinstance(layer, QgsRasterLayer):
            item.setText(1, "WMS")
        if isinstance(layer, QgsVectorLayer):                  
            item.setText(1, "WMS")
        if layer.type() == QgsMapLayer.VectorLayer and layer.dataProvider().name() == 'WFS':
            item.setText(1, "WFS")                    
       
        self.setGuiForItem(item)  
        layersArr = list()
        layers = self.getLayersOrder()
        for layer in layers:
            layersArr.append(layer)     
        self.dlg.treeWidget_layers.addTopLevelItem(item) 
        ###  
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        self.addAvailableServices(layersArr,iterator)
    def addAvailableServices(self, layersArr, iterator, notActive):
        urlServer = self.URI.replace("/client", "")
        while iterator.value():
            item = iterator.value()                
            cell = QComboBox()
            cell.currentTextChanged.connect(self.comboBoxChanged)
            cellServices = QComboBox()
            for layer in layersArr:
                print(self.URI, layer.dataProvider().uri().uri())
                if self.removeUnacceptableChars(layer.name()) == self.removeUnacceptableChars(item.text(0)):
                    if isinstance(layer, QgsRasterLayer) and "geoserver" in layer.dataProvider().dataSourceUri():
                        cellServices.addItems(['WMS','WFS'])
                    if isinstance(layer, QgsRasterLayer) and "geoserver" not  in layer.dataProvider().dataSourceUri():
                        cellServices.addItems(['WMS'])
                    if isinstance(layer, QgsVectorLayer) and layer.dataProvider().name() != 'WFS':
                        cellServices.addItems(['WMS','WFS'])
                    if isinstance(layer, QgsVectorLayer) and layer.dataProvider().name() == 'WFS' and urlServer not in layer.dataProvider().uri().uri():
                        cellServices.addItems(['WFS'])         
                    if isinstance(layer, QgsVectorLayer) and layer.dataProvider().name() == 'WFS' and urlServer in layer.dataProvider().uri().uri():
                        cellServices.addItems(['WFS', 'WMS'])                                                        

            if (self.instance.isLayerInComposition(self.removeUnacceptableChars(item.text(0)))):
                if self.locale == "cs":
                    cell.addItems(['Beze změny','Přepsat data','Smazat'])
                else:
                    cell.addItems(['No change','Overwrite geometry','Remove'])
            elif item.text(0).replace(" (Smazána z projektu)", "").replace(" (Removed from canvas)", "") in  notActive:
                if self.locale == "cs":
                    cell.addItems(['Beze změny','Smazat'])
                else:
                    cell.addItems(['No change','Remove'])                        
            else:
                if self.checkExistingLayer(item.text(0)):           
                    if self.locale == "cs":
                        cell.addItems(['Beze změny','Přidat ze serveru','Přidat a přepsat'])
                    else:
                        cell.addItems(['No change','Add from server','Add and overwrite' ])
                else:
                    if self.locale == "cs":
                        cell.addItems(['Beze změny','Přidat'])
                    else:
                        cell.addItems(['No change','Add'])

            self.dlg.treeWidget_layers.setItemWidget(item,2, cell)

            self.dlg.treeWidget_layers.setItemWidget(item,1, cellServices)   
            ## qpushbutton   
                                            
            if self.instance.getServiceForLayer(item.text(0)) in (["HSLayers.Layer.WMS", "XYZ"]):
                cellButton = QPushButton("...", None)                
                cellButton.clicked.connect(self.showLayerProperties)
                self.dlg.treeWidget_layers.setItemWidget(item,3, cellButton)
            ##
            iterator +=1
            self.dlg.treeWidget_layers.itemWidget(item,1).setCurrentText(item.text(1))
    def on_layers_added(self, layer):  
        try:
            if self.dlg.objectName() == "CurrentCompositionDialog":           
                self.refreshCurrentForm(layer)
        except:
            pass                
    def on_layers_removed(self):  
        try:  
            if self.dlg.objectName() == "CurrentCompositionDialog":                 
                self.refreshCurrentForm()  
        except:
            pass                      
    def run_CurrentCompositionDialog(self, refresh = False):
        self.recalculateDPI()
        self.modified = False
        if not refresh:
            self.dlg = CurrentCompositionDialog()
            self.dlg.show()
        self.dlg.pushButton_close.setEnabled(False)
        self.dlg.pushButton_close.hide()
        self.dlg.pushButton_editMeta.setEnabled(False)
        self.dlg.pushButton_save.setEnabled(False)
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.pushButton_qfield.setEnabled(False)
        self.dlg.label_readonly.hide()
        self.dlg.label_log.hide()
        self.dlg.radioButton_wms.hide()
        self.dlg.radioButton_wfs.hide()
        self.dlg.label_raster.hide()
        self.dlg.treeWidget_layers.header().resizeSection(0,230);
        self.dlg.pushButton_setPermissions.setStyleSheet("#pushButton_setPermissions {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #00A2E8;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setPermissions:hover{background: #3bc4ff;}#pushButton_setPermissions:disabled{background: #64818b ;}")
        self.dlg.pushButton_new.setStyleSheet("#pushButton_new {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #00A2E8;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_new:hover{background: #3bc4ff;}#pushButton_new:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.pushButton_close2.setStyleSheet("#pushButton_close2 {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close2:hover{background: #66ab27 ;}#pushButton_close2:disabled{background: #64818b ;}")
        self.dlg.pushButton_editMeta.setStyleSheet("#pushButton_editMeta {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_editMeta:hover{background: #66ab27 ;}#pushButton_editMeta:disabled{background: #64818b ;}")
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #FF8080;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #FF2020 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.pushButton_copyUrl.setStyleSheet("#pushButton_copyUrl {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_copyUrl:hover{background: #66ab27 ;}#pushButton_copyUrl:disabled{background: #64818b ;}")
        self.dlg.pushButton_qfield.setStyleSheet("#pushButton_qfield {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_qfield:hover{background: #66ab27 ;}#pushButton_qfield:disabled{background: #64818b ;}")
        self.dlg.listWidget_service.setStyleSheet("#listWidget_service {height:20px;}")
        self.dlg.pushButton_editMeta.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'edit.png'))
        self.dlg.pushButton_save.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'save2.png'))           
        self.dlg.pushButton_qfield.clicked.connect(self.qfieldLogin)  
        if self.current != None:
            self.instance.refreshComposition()
            composition = self.instance.getComposition()
            print(composition)
            self.dlg.pushButton_editMeta.setEnabled(True)
            self.dlg.pushButton_new.setEnabled(True)
            self.dlg.pushButton_setPermissions.setEnabled(True)
            self.dlg.pushButton_close.setEnabled(True)            
            self.dlg.pushButton_save.setEnabled(True)
            self.dlg.pushButton_delete.setEnabled(True)
            self.dlg.pushButton_qfield.setEnabled(True)           
            self.dlg.pushButton_setPermissions.clicked.connect(lambda: self.showMapPermissionsDialog(composition['title'], False))
            self.dlg.pushButton_copyUrl.clicked.connect(lambda: self.copyCompositionUrl())
            layerList = list()
            serviceList = list()
            try:
                if self.locale == "cs":
                    self.dlg.setWindowTitle("Kompozice: "+composition['title'])
                else:
                    self.dlg.setWindowTitle("Composition: "+composition['title'])
            except:
                print("titulek nenačten")          
            
            try:
                print(composition)
                len(composition['layers'])
            except:            
                self.dlg.progressBar_loader.hide() 
                self.dlg.pushButton_editMeta.setEnabled(False)                
                self.dlg.pushButton_setPermissions.setEnabled(False)     
                self.dlg.pushButton_save.setEnabled(False)
                self.dlg.pushButton_delete.setEnabled(False)
                self.dlg.pushButton_qfield.setEnabled(False)   
                self.dlg.pushButton_new.clicked.connect(lambda: self.showAddMapDialog(True))
                return
            self.refreshCurrentForm()
            if self.laymanUsername != self.instance.getWorkspace():
                self.dlg.pushButton_setPermissions.setEnabled(False)
                self.dlg.pushButton_delete.setEnabled(False)
            if 'access_rights' in composition:         
                
                if self.laymanUsername not in composition['access_rights']['write']:
                    self.dlg.listWidget_layers.setEnabled(False)
                    self.dlg.treeWidget_layers.setEnabled(False)
                    self.dlg.listWidget_service.setEnabled(False)
                    self.dlg.pushButton_editMeta.setEnabled(False)
                    self.dlg.pushButton_setPermissions.setEnabled(False)
                    self.dlg.pushButton_close.setEnabled(False)
                    self.dlg.pushButton_save.setEnabled(False)
                    self.dlg.pushButton_delete.setEnabled(False)
                    self.dlg.pushButton_setPermissions.setEnabled(False)
                    self.dlg.label_readonly.show()
                else:
                    self.dlg.label_readonly.hide()
            elif self.laymanUsername == self.instance.getWorkspace():
                pass
            else:
                self.dlg.pushButton_editMeta.setEnabled(False)
                self.dlg.listWidget_layers.setEnabled(False)
                self.dlg.listWidget_service.setEnabled(False)
                self.dlg.pushButton_setPermissions.setEnabled(False)
                self.dlg.pushButton_delete.setEnabled(False)
                self.dlg.pushButton_close.setEnabled(False)
                self.dlg.pushButton_save.setEnabled(False)
                self.dlg.label_readonly.show()
        if not self.isAuthorized:      
            self.dlg.pushButton_new.setEnabled(False)
            self.dlg.pushButton_setPermissions.setEnabled(False)
            self.dlg.listWidget_layers.setEnabled(False)
            self.dlg.pushButton_editMeta.setEnabled(False)
            self.dlg.treeWidget_layers.setEnabled(False)
            self.dlg.listWidget_service.setEnabled(False)
            self.dlg.pushButton_close.setEnabled(False)
            self.dlg.pushButton_save.setEnabled(False)
            self.dlg.pushButton_delete.setEnabled(False)
        if not self.dlg.pushButton_save.receivers(self.dlg.pushButton_save.clicked) > 0:
            self.dlg.pushButton_editMeta.clicked.connect(lambda: self.showEditMapDialog())
            self.dlg.pushButton_close.clicked.connect(lambda: self.saveMapLayers())  
            self.dlg.pushButton_close2.clicked.connect(lambda: self.dlg.close())
            self.dlg.pushButton_new.clicked.connect(lambda: self.showAddMapDialog(True))
        
            self.dlg.pushButton_save.clicked.connect(lambda: self.updateComposition())
            self.dlg.checkBox_all.stateChanged.connect(self.checkAllLayers)
            self.dlg.pushButton_delete.clicked.connect(lambda: self.deleteCurrentMap())
              
            self.dlg.treeWidget_layers.itemChanged.connect(lambda: self.layersWasModified())       
            self.dlg.treeWidget_layers.itemChanged.connect(self.checkCheckbox)
        self.dlg.progressBar_loader.hide()
    def comboBoxChanged(self, text):        
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        try:
            while iterator.value():
                item = iterator.value()
                if item.checkState(0) == 0 and (self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Add from server" or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Přidat ze serveru" or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Add and overwrite" or  self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == 'Přidat' or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Přidat a přepsat" or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == 'Add'  ) :
                    item.setCheckState(0,2)

                iterator +=1
        except:
            print("neni v canvasu")
    def onSuccess(self, text): 
        if self.locale == "cs":             
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", text[0]), Qgis.Success, duration=3)
        else:             
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", text[1]), Qgis.Success, duration=3)           
    def showMessageBar(self, text, info, err, typ, url):    
        widget = QWidget()
        layout = QHBoxLayout() 
        layout.setAlignment(Qt.AlignCenter)       
        #layout.addWidget(QLabel("Layman - "+ text[0] if self.locale == "cs" else text[1]))
        button = QPushButton("Více informací" if self.locale == "cs" else "More info")
        label2 = iface.messageBar().createMessage("Layman:", text[0] if self.locale == "cs" else text[1])
        layout.addWidget(label2)
        layout.addWidget(button)
        widget.setLayout(layout)
        def showDlg():
            self.dlgErr = ErrMsgDialog()            
            self.dlgErr.pushButton_copyMsg.setStyleSheet("color: #fff !important; text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 6px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;") # Add the stylesheet             
            self.dlgErr.pushButton_copyMsg.clicked.connect(copy_to_clipboard)
            self.dlgErr.plainTextEdit.setPlainText(text[0] +" - "+ str(info) if self.locale == "cs" else text[1] +" - " + str(info))
            self.dlgErr.show()

        def copy_to_clipboard():
            message = str(err) if url == "" else str(err) + "\n" + "requested url: " + url
            clipboard = PyQt5.QtGui.QGuiApplication.clipboard()
            clipboard.setText(message)
            self.dlgErr.close()        
        button.clicked.connect(showDlg)        
        self.iface.messageBar().pushWidget(widget, typ)            
    def copyCompositionUrl(self, composition=None):  
        if not composition:
            url = self.instance.getUrl()
        else:
            if "client" in self.URI:
                url = self.URI+'/rest/'+self.dlg.treeWidget.selectedItems()[0].text(1)+'/maps/'+self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0))+'/file'
            else:  
                url = self.URI+'/client/rest/'+self.dlg.treeWidget.selectedItems()[0].text(1)+'/maps/'+self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0))+'/file'
            
        try:     
            df=pd.DataFrame([url])
            df.to_clipboard(index=False,header=False)            
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL uloženo do schránky."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL saved to clipboard."), Qgis.Success, duration=3)
        except Exception as e:
            info = str(e)
            allInfo = traceback.format_exception(etype=type(e), value=e, tb=e.__traceback__) 
            print([" URL nebylo uloženo do schránky."," URL was not saved to clipboard."],info, allInfo)
            self.showErr.emit([" URL nebylo uloženo do schránky."," URL was not saved to clipboard."],info, str(allInfo), Qgis.Warning, "")
    def run_LayerDecisionDialog(self, layersToDecision):
        self.recalculateDPI()
        self.dlg = LayerDecisionDialog()
        self.dlg.show()
        for layer in layersToDecision:
            item = QListWidgetItem()
            item.setText(layer)
            item.setCheckState(0)
            self.dlg.listWidget_layers.addItem(item)
        self.dlg.pushButton_save.clicked.connect(lambda: self.layersToUpload())
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
    def layersToUpload(self):
        for i in range(0, self.dlg.listWidget_layers.count()):
            item = self.dlg.listWidget_layers.item(i)
            if item.checkState() == 0:
                self.noOverrideLayers.append(item.text())
        
        self.dlg = self.old_dlg        
        self.updateComposition(False)
    def recalculateDPI(self):
        self.DPI = self.getDPI()
        if self.DPI < 0.85:
            self.fontSize = "12px"
        else:
            self.fontSize = "10px"
    
    def checkCheckbox(self, item, column):
        
        combobox = self.dlg.treeWidget_layers.itemWidget(item,2)
        if combobox is not None:            
            if item.checkState(column) == 2:                
                if item.text(2) != "":
                    combobox.setCurrentIndex(2)
                else:
                    combobox.setCurrentIndex(1)
            if item.checkState(column) == 0:
                combobox.setCurrentIndex(2)

    def addService(self, item):
        if item.checkState() == 2:
            print("new layer")         
    def projectReaded(self, afterLogged = False):      
        proj = QgsProject.instance()
        server, type_conversion_ok = proj.readEntry("Layman", "Server","")
        name, type_conversion_ok = proj.readEntry("Layman", "Name","")     
        print(server , name, self.URI, afterLogged)   
        if server != "" and name != "":
            if server == self.URI and not afterLogged and self.laymanUsername !="":
                print (server == self.URI)
                print(afterLogged, self.laymanUsername !="")                
                if self.locale == "cs":
                    msgbox = QMessageBox(QMessageBox.Question, "Layman", "Tento projekt obsahuje odkaz na Layman server. Chcete ho nastavit jako aktuální kompozici?")
                else:
                    msgbox = QMessageBox(QMessageBox.Question, "Layman", "This project includes link to Layman server. Do you want set the project as current composition?")
                msgbox.addButton(QMessageBox.Yes)
                msgbox.addButton(QMessageBox.No)
                msgbox.setDefaultButton(QMessageBox.No)
                reply = msgbox.exec()
                if (reply == QMessageBox.Yes):
                    if self.compositionExists(name):
                        self.current = name
                        print(self.URI, name, self.laymanUsername, self.getAuthHeader(self.authCfg),self.laymanUsername)
                        self.instance = CurrentComposition(self.URI, name, self.laymanUsername, self.getAuthHeader(self.authCfg),self.laymanUsername)                   
                    else:
                        self.current = None
                        if self.locale == "cs":
                            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Kompozice již na serveru neexistuje."), Qgis.Warning, duration=5)
                        else:
                            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Composition on server does not exists."), Qgis.Warning, duration=5)
            elif server == self.URI and afterLogged:
                if self.compositionExists(name):
                    self.current = name
                    self.instance = CurrentComposition(self.URI, name, self.laymanUsername, self.getAuthHeader(self.authCfg),self.laymanUsername)
                else:
                    self.current = None
            else:
                if afterLogged == False:
                    if self.locale == "cs":
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Tento projekt obsahuje odkaz na Layman server. Chcete se k tomuto serveru přihlásit?")
                    else:
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "This project includes link to Layman server. Do you want login?")
                               
                    msgbox.addButton(QMessageBox.Yes)
                    msgbox.addButton(QMessageBox.No)
                    msgbox.setDefaultButton(QMessageBox.No)
                    reply = msgbox.exec()
                    if (reply == QMessageBox.Yes):
                        proj = QgsProject.instance()
                        server, type_conversion_ok = proj.readEntry("Layman", "Server","")
                        self.laymanUsername, type_conversion_ok = proj.readEntry("Layman", "Workspace")
                        self.Agrimail = self.laymanUsername
                        print(self.laymanUsername)
                        path = self.plugin_dir + os.sep + "server_list.txt"
                        servers = self.csvToArray(path)
                        for i in range (0,len(servers)):
                            if server == servers[i][1]:                                
                                self.setServers(servers, i)                             
                                  
                                self.liferayServer = server.replace("/client","")
                        self.openAuthLiferayUrl2("",True)     
                        self.loggedThrowProject = True           
        else:
            
            self.current = None
    def compositionExists(self,name):     
                        
        url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name+'/file' 
        print(url)  
        print(self.laymanUsername)          
        #r = self.requestWrapper("GET", url, payload = None, files = None)
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        print(r.content)
        if r.status_code == 200:
            return True
        elif self.fromByteToJson(r.content)["code"] == 26:
            print("compositon was not set because user is not owner")
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Kompozice nebyla nastavena protože aktuální uživatel není vlastník."), Qgis.Warning, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Compositon was not set because user is not owner."), Qgis.Warning, duration=3)
        else:
            return False 
    def setGuiForItem(self, item):
        if item.text(1) == "GEOJSON":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená z lokálního souboru geojson.")
            else:
                item.setToolTip(1,"Layer loaded from a local geojson file.")

        if item.text(1) == "SHP":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená z lokálního souboru SHP.")
            else:
                item.setToolTip(1,"Layer loaded from a local SHP file.")

        if item.text(1) == "MEMORY":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva uložená v paměti QGIS. Po vypnutí QGIS bude smazána.")
            else:
                item.setToolTip(1,"Layer stored in QGIS memory. It will be deleted after QGIS is turned off.")

        if item.text(1) == "WMS":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená přes službu WMS poskytující data v rasterovém formátu. Je možné tuto službu zaměnit za vektorovou službu WFS pomocí tlačítka.")
            else:
                item.setToolTip(1,"A layer loaded over a WMS service that provides data in a raster format. It is possible to change this service to a WFS vector service using the button.")
        if item.text(1) == "WFS":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená přes službu WFS poskytující data ve vektorovém formátu. Je možné tuto službu zaměnit za rasterovou službu WMS pomocí tlačítka. Změny v této vrstvě jsou ukládány na server.")
            else:
                item.setToolTip(1,"A layer loaded over a WFS service that provides data in a vector format. It is possible to change this service to a WMS raster service using the button. Changes in this layer are saved to the server.")
        if item.text(1) == "OGR":
            if self.locale == "cs":
                item.setToolTip(1,"Vektorová vrstva načtená z lokálního souboru.")
            else:
                item.setToolTip(1,"Vector layer loaded from a local file.")

    def getSource(self, layer):
        uri = layer.dataProvider().uri().uri()
        if ".geojson" in uri:
            return "GEOJSON"
        elif ".shp" in uri:
            return "SHP"
        elif "wms" in uri:
            return "WMS"
        elif "wfs" in uri:
            return "WFS"
        elif str(layer.providerType()) == "memory":
            return "MEMORY"
        elif str(layer.providerType()) == "gdal":

            return "RASTER"
        else:
            return "OGR"
    def getDPI(self):
        return iface.mainWindow().physicalDpiX()/iface.mainWindow().logicalDpiX()


    def itemClick(self, item, col):
        if item.checkState(0) == 2 and self.checkIfLayerIsInMoreGroups(QgsProject.instance().mapLayersByName(item.text(0))[0]):
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva " + item.text(0) +" je vnořena do dvou skupin. Uložena bude pouze nadřazená.")
            else:
                QMessageBox.information(None, "Layman", "Layer " + item.text(0) +" is nested in two groups. Only parent group will be saved.")
          
        else:
            self.dlg.label_info.setText("")
    def layersWasModified(self):

        self.modified = True
    def checkIfLayerIsInMoreGroups(self, layer):
        root = QgsProject.instance().layerTreeRoot()
        tree_layer = root.findLayer(layer.id())
        if tree_layer:
            layer_parent = tree_layer.parent()

            if layer_parent:                
                group_parent = layer_parent.parent() # If you want to go up another level
                test = layer_parent.name() or 'root'
                if test == 'root':
                    return False
                if group_parent:                    
                    test = group_parent.name() or 'root'
                    if test == 'root':
                        return False
                    else:
                        return True
    def getGroupOfLayer(self, layer):
        root = QgsProject.instance().layerTreeRoot()
        tree_layer = root.findLayer(layer.id())
        if tree_layer:
            layer_parent = tree_layer.parent()

            if layer_parent:
                print("Layer parent: {}".format(layer_parent.name() or 'root'))
                group_parent = layer_parent.parent()
                return layer_parent.name() or 'root'
    def differentThanBefore(self):
        for index in range(0, self.dlg.listWidget_layers.count()):
            item = self.dlg.listWidget_layers.item(index)
            print(item.foreground().color().getRgb())
            if (item.foreground().color().green() == 18 and item.checkState() == 2):
                print("ids")
                print(self.layerIds[index])
                if self.instance.isLayerId(self.layerIds[index][1]):
                    pass 
                else: 
                    layerList = [lyr for lyr in QgsProject.instance().mapLayers().values() if lyr.name() == item.text()]
                    for layer in layerList:
                        if layer.id() == self.layerIds[index][1]:
                            data = { 'name' :  self.removeUnacceptableChars(layer.name()), 'title' : str(layer.name())}
                            self.patchThread2(layer.name(), data, layer.id())
                            self.instance.changeLayerId(layer)
                           


            if (item.foreground().color().green() == 18 and item.checkState() == 0):
                item = self.dlg.listWidget_layers.item(index)
                

                if self.instance.isLayerId(self.layerIds[index][1]):

                    del item
                    self.dlg.listWidget_layers.repaint()

    
    def progressColor(self, name, status):
        for i in range(self.dlg.treeWidget.topLevelItemCount()):
            item = self.dlg.treeWidget.topLevelItem(i)
            if item.text(0) == name:
                if status:
                    item.setData(0, Qt.ForegroundRole, QColor("green"))
                else:
                    item.setData(0, Qt.ForegroundRole, QColor("red"))

    def run_QfieldLoginDialog(self):
        self.dlg2 = LoginQfieldDialog()
        self.dlg2.show()
        self.dlg2.pushButton_Connect.setStyleSheet("#pushButton_Connect {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_Connect:hover{background: #66ab27 ;}#pushButton_Connect:disabled{background: #64818b ;}")
        self.dlg2.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        

        self.dlg2.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg2.pushButton_Connect.clicked.connect(self.loginQfield)
        if self.settings.value("laymanRememberQfield"):
            self.dlg2.checkBox_remember.setCheckState(2)
            if self.settings.value("laymenQfieldAuthCfg", type=bool):
                authcfg = self.settings.value("laymenQfieldAuthCfg")
                authManager = QgsApplication.authManager()
                if not authManager.masterPasswordHashInDatabase():
                    return QgsAuthMethodConfig()            
                cfg = QgsAuthMethodConfig()
                authManager.loadAuthenticationConfig(authcfg, cfg, True)
                self.dlg2.lineEdit_userName.setText(cfg.config('username'))
                self.dlg2.lineEdit_password.setText(cfg.config('password'))
                if self.qLogged:
                    self.loginQfield()
        else:
            self.dlg2.checkBox_remember.setCheckState(0)
        
    def showLayerProperties(self):
        self.dlg2 = LayerPropertiesDialog()
        self.dlg2.show()        
        self.dlg2.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg2.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        
        layerName = self.dlg.treeWidget_layers.selectedItems()[0].text(0)      
        self.dlg2.label_name.setText(layerName)
        self.dlg2.pushButton_save.clicked.connect(lambda: self.saveCompositionLayerChanges(layerName))
        self.dlg2.pushButton_close.clicked.connect(lambda: self.dlg2.close())
        composition = self.instance.getComposition()           
        for layer in composition['layers']:
            if layer['title'] == layerName:              
                self.dlg2.checkBox_singleTile.setCheckState(2) if layer['singleTile'] == True else self.dlg2.checkBox_singleTile.setCheckState(0)
                if "base" in layer:
                    self.dlg2.checkBox_baseLayer.setCheckState(2) if layer['base'] == True else self.dlg2.checkBox_singleTile.setCheckState(0)
                if "greyscale" in layer:
                    self.dlg2.checkBox_greyScale.setCheckState(2) if layer['greyscale'] == True else self.dlg2.checkBox_greyScale.setCheckState(0)
                else:
                    self.dlg2.checkBox_greyScale.setCheckState(0)
                ##set attributes to labels
                self.dlg2.label_opacity.setText(str(layer['opacity'] * 100) + " %")
                self.dlg2.label_max.setText("None" if not layer['maxResolution'] else "1:"+str(self.resolutionToScale(layer['maxResolution'])))
                self.dlg2.label_min.setText("1:"+str(int(self.resolutionToScale(layer['minResolution']))))                
                self.dlg2.checkBox_visibility.setChecked(True if layer['visibility'] else False) 
                self.dlg2.label_path.setText(str(layer['path']))
              
                ##
                
    def setGrayScaleForLayer(self, layer):       
        if  isinstance(layer, QgsRasterLayer):
            pipe = layer.pipe()
            if self.dlg2.checkBox_greyScale.checkState() == 2:
                pipe.hueSaturationFilter().setGrayscaleMode(1)
            if self.dlg2.checkBox_greyScale.checkState() == 0:
                pipe.hueSaturationFilter().setGrayscaleMode(0)
            layer.triggerRepaint()
    def saveCompositionLayerChanges(self, name):
        composition = self.instance.getComposition()
        if self.dlg2.checkBox_singleTile.checkState() == 2:
            composition['layers'][self.instance.getLayerOrderByTitle(name)]['singleTile'] = True
        else:
            composition['layers'][self.instance.getLayerOrderByTitle(name)]['singleTile'] = False
        if self.dlg2.checkBox_baseLayer.checkState() == 2:
            composition['layers'][self.instance.getLayerOrderByTitle(name)]['base'] = True
        else:
            composition['layers'][self.instance.getLayerOrderByTitle(name)]['base'] = False
        if self.dlg2.checkBox_greyScale.checkState() == 2:
            composition['layers'][self.instance.getLayerOrderByTitle(name)]['greyscale'] = True
        else:
            composition['layers'][self.instance.getLayerOrderByTitle(name)]['greyscale'] = False
        response = self.patchMap2()
        if  response.status_code == 200:
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Změny byly uloženy."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Changes was saved."), Qgis.Success, duration=3)
        else:
            self.showErr.emit([" Změny nebyly uloženy.", " Changes was not saved."], "code: " + str(response.status_code), str(response.content), Qgis.Warning, "")            
        self.setGrayScaleForLayer(QgsProject.instance().mapLayersByName(name)[0])
    def rememberLastServer(self, server):
        self.settings.setValue("laymanLastServer", server)
    def qfieldLogin(self):
        self.run_QfieldLoginDialog()
    def loginQfield(self):
        url = "https://app.qfield.cloud/api/v1/auth/token/"    
        login = self.dlg2.lineEdit_userName.text()
        passwd = self.dlg2.lineEdit_password.text()
        if login == "" or passwd == "":
            if self.locale == "cs":
                QMessageBox.information(None, "Info", "Nejsou vyplněny přihlašovací údaje!")

            else:
                QMessageBox.information(None, "Info", "Please fill login credentials!")
            return
        payload =  {
          "username": login,
          "email": "",
          "password": passwd
        }     
        response = self.requestWrapper("POST", url, payload, files = None)
        res = self.fromByteToJson(response.content)
        remember = self.dlg2.checkBox_remember.isChecked()
        if remember:
            self.settings.setValue("laymanRememberQfield", remember)
            self.setQAuth(username=login, password=passwd)
        else:
            self.settings.setValue("laymanRememberQfield", "")
        if response.status_code == 200:
            self.qLogged = True
            print(res['token'])
            self.Qtoken = res['token']            
            self.dlg2 = ShowQProjectDialog()
            self.dlg2.show()
            self.dlg2.progressBar.hide()
            self.dlg2.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
            self.dlg2.pushButton_exportCreate.setStyleSheet("#pushButton_exportCreate {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_exportCreate:hover{background: #66ab27 ;}#pushButton_exportCreate:disabled{background: #64818b ;}")
            self.dlg2.pushButton_export.setStyleSheet("#pushButton_export {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_export:hover{background: #66ab27 ;}#pushButton_export:disabled{background: #64818b ;}")
            ret = self.getProjectsQfield()
            try:
                composition = self.instance.getComposition()
                self.dlg2.lineEdit_name.setText(composition['name'])
                self.dlg2.lineEdit_desciption.setText(composition['abstract'])
            except:
                print("kompozice není k dispozici")
            for project in ret:               
                item = QTreeWidgetItem([project['name'],project['owner'],str(project['is_public']), project['id']])
                self.dlg2.treeWidget.addTopLevelItem(item)
            self.dlg2.pushButton_close.clicked.connect(lambda: self.dlg2.close())
            self.dlg2.pushButton_export.clicked.connect(lambda:self.uploadQFiles(self.dlg2.treeWidget.currentItem().text(3),""))
            self.dlg2.pushButton_exportCreate.clicked.connect(lambda: self.createQProject(self.dlg2.lineEdit_name.text(),self.dlg2.lineEdit_desciption.text(),self.dlg2.checkBox_private.checkState()))
            return
        else:
            self.showErr.emit(["Přihlášení nebylo úspěšné!", "Login was not successful!"], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)  
    def setQAuth(self, **kwargs: str) -> None:

        authcfg = self.settings.value("laymenQfieldAuthCfg")
        cfg = QgsAuthMethodConfig()
        authManager = QgsApplication.authManager()
        authManager.setMasterPassword()
        authManager.loadAuthenticationConfig(authcfg, cfg, True)

        cfg.setUri(self.URI)

        if cfg.id():
            for key, value in kwargs.items():
                cfg.setConfig(key, value)

            authManager.updateAuthenticationConfig(cfg)
        else:
            cfg.setMethod("Basic")
            cfg.setName("laymanQfield")            

            for key, value in kwargs.items():
                cfg.setConfig(key, value)

            authManager.storeAuthenticationConfig(cfg)
            self.settings.setValue("laymenQfieldAuthCfg", cfg.id())

    def exportJunction(self, create):
        if not create:
            threading.Thread(target=lambda: self.uploadQFiles(self.dlg2.treeWidget.currentItem().text(3),"")).start()
    def createQProject(self,name, description, private):
        url = "https://app.qfield.cloud/api/v1/projects/"
        
        if private == 2:
            private = "false"
        if private == 0:
            private = "true"        
        payload="""{
                  "name": \""""+name+"""\",
                  "description":\""""+description+"""\",
                  "private":\""""+ str(private)+"""\",
                  "is_public": \""""+str(private)+"""\"
                }"""
        headers = {
          'Authorization': 'token ' + self.Qtoken,
          'Content-Type': 'application/json'
        }        
        response = self.requestWrapper("POST", url, payload, files = None)
        res = self.fromByteToJson(response.content)        
        if response.status_code == 201:            
            self.uploadQFiles(res['id'],"")
        else:
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Taková kompozice již existuje. Vyberte prosím jiný název.")
            else:
                QMessageBox.information(None, "Layman", "This composition already exists. Please choose another name.")
    def convertQProject(self):
        import random
        import string
        letters = string.ascii_lowercase
        end = ''.join(random.choice(letters) for i in range(10))
        path = tempFileFolder = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "qfield" + end
        try:
            shutil.rmtree(path, ignore_errors=True)
        except OSError as error:
            print(error)

        try:
            os.mkdir(path)
        except OSError as error:
            print(error)
        cloud_convertor = CloudConverter(QgsProject.instance(), path)
        cloud_convertor.convert()
        return path
    def uploadQFiles(self, project, path):
        layers = QgsProject.instance().mapLayers().values()        
        if len(layers) == 0:
            if self.locale == "cs":
                QMessageBox.information(None, "Warning", "Nejsou vrstvy k exportu!")

            else:
                QMessageBox.information(None, "Warning", "No layers to export!")
            return
        mypath = self.convertQProject()
        self.dlg2.progressBar.show()
        threading.Thread(target=lambda: self.postQData(project,mypath)).start()
        

    def postQData(self, project, mypath):
        projekct_Id = project
        payload={}     
        filepaths = []
        f = []
        for (dirpath, dirnames, filenames) in walk(mypath):
            f.extend(filenames)
            break
        for files in f:
            filepaths.append(mypath + os.sep+files)
        
        for i in range (0,len(filepaths)):

            files=[
              ('file',(f[i],open(filepaths[i],'rb'),'application/octet-stream'))


              
            ]
            
            headers = {
                      'Authorization': 'token ' + self.Qtoken}
            url = "https://app.qfield.cloud/api/v1/files/" + projekct_Id+ "/" +f[i] + "/"           
                 
            response = self.requestWrapper("POST", url, payload, files)      
            print(response.status_code)
        QgsMessageLog.logMessage("qfieldExport")
    def getProjectsQfield(self):
        url = "https://app.qfield.cloud/api/v1/projects/"
        headers = {
          'Authorization': 'token ' + self.Qtoken,
          'Content-Type': 'application/json'
        }    
        response = self.requestWrapper("GET", url, payload = None, files = None)

        return (self.fromByteToJson(response.content))
    def postProjectQfield(self):
        url = "https://app.qfield.cloud/api/v1/projects/"

        payload="{  \"name\": \"test_qgis\",  \"description\": \"test_qgis\",  \"private\": true,  \"is_public\": true,  \"data_last_packaged_at\": \"2022-04-11T13:11:27.082Z\",  \"data_last_updated_at\": \"2022-04-11T13:11:27.082Z\"}"
        headers = {
          'Authorization': 'token ' + self.Qtoken,
          'Content-Type': 'application/json'
        }  
        r = self.requestWrapper("POST", url, payload, files = None)

        print(response.text)
### qfield plugin uploader
    def _prepare_uri(self, uri: Union[str, List[str], QUrl]) -> QUrl:
        if isinstance(uri, QUrl):
            return uri

        if isinstance(uri, str):
            encoded_uri = uri
        else:
            encoded_parts = []

            for part in uri:
                encoded_parts.append(urllib.parse.quote(part))

            encoded_uri = "/".join(encoded_parts)

        if encoded_uri[-1] != "/":
            encoded_uri += "/"
        self.server_url = "https://app.qfield.cloud/"
        return QUrl(self.server_url + encoded_uri)
    def _clear_cloud_cookies(self, url: QUrl) -> None:
        """When the CSRF_TOKEN cookie is present and the plugin is reloaded, the token has expired"""
        for cookie in self._nam.cookieJar().cookiesForUrl(url):
            self._nam.cookieJar().deleteCookie(cookie)
    def cloud_upload_files(
            self, uri: Union[str, List[str]], filenames: List[str], payload: Dict = None
        ) -> QNetworkReply:
            url = self._prepare_uri(uri)     

            request = QNetworkRequest(url)
            request.setAttribute(QNetworkRequest.FollowRedirectsAttribute, True)
            print(b"Authorization", "Token {}".format(self.Qtoken).encode("utf-8"))

            if self.Qtoken:
                request.setRawHeader(
                    b"Authorization", "Token {}".format(self.Qtoken).encode("utf-8")
                )

            multi_part = QHttpMultiPart(QHttpMultiPart.FormDataType)
         

            # most of the time there is no other payload
            if payload is not None:
                json_part = QHttpPart()

                json_part.setHeader(QNetworkRequest.ContentTypeHeader, "application/json")
                json_part.setHeader(
                    QNetworkRequest.ContentDispositionHeader, 'form-data; name="json"'
                )
                json_part.setBody(json.dumps(payload).encode("utf-8"))

                multi_part.append(json_part)

            # now attach each file
            for filename in filenames:
                # this might be optimized by usung QFile and QHttpPart.setBodyDevice, but didn't work on the first
                with open(filename, "rb") as file:
                    file_part = QHttpPart()
                    file_part.setBody(file.read())
                    file_part.setHeader(
                        QNetworkRequest.ContentDispositionHeader,
                        'form-data; name="file"; filename="{}"'.format(filename),
                    )

                    multi_part.append(file_part)
                print(filename)
           # with disable_nam_timeout(self._nam):
            print(multi_part)
            xx = QgsNetworkAccessManager.instance()
            threading.Thread(target=lambda: xx.post(request, multi_part)).start()


    def crsChanged(self):       
      
        if self.strip_accents(self.current) == self.strip_accents(QgsProject.instance().title()):
            if self.crsChangedConnect == True:
                print("crs changed")              
                crs = QgsProject.instance().crs()
                if  self.crsOld != crs.authid() and self.current != None:
                    self.crsOld = crs.authid()                   
                    if self.locale == "cs":
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Souřadnicový systém byl změnen na: "+ str(crs.authid())+". Chcete tento souřadnicový systém zapsat do kompozice?")
                    else:
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Coordinate system was changed to: "+ str(crs.authid())+". Do you want write it to composition?")
                    msgbox.addButton(QMessageBox.Yes)
                    msgbox.addButton(QMessageBox.No)
                    msgbox.setDefaultButton(QMessageBox.No)
                    reply = msgbox.exec()
                    if (reply == QMessageBox.Yes):
                        composition = self.instance.getComposition()
                        xmin = float(composition['extent'][0])
                        xmax = float(composition['extent'][2])
                        ymin = float(composition['extent'][1])
                        ymax = float(composition['extent'][3])
                        xcenter = float(composition['center'][0])
                        ycenter = float(composition['center'][1])
                        if crs.authid() == 'EPSG:5514':
                            composition['projection'] = str(crs.authid()).lower()
          
                        if crs.authid() == 'EPSG:4326':
                            composition['projection'] = str(crs.authid()).lower()
               
                        self.patchMap2()
                   

    def set_project_crs(self):
        # Set CRS to EPSG:4326
        QApplication.instance().processEvents()        
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(self.crsOld))
    def change_map_canvas(self, crs):   

        crs = QgsCoordinateReferenceSystem(crs)        
        QApplication.instance().processEvents()

        QgsProject.instance().setCrs(crs)
    def duplicateLayers(self):
        layerList = set()
        duplicity = list()
        ret = False

        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if item.text(0) in layerList and item.checkState(0) == 2:
                print("duplicity" + item.text(0))
                duplicity.append(item.text(0))
            if item.checkState(0) == 2:
                layerList.add(item.text(0))
                print("append" + item.text(0))            
            iterator +=1
        while iterator.value():
            item = iterator.value()

            if item.text(0) in duplicity:
                
                item.setForeground(0, QColor(255,18,0))
                ret = True
            else:
                
                item.setForeground(0, QColor(0,0,0))
            iterator +=1        
        return ret        
    def addExistingLayerToComposition(self, title, composition, type):
        name = self.removeUnacceptableChars(title)       
        self.existLayer = False       
        if (type == "wms"):
            wmsUrl = (self.URI+'/geoserver/'+self.laymanUsername+'_wms/ows').replace("/client","")
            composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"HSLayers.Layer.WMS","singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution":None,"minResolution":0,"opacity":1,"url": wmsUrl ,"params":{"LAYERS": str(name),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"visibility": True,"dimensions":{}})
        if (type == "wfs"):
            wfsUrl = (self.URI+'/geoserver/'+self.laymanUsername+'/wfs').replace("/client","")
            composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"OpenLayers.Layer.Vector","singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution":None,"minResolution":0,"name": str(name),"opacity":1 ,"protocol":{"format": "hs.format.WFS","url": wfsUrl,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"visibility": True,"dimensions":{}})

    def checkIfLayersExists(self):
        layerListServer = list()
        foundedOnServer = False
        layersToDecision = list()
        uri = self.URI + "/rest/"+self.laymanUsername+"/layers"    
        r = self.requestWrapper("GET", uri, payload = None, files = None)
        data = r.json()        
        for i in range(0, len(data)):
            layerListServer.append(data[i]['name'])
        
        for index in range(0, self.dlg.listWidget_layers.count()): ## find duplicity
            item = self.dlg.listWidget_layers.item(index)            
            
            if item.checkState() == 2 and self.removeUnacceptableChars(item.text()) in layerListServer and not self.instance.isLayerInComposition(self.removeUnacceptableChars(item.text())):
                item.setForeground(QColor(0,191,255))
                foundedOnServer = True
                layersToDecision.append(item.text())
        if foundedOnServer:
            self.old_dlg = self.dlg
            self.run_LayerDecisionDialog(layersToDecision)
            return True
        else:
            return False

    def checkUniqueName(self, layers):
        layerList = list()
        for layer in layers:
            layerList.append(layer.name())
        if(len(set(layerList)) == len(layerList)):
            return True
        else:
            return False

    def saveMapLayers(self):
        layerList = list()
        layerCheckedList = list()
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if item.checkState(0) == 2:
                layerCheckedList.append(item.text(0))
            iterator +=1  
        composition = self.instance.getComposition()  
        for i in range (0, len(composition['layers'])):       
            layerList.append(self.removeUnacceptableChars(composition['layers'][i]['title']))
        composition = self.instance.getComposition()
        self.processingRequest = True
        layers = list()
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()         
            if item.checkState(0) == 2 and  self.removeUnacceptableChars(item.text(0)) not in layerList:           
                if not self.checkLayerInCurrentCompositon(item.text(0)):              
                    layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
                    if (isinstance(layer, QgsVectorLayer)):                                
                        layerType = layer.type()
                        if layerType == QgsMapLayer.VectorLayer:
                            layer.editingStopped.connect(self.layerEditStopped)
                        layers.append(layer)
                        
                    else:
                        layers.append(layer)          

            elif item.checkState(0) == 2 and  self.removeUnacceptableChars(item.text(0))  in layerList:
                for it in self.currentSet:                    
                    if (it[2] =='Overwrite geometry'  or it[2] == "Přepsat data") and it[0] == item.text(0):
                        layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
                        if layer.type() == QgsMapLayer.VectorLayer:
                            self.postRequest(layer.name(), True)
            elif item.checkState(0) == 0 and item.text(0) not in layerCheckedList and self.dlg.treeWidget_layers.itemWidget(item,2).currentText() in ("Smazat", "Remove"):  ## může být zaškrnut i jinde, pak nemažem                                        
                pom = 0
                for i in range (0, len(composition['layers'])):
                    i = i - pom
                                      

                    if self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(item.text(0).split(" (")[0]):
                        del composition['layers'][i]
                        pom = pom + 1

            iterator +=1

        uniq = self.checkUniqueName(layers)
        if uniq:
            if len(layers) > 0:
                
                
                newLayers = list()                
                for item in self.currentSet:                    
                    layersFromServer = list()                    
             

                    if item[2] == "Add from server" or item[2] == "Přidat ze serveru":
                        for layer in layers:                                                    
                   
                            if layer.name() == item[0]:                               
                                self.addExistingLayerToComposition(layer.name(),composition,item[1].lower())
                                layers.remove(layer)
                    
                    if item[2] == "Add and overwrite" or item[2] =='Add' or item[2] == "Přidat a přepsat" or item[2] =='Přidat':
                        for layer in layers:
                            if layer.name() == item[0]:
                                newLayers.append(layer)
 

                if len(newLayers) > 0:                   
                    self.addLayerToComposite2(composition, layers)

            #self.dlg.close()
            return True
        else:
            QgsMessageLog.logMessage("uniqLayers")
            return False
    def getFinalService(self, layerName):
        for item in self.currentSet:
            if item[0] == layerName:
                return item[1]
    def setPortValue(self, index):
        if index == 0:
            self.saveToIni("port", "7070") 
            self.port = "7070"
        elif index == 1:
            self.saveToIni("port", "7071")  
            self.port = "7071" 
        elif index == 2:
            self.saveToIni("port", "7072") 
            self.port = "7072"  
        if index in (0,1,2) and self.port:            
            self.showQgisBar(["Port byl uložen.","Port has been saved."], Qgis.Success)                                                       
    def run_UserInfoDialog(self):        
        self.recalculateDPI()
        self.dlg = UserInfoDialog()
        self.dlg.show()
        self.dlg.pushButton_update.setStyleSheet("#pushButton_update {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_update:hover{background: #66ab27 ;}#pushButton_update:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.label_older.setCursor(QCursor(Qt.PointingHandCursor))
        self.dlg.label_older.mousePressEvent = lambda event: self.getOldVersion()  
        self.dlg.comboBox_port.addItem("7070")
        self.dlg.comboBox_port.addItem("7071")
        self.dlg.comboBox_port.addItem("7072")
        port = self.getConfigItem("port") 
        if not port:
            self.dlg.comboBox_port.setCurrentIndex(0)
            self.port = "7070"
        else:
            if port == "7070":
                self.port = "7070"
                self.dlg.comboBox_port.setCurrentIndex(0)
            elif port == "7071":
                self.port = "7071"
                self.dlg.comboBox_port.setCurrentIndex(1) 
            elif port == "7072":
                self.port = "7072"
                self.dlg.comboBox_port.setCurrentIndex(2) 
        self.dlg.comboBox_port.currentIndexChanged.connect(self.setPortValue)                                                        
        if self.liferayServer != None and self.laymanUsername != "":
            userEndpoint = self.URI + "/rest/current-user"            
            r = self.requestWrapper("GET", userEndpoint, payload = None, files = None)
            res = r.text
            res = self.fromByteToJson(r.content)
            versionCheck = self.checkVersion()
            self.dlg.pushButton_update.clicked.connect(lambda: self.updatePlugin(versionCheck[1]))            
            if self.isAuthorized:                
                #self.dlg.label_layman.setText(res['claims']['preferred_username'])
                self.dlg.label_layman.setText(res['username'])
                self.dlg.label_agrihub.setText(res['claims']['email'])
            else:
                self.dlg.label_layman.setText("Anonymous")
            self.dlg.label_server.setText(self.URI)

            self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
            self.dlg.label_version.setText(self.getVersion())
            self.dlg.label_versionLayman.setText(self.laymanVersion)            
            self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
                       
            self.dlg.label_avversion.setText(versionCheck[1])
            if versionCheck[0] == True:
                #self.dlg.label_avversion.hide()            
                self.dlg.pushButton_update.setEnabled(False)
        else:
            self.dlg.label_version.setText(self.getVersion())
            versionCheck = self.checkVersion()
            self.dlg.label_avversion.setText(versionCheck[1])
            if versionCheck[0] == True:
                #self.dlg.label_avversion.hide()           
                self.dlg.pushButton_update.setEnabled(False)
            self.dlg.pushButton_update.clicked.connect(lambda: self.updatePlugin(versionCheck[1]))
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
    def run_SetMapPermission(self, mapName, fromAddMap = False):
        self.recalculateDPI()
        self.dlg = SetPermissionDialog()
        self.dlg.show()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_addRead.setStyleSheet("#pushButton_addRead {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addRead:hover{background: #66ab27 ;}#pushButton_addRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeRead.setStyleSheet("#pushButton_removeRead {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeRead:hover{background: #66ab27 ;}#pushButton_removeRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_addWrite.setStyleSheet("#pushButton_addWrite {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addWrite:hover{background: #66ab27 ;}#pushButton_addWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeWrite.setStyleSheet("#pushButton_removeWrite {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeWrite:hover{background: #66ab27 ;}#pushButton_removeWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.progressBar_loader.hide()
        self.dlg.listWidget_read.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.listWidget_write.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.pushButton_removeRead.setEnabled(False)
        self.dlg.pushButton_removeWrite.setEnabled(False)
        ## combobox full text part
        self.dlg.comboBox_users.setEditable(True)
        self.dlg.comboBox_users.setInsertPolicy(QtWidgets.QComboBox.NoInsert)
        self.dlg.comboBox_users.completer().setCompletionMode(QtWidgets.QCompleter.PopupCompletion)
        ##

        uri = self.URI + "/rest/users"
        usersDict = dict()
        if self.locale == "cs":
            usersDict['EVERYONE'] = 'VŠICHNI'
        else:
            usersDict['EVERYONE'] = 'EVERYONE'
        usersDictReversed = dict()
        if self.locale == "cs":
            usersDictReversed['EVERYONE'] = 'VŠICHNI'
        else:
            usersDictReversed['EVERYONE'] = 'EVERYONE'   
        r = self.requestWrapper("GET", uri, payload = None, files = None)
        res = self.fromByteToJson(r.content)
        userCount = len(res)      
        if self.locale == "cs":
            self.dlg.comboBox_users.addItem('VŠICHNI')
        else:
            self.dlg.comboBox_users.addItem('EVERYONE')
        for i in range (0, userCount):           
            usersDict[res[i]['name'] if res[i]['name'] !="" else res[i]['username']] = res[i]['username']
            usersDictReversed[res[i]['username']] = res[i]['name'] if res[i]['name'] !="" else res[i]['username']          
            self.dlg.comboBox_users.addItem(res[i]['name'] if res[i]['name'] !="" else res[i]['username'])      
        mapName = self.removeUnacceptableChars(mapName)
        uri = self.URI + "/rest/"+self.laymanUsername+"/maps/"+mapName        
        r = self.requestWrapper("GET", uri, payload = None, files = None)
        res = self.fromByteToJson(r.content)
        self.info = 0
        lenRead = len(res['access_rights']['read'])
        lenWrite = len(res['access_rights']['write'])
        for i in range (0, lenRead):           
            self.dlg.listWidget_read.addItem(usersDictReversed[res['access_rights']['read'][i]])
        for i in range (0, lenWrite):         
            self.dlg.listWidget_write.addItem(usersDictReversed[res['access_rights']['write'][i]])
        self.dlg.pushButton_save.clicked.connect(lambda:  self.dlg.progressBar_loader.show())       
        self.dlg.pushButton_save.clicked.connect(lambda:self.askForLayerPermissionChanges([mapName], usersDict, "maps"))


        self.dlg.pushButton_addRead.clicked.connect(lambda: self.checkAddedItemDuplicity("read"))
        self.dlg.pushButton_addWrite.clicked.connect(lambda: self.setWritePermissionList())

        self.dlg.pushButton_removeRead.clicked.connect(lambda: self.removeWritePermissionList())
        self.dlg.pushButton_removeWrite.clicked.connect(lambda: self.dlg.listWidget_write.removeItemWidget(self.dlg.listWidget_write.takeItem(self.dlg.listWidget_write.currentRow())))
        if fromAddMap:
            self.dlg.rejected.connect(lambda: self.afterClosePermissionMapDialog())
        else:
            self.dlg.rejected.connect(lambda: self.afterCloseEditMapDialog())

    def run_SetPermission(self, layerName):
        self.recalculateDPI()
        self.dlg = SetPermissionDialog()
        self.dlg.show()
        self.info = 0
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_addRead.setStyleSheet("#pushButton_addRead {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addRead:hover{background: #66ab27 ;}#pushButton_addRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeRead.setStyleSheet("#pushButton_removeRead {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeRead:hover{background: #66ab27 ;}#pushButton_removeRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_addWrite.setStyleSheet("#pushButton_addWrite {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addWrite:hover{background: #66ab27 ;}#pushButton_addWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeWrite.setStyleSheet("#pushButton_removeWrite {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeWrite:hover{background: #66ab27 ;}#pushButton_removeWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.progressBar_loader.hide()
        self.dlg.listWidget_read.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.listWidget_write.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.pushButton_removeRead.setEnabled(False)
        self.dlg.pushButton_removeWrite.setEnabled(False)
        ## combobox full text part
        self.dlg.comboBox_users.setEditable(True)
        self.dlg.comboBox_users.setInsertPolicy(QtWidgets.QComboBox.NoInsert)
        self.dlg.comboBox_users.completer().setCompletionMode(QtWidgets.QCompleter.PopupCompletion)
        ##

        uri = self.URI + "/rest/users"
        usersDict = dict()
        if self.locale == "cs":
            usersDict['EVERYONE'] = 'VŠICHNI'
        else:
            usersDict['EVERYONE'] = 'EVERYONE'
        usersDictReversed = dict()
        if self.locale == "cs":
            usersDictReversed['EVERYONE'] = 'VŠICHNI'
        else:
            usersDictReversed['EVERYONE'] = 'EVERYONE'
       # r= requests.get(uri)
        r = self.requestWrapper("GET", uri, payload = None, files = None)
        res = self.fromByteToJson(r.content)        
        userCount = len(res)
        ##nabit combobox
        if self.locale == "cs":
            self.dlg.comboBox_users.addItem('VŠICHNI')
        else:
            self.dlg.comboBox_users.addItem('EVERYONE')
        for i in range (0, userCount):            
            usersDict[res[i]['name'] if res[i]['name'] !="" else res[i]['username']] = res[i]['username']
            usersDictReversed[res[i]['username']] = res[i]['name'] if res[i]['name'] !="" else res[i]['username']
            if (res[i]['name'] != self.laymanUsername):
                #self.dlg.comboBox_users.addItem(res[i]['name'] if res[i]['name'] !="" else res[i]['username']  + ' , ' + res[i]['username'])
                self.dlg.comboBox_users.addItem(res[i]['name'] if res[i]['name'] !="" else res[i]['username'])
       
        if (len(layerName) == 1):          
            layerName[0] = self.layerNamesDict[layerName[0]]
            uri = self.URI + "/rest/"+self.laymanUsername+"/layers/"+layerName[0]

            #r= requests.get(uri,headers = self.getAuthHeader(self.authCfg))
            r = self.requestWrapper("GET", uri, payload = None, files = None)  
            res = self.fromByteToJson(r.content)

            lenRead = len(res['access_rights']['read'])
            lenWrite = len(res['access_rights']['write'])
            for i in range (0, lenRead):
                               
                self.dlg.listWidget_read.addItem(usersDictReversed[res['access_rights']['read'][i]])
            for i in range (0, lenWrite): 
                self.dlg.listWidget_write.addItem(usersDictReversed[res['access_rights']['write'][i]])
        else:
            self.dlg.listWidget_read.addItem(self.name)
            self.dlg.listWidget_write.addItem(self.name)
            #self.dlg.listWidget_read.addItem(usersDict['EVERYONE'])
        self.dlg.pushButton_save.clicked.connect(lambda:  self.dlg.progressBar_loader.show())     
        self.dlg.pushButton_save.clicked.connect(lambda: self.askForMapPermissionChanges(layerName, usersDict, "layers"))
        self.dlg.pushButton_addRead.clicked.connect(lambda:  self.checkAddedItemDuplicity("read"))
        self.dlg.pushButton_addWrite.clicked.connect(lambda: self.setWritePermissionList())

        self.dlg.pushButton_removeRead.clicked.connect(lambda: self.removeWritePermissionList())
        self.dlg.pushButton_removeWrite.clicked.connect(lambda: self.dlg.listWidget_write.removeItemWidget(self.dlg.listWidget_write.takeItem(self.dlg.listWidget_write.currentRow())))

        #|self.dlg.rejected.connect(lambda: self.afterCloseEditMapDialog())
        self.dlg.rejected.connect(lambda: self.afterClosePermissionMapDialog())
    def run_EditCurrentMap(self):
        self.recalculateDPI()
        composition = self.instance.getComposition()
        self.dlg = EditMapDialog()
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton_range.setStyleSheet("#pushButton_range {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_range:hover{background: #66ab27 ;}#pushButton_range:disabled{background: #64818b ;}")
        self.dlg.pushButton_range_2.setStyleSheet("#pushButton_range_2 {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_range_2:hover{background: #66ab27 ;}#pushButton_range_2:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.lineEdit_name.hide()
        self.dlg.label_2.hide()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.lineEdit_name.setText(composition['name'])
        self.dlg.lineEdit_abstract.setText(composition['abstract'])
        self.dlg.lineEdit_title.setText(composition['title'])
        self.dlg.lineEdit_units.setText(composition['units'])
        self.dlg.lineEdit_scale.setText(str(composition['scale']))
        self.dlg.lineEdit_user.setText(composition['user']['name'])
        self.dlg.lineEdit_xmin.setText(str(composition['extent'][0]))
        self.dlg.lineEdit_xmax.setText(str(composition['extent'][2]))
        self.dlg.lineEdit_ymin.setText(str(composition['extent'][1]))
        self.dlg.lineEdit_ymax.setText(str(composition['extent'][3]))
        self.dlg.lineEdit_epsg.setEnabled(False)
        if 'projection' in composition:
            self.dlg.lineEdit_epsg.setText(composition['projection'].replace("epsg:",""))
        self.dlg.lineEdit_xmin.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_xmax.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_ymin.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_ymax.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.rejected.connect(lambda: self.afterCloseCurrentMapDialog())
        self.dlg.pushButton_save.clicked.connect(lambda: self.modifyMapNew())
        self.dlg.pushButton_range_2.clicked.connect(lambda: self.setRangeFromCanvas())
        self.dlg.pushButton_range.clicked.connect(lambda: self.setExtentFromLayers())
        if self.locale == "cs":
            self.dlg.pushButton_range.setToolTip("Získá informaci o rozsahu z wms capatibilies.")
            self.dlg.pushButton_range_2.setToolTip("Získá informaci o rozsahu z okna QGI.")
        else:
            self.dlg.pushButton_range.setToolTip("Gets spatial range information from wms capatibilies.")
            self.dlg.pushButton_range_2.setToolTip("Gets spatial range information from QGIS canvas.")

        #self.dlg.rejected.connect(lambda: self.afterCloseCompositeDialog())

        if not self.isAuthorized:
            self.dlg.pushButton_save.setEnabled(False)
            self.dlg.pushButton_range.setEnabled(False)
            self.dlg.pushButton_range_2.setEnabled(False)
        self.dlg.show()
        result = self.dlg.exec_()  

    

    def initFiles(self):
        tempFileFolder = tempfile.gettempdir() + os.sep + "atlas"
        if not os.path.exists(tempFileFolder):
            os.makedirs(tempFileFolder)
        if os.path.exists(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt") == False:
            open(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt", "w").close
        if os.path.exists(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt") == False:
            open(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt", "w").close
    def run_CreateCompositeDialog(self, fromImport = False, fromCurrent = False):
        self.recalculateDPI()
        self.dlg = CreateCompositeDialog()
        
        self.dlg.label_info.hide()
        self.dlg.label_2.hide()
        self.dlg.lineEdit.hide()

        layers = QgsProject.instance().mapLayers().values()     
        self.dlg.treeWidget.itemClicked.connect(self.setExtent)
        for layer in layers:         
            if (layer.type() == QgsMapLayer.VectorLayer):
                item = QTreeWidgetItem([layer.name()])


                self.dlg.treeWidget.addTopLevelItem(item)
        ext = iface.mapCanvas().extent()
        self.dlg.lineEdit.setValidator(QRegExpValidator(QRegExp("[a-z]{1}[a-z0-9]{1,30}")))
        self.dlg.lineEdit_3.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_4.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_5.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_6.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_2.editingFinished.connect(self.checkNameCreateMap)
        self.dlg.lineEdit_2.textEdited.connect(self.checkForChars)

        projectPath = QgsProject.instance().fileName()
        if projectPath != "":
            projectName = os.path.basename(projectPath).split(".")[0]
            if projectName[0] in ["0","1","2","3","4","5","6","7","8","9"]:
                if self.locale == "cs":
                    QMessageBox.information(None, "Message", "Není povoleno číslo v prvník znaku titulku! Není možné předvyplnit název.")
                else:
                    QMessageBox.information(None, "Message", "Number in first character of title is not allowed! Title can not be prefilled.")
            else:
                self.dlg.lineEdit_2.setText(projectName)



        self.dlg.lineEdit_3.setText(str(ext.xMinimum()))
        self.dlg.lineEdit_4.setText(str(ext.xMaximum()))
        self.dlg.lineEdit_5.setText(str(ext.yMinimum()))
        self.dlg.lineEdit_6.setText(str(ext.yMaximum()))
        self.dlg.pushButton_defaultExtent.clicked.connect(lambda: self.setDefaultExtent(ext))
        self.dlg.pushButton_defaultExtent.setStyleSheet("#pushButton_defaultExtent {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_defaultExtent:hover{background: #66ab27 ;}#pushButton_defaultExtent:disabled{background: #64818b ;}")
        self.dlg.pushButton_CreateComposition.setStyleSheet("#pushButton_CreateComposition {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_CreateComposition:hover{background: #66ab27 ;}#pushButton_CreateComposition:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")

        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")



        
        if fromCurrent:            
            self.dlg.rejected.connect(lambda: self.afterCloseNewMapDialog())
            self.dlg.pushButton_CreateComposition.clicked.connect(lambda: self.createComposite(self.dlg.lineEdit.text(),self.dlg.lineEdit_2.text(), True))
            self.dlg.pushButton_close.clicked.connect(lambda: self.afterCloseNewMapDialog())
        else:
            self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
            self.dlg.pushButton_CreateComposition.clicked.connect(lambda: self.createComposite(self.dlg.lineEdit.text(),self.dlg.lineEdit_2.text()))
        result = self.dlg.exec_()
        self.dlg.show()
    
    def getOldVersion(self):
        response = QMessageBox.question(None, "Downgrade", "Chcete nainstalovat starší verzi pro QGIS 3.24 a nižší?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
        if response == QMessageBox.Yes:
            url = "https://gitlab.com/plan4all/layman-qgis-plugin/-/archive/old/layman-qgis-plugin-old.zip"
            self.installPlugin(url)        
        else:
            print("No install")
        
    def importMapEnvironmnet(self,enabled):
        time.sleep(1)
        if enabled:

            self.dlg.pushButton_deleteMap.setEnabled(self.deleteM)
            self.dlg.pushButton_editMeta.setEnabled(self.editM)
            self.dlg.pushButton_setMapPermissions.setEnabled(self.editP)
            self.dlg.pushButton_up.setEnabled(self.up)
            self.dlg.pushButton_down.setEnabled(self.down)
            self.dlg.pushButton_deleteLayers.setEnabled(self.deleteL)         
            self.dlg.pushButton.setEnabled(True)         
            try:
                self.dlg.pushButton_addMap.setEnabled(self.add)
                self.dlg.pushButton_addRaster.setEnabled(self.addR)
            except:
                pass
        else:
            self.add = self.dlg.pushButton_addMap.isEnabled()
            self.dlg.pushButton_addMap.setEnabled(False)
            self.deleteM = self.dlg.pushButton_deleteMap.isEnabled()
            self.dlg.pushButton_deleteMap.setEnabled(False)
            self.editM = self.dlg.pushButton_editMeta.isEnabled()
            self.editP = self.dlg.pushButton_setMapPermissions.isEnabled()
            self.dlg.pushButton_editMeta.setEnabled(False)
            self.dlg.pushButton_setMapPermissions.setEnabled(False)
            self.up = self.dlg.pushButton_up.isEnabled()
            self.dlg.pushButton_up.setEnabled(False)
            self.down = self.dlg.pushButton_down.isEnabled()
            self.dlg.pushButton_down.setEnabled(False)
            self.deleteL = self.dlg.pushButton_deleteLayers.isEnabled()
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.post = self.dlg.pushButton.isEnabled()
            self.dlg.pushButton.setEnabled(False)
            self.addR = self.dlg.pushButton_addRaster.isEnabled()
            self.dlg.pushButton_addRaster.setEnabled(False)
   
    def run_DeleteMapDialog(self):
        self.recalculateDPI()
        self.dlg = DeleteMapDialog()
        self.refreshListWidgetMaps()
        self.dlg.pushButton.setEnabled(False)
        self.dlg.treeWidget.itemClicked.connect(self.enableButton)
        self.dlg.pushButton.clicked.connect(lambda: self.deleteMapFromServer(self.dlg.treeWidget.selectedItems()[0].text(0)))
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.show()
        result = self.dlg.exec_()
    def checkRegex(self, items, regex):
        for item in items:
            if not re.search(regex, item.text(0)):
                return False
        return True 
    def getRegex(self):       
        string = self.dlg2.comboBox_layers.currentText()
        print(string)
        patterns =  [r'[0-9]{8}', r'[0-9]{8}T[0-9]{6}Z', r'([0-9]{8}T[0-9]{6})000(Z)', r'([0-9]{4}).([0-9]{2}).([0-9]{2})']
        for pattern in patterns:
            print(pattern)
            if re.search(pattern, string):
                print("Pattern found in the string.")
                self.dlg2.lineEdit_regex.setText(pattern)   
        return False              
    def showTSDialog(self):
        self.dlg2 = TimeSeriesDialog()
        self.dlg2.pushButton_timeSeries.setStyleSheet("#pushButton_timeSeries {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_timeSeries:hover{background: #66ab27 ;}")        
        self.dlg2.pushButton_getRegex.setStyleSheet("#pushButton_getRegex {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_getRegex:hover{background: #66ab27 ;}")        
        self.dlg2.show()   
        self.dlg2.lineEdit_layerName.hide()   
        for item in self.dlg.treeWidget.selectedItems():
            self.dlg2.comboBox_layers.addItem(item.text(0))
        self.dlg2.pushButton_timeSeries.clicked.connect(lambda: self.prepareTSUpdate(self.dlg.treeWidget.selectedItems(), self.dlg2.lineEdit_regex.text() , self.dlg2.lineEdit_name.text()))  
        self.dlg2.pushButton_getRegex.hide()
        self.dlg2.comboBox_layers.hide()

        self.getRegex()
      
    def prepareTSUpdate(self, items, regex, title):
        resamplingMethod = self.dlg.comboBox_resampling.currentText()
        if not self.checkRegex(items, regex):
            print("regex nesedí na názvy")
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Regulerní výraz nesedí na jeden nebo více názvů.")
            else:
                QMessageBox.information(None, "Layman", "The regular expression does not match one or more names.")
            return
        self.dlg2.close()
        self.dlg.progressBar.setMaximum(0)
        self.dlg.progressBar.show()
        self.dlg.label_progress.show()
        if self.locale == "cs":
            self.dlg.label_progress.setText("Úspěšně exportováno: 0 / 1")
        else:
            self.dlg.label_progress.setText("Sucessfully exported: 0 / 1")
        threading.Thread(target=lambda: self.timeSeries(items, regex, title, resamplingMethod)).start()

    def timeSeries(self, items, regex, title, resamplingMethod="Není vybrán"):    
        if self.locale == "cs":
            resamplingMethod = self.resamplingMethods[resamplingMethod]        
        if resamplingMethod == "No value" or resamplingMethod == "Není vybrán":
            resamplingMethod = ""     
        print("time series")        
        name = self.removeUnacceptableChars(title)
        rasters = list()
        path = None
        stylePath = None
        for item in items:
            layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
            if stylePath is None: ## get first layer
                stylePath = self.getTempPath(self.removeUnacceptableChars(layer.name())).replace(".geojson",".sld")
                layer.saveSldStyle(stylePath) 
            if (r'/vsizip/') in layer.source():
                path = layer.source().replace("/"+os.path.basename(layer.source()),"").replace(r'/vsizip/','')
                break
            rasters.append(layer.source())
        crs = layer.crs().authid()
        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name
        r = requests.delete(url,headers = self.getAuthHeader(self.authCfg))        
        name = self.removeUnacceptableChars(title)
        # Create the zip archive
        if path is None:
            path = tempfile.gettempdir() + os.sep + name+".zip"
            with zipfile.ZipFile(path, "w") as zip:
                for raster in rasters:                
                    zip.write(raster, os.path.basename(raster))
        
        payload = {
                #'file': name.lower()+ext,
                'file': [name+".zip"],
                'title': title,
                'crs': crs,
                'time_regex': regex,
                'style': open(stylePath, 'rb'),
                'overview_resampling': resamplingMethod
                }    
        print(payload)
        url = self.URI+'/rest/'+self.laymanUsername+'/layers'        
        files = {'file': ("", open(path, 'rb'))} 
        files = {'style': open(stylePath, 'rb')}
        response = self.requestWrapper("POST", url, payload, files)  
        print(response.text)  
        f = open(path, 'rb')
        arr = []
        for piece in self.read_in_chunks(f):
            arr.append(piece)    
        resumableFilename = name + ".zip"
        layman_original_parameter = "file"
        resumableTotalChunks = len(arr)    
        print(resumableTotalChunks)
        filePath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) ## chunky se ukládají do adresáře v tempu
        self.layersToUpload = 1
        self.processChunks(arr, resumableFilename, layman_original_parameter,resumableTotalChunks, name,filePath,".zip")

        self.tsSuccess.emit()         
    def run_ImportLayerDialog(self):
        self.recalculateDPI()
        self.dlg = ImportLayerDialog()
        self.dlg.label_progress.hide()
        self.dlg.pushButton.clicked.connect(lambda: self.callPostRequest(self.dlg.treeWidget.selectedItems()))       
        if self.locale == "cs":
            self.dlg.label_progress.setText("Úspěšně exportováno: 0 / 0")
        else:
            self.dlg.label_progress.setText("Sucessfully exported: 0 / 0")
        self.dlg.progressBar.hide()
        self.resamplingMethods = {
            "Není vybrán": "No value",
            "Nejbližší": "nearest",
            "Průměr": "average",
            "rms": "rms",
            "Bilineární": "bilinear",
            "Gaussovská": "gauss",
            "Kubická": "cubic",
            "Kubický spline": "cubicspline",
            "Průměr magnitudy a fáze": "average_magphase",
            "Modus": "mode"
        }
        if self.locale == "cs":
            resamplingMethods = ["Není vybrán", "Nejbližší", "Průměr", "rms", "Bilineární", "Gaussovská", "Kubická", "Kubický spline", "Průměr magnitudy a fáze", "Modus"]
        else:            
            resamplingMethods = ["No value", "nearest", "average", "rms", "bilinear", "gauss", "cubic", "cubicspline", "average_magphase", "mode"]
        self.dlg.comboBox_resampling.addItems(resamplingMethods)
        self.dlg.comboBox_resampling.setEnabled(False)
        self.dlg.label_import.hide()
        self.dlg.pushButton.setEnabled(False)      
        self.dlg.pushButton_errLog.hide()
        self.dlg.pushButton_errLog.clicked.connect(self.copyErrLog)
        self.dlg.treeWidget.itemPressed.connect(self.enableButtonImport)      
        self.dlg.treeWidget.itemSelectionChanged.connect(lambda: self.disableExport())
        self.dlg.treeWidget.itemSelectionChanged.connect(lambda: self.checkIfRasterInSelected())        
        self.dlg.treeWidget.setCurrentItem(self.dlg.treeWidget.topLevelItem(0),0)
        layers = QgsProject.instance().mapLayers().values()
        mix = list()
        self.initLogFile()
        root = QgsProject.instance().layerTreeRoot()      
        layers = []    
        for child in root.children():
            self.get_layers_in_order(child, layers)
        for layer in layers:
            if (layer.type() == QgsMapLayer.VectorLayer):
                if self.isLayerPostgres(layer):
                    layerType = 'postgres'
                else:
                    layerType = 'vector layer'
            if (layer.type() == QgsMapLayer.RasterLayer):	
                if layer.dataProvider().name() == "arcgismapserver":	
                    layerType = 'arcgis layer'	
                else:	
                    layerType = 'raster layer'
            if layer.providerType() != "wms":
                item = QTreeWidgetItem([layer.name(), layerType])
        
                if (layerType == 'vector layer'):
                    if (layer.name() in self.mixedLayers and layer.name() in mix):
                        pass
                    elif (layer.name() in self.mixedLayers and layer.name() not in mix):
                        self.dlg.treeWidget.addTopLevelItem(item)
                        mix.append(layer.name())
                    else:
                        self.dlg.treeWidget.addTopLevelItem(item)
                if (layerType == 'raster layer'):
                    self.dlg.treeWidget.addTopLevelItem(item)
                if (layerType == 'postgres'):
                    self.dlg.treeWidget.addTopLevelItem(item)                      
        self.dlg.setWindowModality(Qt.ApplicationModal)
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.pushButton_errLog.setStyleSheet("#pushButton_errLog {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #c0332c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_errLog:hover{background: #c21c13 ;}#pushButton_errLog:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.selectSelectedLayer()
        self.dlg.treeWidget.header().resizeSection(0,250)
        self.dlg.show()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        result = self.dlg.exec_()
    def initLogFile(self):
        filename = tempFile = tempfile.gettempdir() + os.sep + "import_log.txt"  
        if os.path.exists(filename):    
            open(filename, 'w').close()
        else:           
            open(filename, 'x').close()        
    def setBatchLengthZero(self):
        self.batchLength = 0
    def get_layers_in_order(self,node, layers):
        if isinstance(node, QgsLayerTreeLayer):
            layers.append(node.layer())
        elif isinstance(node, QgsLayerTreeGroup):
            for child in node.children():
                self.get_layers_in_order(child, layers)        
    def run_login(self, server = False):        
        if server or self.current != None:
            server = True
            proj = QgsProject.instance()
            server, type_conversion_ok = proj.readEntry("Layman", "Server","")
            name, type_conversion_ok = proj.readEntry("Layman", "Name","")            
        self.recalculateDPI()
        self.dlg = ConnectionManagerDialog()      
        self.dlg.show()    
        if not self.dependencies:
            self.dlg.pushButton_Connect.hide()          
            self.dlg.comboBox_server.setEnabled(False)
            self.dlg.lineEdit_userName.setEnabled(False)
        self.dlg.pushButton_Connect.setEnabled(False)      
        path = self.plugin_dir + os.sep + "server_list.txt"
        servers = self.csvToArray(path)
        self.dlg.label_APIKey_2.setToolTip("Username is important only with first login")       
        

        
        for i in range (0,len(servers)):

            if not server:
                if i == len(servers) - 1: ## vyjimka pro alias na test server bude ostraneno
                    self.dlg.comboBox_server.addItem("test HUB")
                else:                 
                    if len(servers[i]) == 6:
                        self.dlg.comboBox_server.addItem(servers[i][5])  
                    else:
                       self.dlg.comboBox_server.addItem(servers[i][0].replace("www.", "").replace("https://", ""))
            else:         
                if not self.loggedThrowProject:
                    if server == servers[i][1] and server != "http://157.230.109.174/client":
                        self.dlg.comboBox_server.addItem(server.replace("/client",""))
                        self.setServers(servers, i) 
                        print("loaded name is "+name)
                        self.dlg.pushButton_Connect.clicked.connect(lambda: self.openAuthLiferayUrl2(name))
                        break
                    elif server == "http://157.230.109.174/client" and servers[i][1] == server:
                        self.dlg.comboBox_server.addItem("test HUB")                  
                        self.setServers(servers, i)
                        print("loaded name is "+name)
                        self.dlg.pushButton_Connect.clicked.connect(lambda: self.openAuthLiferayUrl2(name))
                        break
                else:      
                    if len(servers[i]) == 6:
                        self.dlg.comboBox_server.addItem(servers[i][5])  
                    else:
                       self.dlg.comboBox_server.addItem(servers[i][0].replace("www.", "").replace("https://", ""))             
  
                       
        if self.laymanUsername == "":
            if not server:
                self.setServers(servers, 0) ## nastavujeme prvni server

        self.dlg.comboBox_server.currentIndexChanged.connect(lambda: self.setServers(servers, self.dlg.comboBox_server.currentIndex()))
        if (os.path.isfile(os.getenv("HOME") + os.sep + ".layman" + os.sep +'layman_user.INI')):
            config = self.loadIni()   
            if 'login' in config['DEFAULT']:
                if len(config['DEFAULT']['login']) > 0:
                    self.Agrimail = config['DEFAULT']['login']
                    self.dlg.pushButton_Connect.setEnabled(True)  
                self.dlg.lineEdit_userName.setText(config['DEFAULT']['login'])

            for i in range (0, self.dlg.comboBox_server.count()):   
                if not server:
                    if self.authCfg == "a67e5fd":
                        self.dlg.comboBox_server.setCurrentIndex(len(servers) - 1)
                    else:
                        if "server" in config['DEFAULT']:
                            if(self.dlg.comboBox_server.itemText(i) == config['DEFAULT']['server'].replace("www.", "").replace("https://", "")):
                                self.dlg.comboBox_server.setCurrentIndex(i)
        else:
            try:
                os.makedirs(os.getenv("HOME") + os.sep + ".layman")
            except:
                print("layman directory already exists")       
            self.dlg.pushButton_Connect.setEnabled(True)
        self.dlg.lineEdit_userName.textChanged.connect(self.checkUsername)
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        if QgsSettings().value("laymanLastServer") != None:
            self.dlg.comboBox_server.setCurrentIndex(int(QgsSettings().value("laymanLastServer")))
        if not server:
            self.dlg.pushButton_Connect.clicked.connect(lambda: self.openAuthLiferayUrl2())     
        self.dlg.pushButton_NoLogin.clicked.connect(lambda: self.withoutLogin(servers, self.dlg.comboBox_server.currentIndex()))
        self.dlg.pushButton_Continue.setEnabled(False)
        registerSuffix = "/home?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&saveLastPath=false&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Fcreate_account"
        self.dlg.comboBox_server.currentTextChanged.connect(self.setReg)
        self.dlg.label_sign.setOpenExternalLinks(True)
        if self.locale == "cs":
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Registrovat</a>')
        else:
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Register</a>')
        pushbuttons = self.findChildren(QPushButton)
        for button in pushbuttons:
            print(button.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}"))
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton_Connect.setStyleSheet("#pushButton_Connect {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_Connect:hover{background: #66ab27 ;}#pushButton_Connect:disabled{background: #64818b ;}")
        self.dlg.pushButton_Continue.setStyleSheet("#pushButton_Continue {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_Continue:hover{background: #66ab27 ;} #pushButton_Continue:disabled{background: #64818b ;}")        
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_NoLogin.setStyleSheet("#pushButton_NoLogin {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_NoLogin:hover{background: #66ab27 ;}#pushButton_NoLogin:disabled{background: #64818b ;}")
        self.dlg.pushButton_logout.setStyleSheet("#pushButton_logout {color: #fff !important;font-size:"+self.fontSize+";text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_logout:hover{background: #66ab27 ;}#pushButton_logout:disabled{background: #64818b ;}")
        self.dlg.pushButton_logout.clicked.connect(lambda: self.logout())
        
        if self.laymanUsername != "":
            self.dlg.pushButton_logout.setEnabled(True)
            self.dlg.pushButton_NoLogin.setEnabled(False)
            self.dlg.pushButton_Connect.setEnabled(False)
            self.dlg.comboBox_server.setEnabled(False)
            self.dlg.lineEdit_userName.setEnabled(False)
            if self.locale == "cs":
                self.dlg.setWindowTitle("Layman - Přihlášený uživatel: " + self.laymanUsername)
            else:
                self.dlg.setWindowTitle("Layman - Logged user: " + self.laymanUsername)

        else:
            self.dlg.pushButton_logout.setEnabled(False)
            self.dlg.pushButton_NoLogin.setEnabled(True)
            self.dlg.pushButton_Connect.setEnabled(True)
            self.dlg.comboBox_server.setEnabled(True)
            self.dlg.lineEdit_userName.setEnabled(True)

        result = self.dlg.exec_()
        self.dlg.rejected.connect(lambda: self.loginReject())
    def run_AddMickaDialog(self):
        self.dlg = AddMickaDialog()
        self.dlg.show()
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton_map.setStyleSheet("#pushButton_map {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_map:hover{background: #66ab27 ;}")
        self.dlg.pushButton_search.setStyleSheet("#pushButton_search {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_search:hover{background: #66ab27 ;}")
        self.dlg.pushButton_stepRight.setStyleSheet("#pushButton_stepRight {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_stepRight:hover{background: #66ab27 ;}")
        self.dlg.pushButton_stepLeft.setStyleSheet("#pushButton_stepLeft {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_stepLeft:hover{background: #66ab27 ;}")

        QgsMessageLog.logMessage("disableProgressBar")
        threading.Thread(target=lambda: self.loadMickaMaps()).start()
        self.dlg.pushButton_map.clicked.connect(lambda: QgsMessageLog.logMessage("showLoader"))
        self.dlg.pushButton_map.clicked.connect(lambda: self.loadLayersMicka(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.indexOfTopLevelItem(self.dlg.treeWidget.currentItem())))
        self.dlg.pushButton_stepLeft.clicked.connect(lambda: self.goLeft())
        self.dlg.pushButton_stepRight.clicked.connect(lambda: self.goRight())
        self.dlg.pushButton_search.clicked.connect(lambda: self.mickaSearch())
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
    def goLeft(self):
        if self.cataloguePosition > 30:
            self.cataloguePosition = self.cataloguePosition - 20
            threading.Thread(target=lambda: self.loadMickaMaps()).start()
        else:
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Není možné listovat doleva!")
            else:
                QMessageBox.information(None, "Layman", "Not possible page to left!")
    def goRight(self):
        if self.cataloguePosition < 500:            
            self.cataloguePosition = self.cataloguePosition + 20           
            threading.Thread(target=lambda: self.loadMickaMaps()).start()
        else:
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Není možné listovat doprava!")
            else:
                QMessageBox.information(None, "Layman", "Not possible page to right!")
    def mickaSearch(self):
        query = self.dlg.lineEdit_search.text()     
        threading.Thread(target=lambda: self.loadMickaMaps(query)).start()
    def loadLayersMicka(self, name, row):   
        epsg = list()
        if "crs" in self.mickaRet['records'][row]:
            for record in  self.mickaRet['records'][row]['crs']:
                epsg.append(record['code'])     
        if 'operatesOn' in self.mickaRet['records'][row]:
            for record in  self.mickaRet['records'][row]['operatesOn']:
                if "title" in record:
                    title = record['title']
                else:
                    title = "without title"

                loaded = False
                if "online" in record:
                    for online in record['online']:
                        protocol = online['protocolText']
                        url = online['url']                 

                        if "OGC:WMS" in protocol and not loaded:
                            print("load wms")
                            urlWithParams = self.getWmsUrl(url, epsg)
                            
                            rlayer = QgsRasterLayer(urlWithParams, title, 'wms')
                            if (rlayer.isValid()):
                                QgsProject.instance().addMapLayer(rlayer)
                            
                            loaded = True

                        elif "OGC:WFS" in protocol and not loaded:
                            r = url.split("/")
                            acc = (r[len(r)-2])
                            print("load wfs")
                            if "REQUEST" in url:
                                layers = (url.split("LAYERS=")[1].lower())
                            quri = QgsDataSourceUri()
                            quri.setParam("srsname", epsg[0])
                            quri.setParam("typename", acc+":"+layers)
                            quri.setParam("restrictToRequestBBOX", "1")
                            quri.setParam("pagingEnabled", "true")
                            quri.setParam("version", "auto")
                            quri.setParam("request", "GetFeature")
                            quri.setParam("service", "WFS")
                            quri.setParam("url", url)
                            vlayer = QgsVectorLayer(url+"?" + str(quri.encodedUri(), "utf-8"), layers, "WFS")
                            print("validity WFS")
                            
                            if (rlayer.isValid()):
                                QgsProject.instance().addMapLayer(vlayer)
                            loaded = True
                        else: 
                            if "wms" in url.lower()  and not loaded:
                                urlWithParams = self.getWmsUrl(url, epsg)                                
                                rlayer = QgsRasterLayer(urlWithParams, title, 'wms')
                                if (rlayer.isValid()):
                                    QgsProject.instance().addMapLayer(rlayer)
                                    loaded = True                               


                   
                else:
                    print("online not found")
        else:
            print("neni vrstva")
        QgsMessageLog.logMessage("disableProgressBar")
    def getWmsUrl(self, url, epsg):        
        url = url.replace("%2F", "/").replace("%3A",":")
        try:
            wms = WebMapService(url)
        except:
            url = ""
        founded = False
        for e in epsg:
            if not founded:
                if "5514" in e:
                    epsg = "EPSG:5514"
                    founded = True
                elif "4326" in e:
                    epsg = "EPSG:4326"
                    founded = True
                elif "3857" in e:
                    epsg = "EPSG:3857"
                    founded = True
                elif "102067" in e:
                    epsg = "EPSG:102067"
                    founded = True
                elif "32634" in e:
                    epsg = "EPSG:32634"
                    founded = True
                elif "32633" in e:
                    epsg = "EPSG:32633"
                    founded = True
                elif "3034" in e:
                    epsg = "EPSG:3034"
                    founded = True
                elif "3035" in e:
                    epsg = "EPSG:3035"
                    founded = True
                elif "305" in e:
                    epsg = "EPSG:305"
                    founded = True
                else:
                    epsg = "EPSG:4326"
                    founded = True
        if len(epsg) == 0:
            epsg = "EPSG:4326"
      
       
        if "REQUEST" in url:
            if "LAYERS=" in url:
                layers = (url.split("LAYERS=")[1].lower())
            else:
                layers = self.parseWMSlayers(str(list(wms.contents)))
            url = (url.split("?")[0])
            urlWithParams = 'contextualWMSLegend=0&crs='+epsg+'&IgnoreReportedLayerExtents=1&dpiMode=7&featureCount=10&format=image/png&layers='+layers+'&styles=&url=' + url
        else:
            layerName = self.parseWMSlayers(str(list(wms.contents)))
            urlWithParams = 'contextualWMSLegend=0&crs='+epsg+'&dpiMode=7&featureCount=10&format=image/png&layers='+layerName+'&styles=&url=' + url.split("?")[0]
        return urlWithParams.replace("'","")
    def run_AddMapDialog(self):
        self.recalculateDPI()
        self.dlg = AddMapDialog()
        self.dlg.label_info.hide()     
        self.dlg.treeWidget.itemClicked.connect(lambda: threading.Thread(target=lambda: self.showThumbnailMap2(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)), self.dlg.treeWidget.selectedItems()[0].text(1)  ) ).start())
        self.dlg.treeWidget.itemClicked.connect(self.enableButton)
        self.dlg.treeWidget.itemClicked.connect(self.enableLoadMapButtons)
        self.dlg.treeWidget.itemClicked.connect(self.setPermissionsButton)
        self.dlg.treeWidget.setColumnWidth(0, 300)
        self.dlg.treeWidget.setColumnWidth(2, 80)
        self.dlg.label_noUser.hide()
        self.dlg.pushButton_map.clicked.connect(lambda: QgsMessageLog.logMessage("showLoader"))
        self.dlg.pushButton_map.clicked.connect(lambda: self.readMapJson(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)), 'WFS', self.dlg.treeWidget.selectedItems()[0].text(1)))
        self.dlg.pushButton_setPermissions.clicked.connect(lambda: self.showMapPermissionsDialog(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)), True))
        if not self.isAuthorized:
            self.dlg.checkBox_own.setEnabled(False)
        else:
            self.dlg.checkBox_own.setEnabled(True)
        self.dlg.pushButton_delete.clicked.connect(lambda: self.deleteMap(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)),self.getCompositionIndexByName(self.dlg.treeWidget.selectedItems()[0].text(0))))
        
        self.dlg.filter.valueChanged.connect(self.filterResults)
        self.dlg.filter.valueChanged.connect(self.disableButtonsAddMap)
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_map.setStyleSheet("#pushButton_map {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_map:hover{background: #66ab27 ;}#pushButton_map:disabled{background: #64818b ;}")
        self.dlg.pushButton_mapWFS.setStyleSheet("#pushButton_mapWFS {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_mapWFS:hover{background: #66ab27 ;}#pushButton_mapWFS:disabled{background: #64818b ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_setPermissions.setStyleSheet("#pushButton_setPermissions {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setPermissions:hover{background: #66ab27 ;}#pushButton_setPermissions:disabled{background: #64818b ;}")
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #66ab27 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.pushButton_copyUrl.setStyleSheet("#pushButton_copyUrl {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_copyUrl:hover{background: #66ab27 ;}#pushButton_copyUrl:disabled{background: #64818b ;}")
        self.dlg.checkBox_own.stateChanged.connect(self.loadMapsThread)
        self.dlg.checkBox_own.stateChanged.connect(self.disableButtonsAddMap)
        self.dlg.checkBox_own.stateChanged.connect(self.rememberValueMap)
        self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.pushButton_copyUrl.setEnabled(False)
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.pushButton_map.setEnabled(False)
        self.dlg.show()
        self.dlg.pushButton_copyUrl.clicked.connect(lambda: self.copyCompositionUrl(True))
        self.dlg.progressBar_loader.show()
        self.dlg.label_loading.show()
        if not self.isAuthorized:
            self.dlg.label_noUser.show()
        try:
            checked = self.getConfigItem("mapcheckbox")   
        except:
            checked = False
        if checked == "0":
            self.dlg.checkBox_own.setCheckState(0)
            checked = False
        if checked == "1":
            self.dlg.checkBox_own.setCheckState(2)
            checked = True
        # threading.Thread(target=lambda: self.loadMapsThread(checked)).start()
        self.loadMapsThread(checked)
        result = self.dlg.exec_()

    def writeValuesToProject(self, server, name):
        proj = QgsProject.instance()
        proj.writeEntry("Layman", "Server", server)
        proj.writeEntry("Layman", "Name", name)
        proj.writeEntry("Layman", "Workspace", self.laymanUsername)
        proj.write()
       

    def setExtentFromLayers(self):

        composition = self.instance.getComposition()
        xmin = None
        xmax = None
        ymin = None
        ymax = None
        initRun = True
        url = self.URI+'/client/geoserver/'+self.laymanUsername+'/ows?service=wms&version=1.1.1&request=GetCapabilities'
        #r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))    
        r = self.requestWrapper("GET", url, payload = None, files = None)      
        names = list()
        renge = list()
        tree = ET.ElementTree(ET.fromstring(r.content))
        root = tree.getroot()
        for name in  root.findall("./Capability/Layer/Layer/Name"):      
            names.append(name.text)
        for name in  root.findall("./Capability/Layer/Layer/LatLonBoundingBox"):           
            renge.append(name.attrib)
        for i in range(len(composition['layers'])):
            className = composition['layers'][i]['className']
            if className == 'HSLayers.Layer.WMS' or 'OpenLayers.Layer.Vector':
                name = self.removeUnacceptableChars(composition['layers'][i]['title'])
     
               
                for i in range (0, len(names)):
                    if names[i] == name:
                        print("matched")
                        if initRun:
                            ymax = renge[i]['maxy']
                            xmax = renge[i]['maxx']
                            ymin = renge[i]['miny']
                            xmin = renge[i]['minx']
                            initRun = False
                        if renge[i]['maxy'] > ymax:                            
                            ymax = renge[i]['maxy']
                        if renge[i]['maxx'] > xmax:                            
                            xmax = renge[i]['maxx']
                        if renge[i]['miny'] < ymin:                            
                            ymin = renge[i]['miny']
                        if renge[i]['minx'] < xmin:                            
                            xmin = renge[i]['minx']
        if (xmin == None or xmax == None or ymin == None or ymax==None):
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Záznam prostorového rozsahu vrstev vybrané kompozice nebyl nalezen!")
            else:
                QMessageBox.information(None, "Layman", "A record of the layers spatial extent for the selected composition was not found!")
        else:
            self.dlg.lineEdit_xmin.setText(str(xmin))
            self.dlg.lineEdit_xmax.setText(str(xmax))
            self.dlg.lineEdit_ymin.setText(str(ymin))
            self.dlg.lineEdit_ymax.setText(str(ymax))

    def setRangeFromCanvas(self):
        ext = self.iface.mapCanvas().extent()
        self.dlg.lineEdit_xmin.setText(str(ext.xMinimum()))
        self.dlg.lineEdit_xmax.setText(str(ext.xMaximum()))
        self.dlg.lineEdit_ymin.setText(str(ext.yMinimum()))
        self.dlg.lineEdit_ymax.setText(str(ext.yMaximum()))
    def withoutLogin(self, servers, i):
        self.menu_CurrentCompositionDialog.setEnabled(False)
        self.isAuthorized = False
        self.URI = servers[i][1]
        self.menu_AddLayerDialog.setEnabled(True)    
        self.laymanUsername = "Anonymous"
        self.dlg.pushButton_logout.setEnabled(True)
        self.dlg.pushButton_NoLogin.setEnabled(False)
        self.dlg.pushButton_Connect.setEnabled(False)
        self.menu_UserInfoDialog.setEnabled(True)
        self.menu_AddMapDialog.setEnabled(True)
        threading.Thread(target=lambda: self.fillCompositionDict()).start()
        self.dlg.close()
    def rememberValueLayer(self, value):
        ## 2 true, 0 false
        if value == 2:
            self.appendIniItem("layerCheckbox", "1")
        if value == 0:
            self.appendIniItem("layerCheckbox", "0")
    def rememberValueMap(self, value):
        ## 2 true, 0 false
        if value == 2:
            self.appendIniItem("mapCheckbox", "1")
        if value == 0:
            self.appendIniItem("mapCheckbox", "0")
    def saveToIni(self, key, value):
        self.appendIniItem(key, value)               
    def checkAllLayers(self, checked):
        if checked:
            iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()
                item.setCheckState(0,2)                
                self.layerServices[self.removeUnacceptableChars(item.text(0))] = "HSLayers.Layer.WMS"
                iterator +=1
     
        if not checked:
            iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()
                item.setCheckState(0,0)                
                self.layerServices = {}
                iterator +=1          
    def fillCompositionDict(self):
        url = self.URI+'/rest/maps'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        dataAll = r.json()
        for row in range(0, len(dataAll)):
            self.compositionDict[dataAll[row]['name']] = dataAll[row]['title']       
    def getNameByTitle(self, val, refresh=True):   
        ret = None     
        for key, value in self.compositionDict.items():
            if val == value:   
                ret = key              
                return ret
        ## if title not found refresh dict
        if ret == None and refresh:
            self.fillCompositionDict()
            ret = self.getNameByTitle(val, False)
            return ret
                     
    def loadMickaMaps(self, query = ""):
        self.dlg.progressBar_loader.show()
        self.dlg.treeWidget.clear()       
        uri = self.URI.replace("/client", "")       
        if query == "":
            url = uri + "/micka/csw/?request=GetRecords&query=type%3D%27application%27&format=text/json&MaxRecords=20&StartPosition="+str(self.cataloguePosition)+"&sortby=&language=eng&template=report-layman"           
        else:
            url = uri + "/micka/csw/?request=GetRecords&query=AnyText%20like%20%27*"+query+"*%27%20AND%20type%3D%27application%27&format=text/json&MaxRecords=10&StartPosition=&sortby=&language=eng&template=report-layman"            
        r = self.requestWrapper("GET", url, payload = None, files = None)         
        self.mickaRet = r.json() 
        for record in self.mickaRet['records']:          
            if "title" in record:
                item = QTreeWidgetItem([record['title']])
                self.dlg.treeWidget.addTopLevelItem(item)
     
        QgsMessageLog.logMessage("disableProgressBar")
    def loadMapsThread(self, onlyOwn):        
        self.dlg.treeWidget.clear()
        url = self.URI+'/rest/'+self.laymanUsername+'/maps?order_by=title'
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()     
        if onlyOwn and self.isAuthorized:
            for row in range(0, len(data)):
                if "native_crs" in data[row]:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own", data[row]['native_crs']])
                else:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own"])
                self.dlg.treeWidget.addTopLevelItem(item)
            QgsMessageLog.logMessage("loadMaps")
        elif not self.isAuthorized:
            url = self.URI+'/rest/maps?order_by=title'
            r = self.requestWrapper("GET", url, payload = None, files = None)       
            dataAll = r.json()
            permissions = ""
            for row in range(0, len(dataAll)):
                if "native_crs" in dataAll[row]:
                    item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],"read", dataAll[row]['native_crs']])
                else:
                    item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],"read"])
                self.dlg.treeWidget.addTopLevelItem(item)
        else:
            url = self.URI+'/rest/maps?order_by=title'
            r = self.requestWrapper("GET", url, payload = None, files = None)
            dataAll = r.json()
            permissions = ""
            for row in range(0, len(dataAll)):
                if self.laymanUsername in dataAll[row]['access_rights']['read'] or "EVERYONE" in dataAll[row]['access_rights']['read']:
                    permissions = "read"
                if self.laymanUsername in dataAll[row]['access_rights']['write'] or "EVERYONE" in dataAll[row]['access_rights']['write']:
                    permissions = "write"
                if dataAll[row] in data:
                    permissions = "own"
                if permissions != "":
                    if "native_crs" in dataAll[row]:
                        item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions, dataAll[row]['native_crs']])
                    else:
                        item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions])                    
                    self.dlg.treeWidget.addTopLevelItem(item)
        QgsMessageLog.logMessage("loadMaps")

    def run_AddLayerDialog(self):
        self.recalculateDPI()

        self.dlg = AddLayerDialog()
        self.dlg.pushButton_layerRedirect.hide()
        self.dlg.pushButton_layerRedirect.setEnabled(False)
        self.dlg.pushButton_urlWfs.setEnabled(False)
        self.dlg.pushButton_urlWms.setEnabled(False)
        self.dlg.pushButton.setEnabled(False)
        self.dlg.pushButton_wfs.setEnabled(False)
        self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.label_noUser.hide()
        self.dlg.pushButton_postgis.hide() 
        try:
            checked = self.getConfigItem("layercheckbox")            
        except:
            checked = False
        if checked == "0":
            self.dlg.checkBox_own.setCheckState(0)
            checked = False
        if checked == "1":
            self.dlg.checkBox_own.setCheckState(2)
            checked = True
        
        self.dlg.pushButton_delete.clicked.connect(lambda: self.callDeleteLayer(self.dlg.treeWidget.selectedItems(), self.layerNamesDict))
        self.dlg.pushButton_layerRedirect.clicked.connect(lambda: self.layerInfoRedirect(self.dlg.treeWidget.selectedItems()[0].text(0)))
        self.dlg.pushButton.clicked.connect(lambda: self.readLayerJson(self.dlg.treeWidget.selectedItems(), "WMS"))
        self.dlg.pushButton_wfs.clicked.connect(lambda: self.readLayerJson(self.dlg.treeWidget.selectedItems(), "WFS"))
        self.dlg.pushButton_postgis.clicked.connect(lambda: self.loadPostgisLayer(self.dlg.treeWidget.selectedItems()[0]))
        self.dlg.pushButton_urlWms.clicked.connect(lambda: self.copyLayerUrl(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.selectedItems()[0].text(1),"wms"))
        self.dlg.pushButton_urlWfs.clicked.connect(lambda: self.copyLayerUrl(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.selectedItems()[0].text(1),"wfs"))
        if not self.isAuthorized:
            self.dlg.label_noUser.show()
            self.dlg.checkBox_own.setEnabled(False)
        self.dlg.treeWidget.itemClicked.connect(self.enableDeleteButton)
        self.dlg.treeWidget.itemSelectionChanged.connect(self.checkSelectedCount)
        self.dlg.treeWidget.itemClicked.connect(self.setPermissionsButton)
        self.dlg.treeWidget.itemClicked.connect(lambda: threading.Thread(target=lambda: self.showThumbnail2(self.dlg.treeWidget.selectedItems()[0])).start())      
        self.dlg.treeWidget.itemClicked.connect(lambda: threading.Thread(target=lambda: self.checkIfPostgis(self.dlg.treeWidget.selectedItems()[0])).start())          
        self.dlg.filter.valueChanged.connect(self.filterResults)
        self.dlg.treeWidget.setColumnWidth(0, 300)
        self.dlg.treeWidget.setColumnWidth(2, 80)
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())        
        self.dlg.checkBox_own.stateChanged.connect(self.rememberValueLayer)
        self.dlg.pushButton_setPermissions.clicked.connect(lambda: self.showPermissionsDialog(self.dlg.treeWidget.selectedItems()))
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #66ab27 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #66ab27 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.pushButton_wfs.setStyleSheet("#pushButton_wfs {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_wfs:hover{background: #66ab27 ;}#pushButton_wfs:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_setPermissions.setStyleSheet("#pushButton_setPermissions {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setPermissions:hover{background: #66ab27 ;}#pushButton_setPermissions:disabled{background: #64818b ;}")
        self.dlg.pushButton_urlWms.setStyleSheet("#pushButton_urlWms {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+"; text-decoration: none;   background: #999999;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_urlWms:hover{background: #707070 ;}#pushButton_urlWms:disabled{background: #999999 ;}")
        self.dlg.pushButton_urlWfs.setStyleSheet("#pushButton_urlWfs {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+"; text-decoration: none;   background: #999999;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_urlWfs:hover{background: #707070 ;}#pushButton_urlWfs:disabled{background: #999999 ;}")
        self.dlg.pushButton_postgis.setStyleSheet("#pushButton_postgis {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_postgis:hover{background: #66ab27 ;}#pushButton_postgis:disabled{background: #64818b ;}")
        # self.threadLayers = threading.Thread(target=lambda: self.loadLayersThread(checked))
        # self.threadLayers.start()
        self.dlg.progressBar_loader.show()
        self.loadLayersThread(checked)
        self.dlg.checkBox_own.stateChanged.connect(self.loadLayersThread)     
        if self.isAuthorized:
            self.dlg.checkBox_own.setEnabled(True)
        else:
            self.dlg.checkBox_own.setEnabled(False)
        
        self.dlg.label_loading.show()
        self.dlg.show()
        result = self.dlg.exec_()

    def loadLayersThread(self, onlyOwn=False):
        self.layerNamesDict = dict()
        self.dlg.treeWidget.clear()
        if self.laymanUsername and self.isAuthorized:              
            url = self.URI+'/rest/'+self.laymanUsername+'/layers'            
            r = self.requestWrapper("GET", url, payload = None, files = None)     
            #print(self.getAuthHeader(self.authCfg))      
            #r = requests.request("GET", url = url, headers=self.getAuthHeader(self.authCfg))        
            data = r.json()            
            if onlyOwn:                
                for row in range(0, len(data)):                   
                    if "native_crs" in data[row]:
                        item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own",data[row]['native_crs']])
                    else:
                        item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own"])
                    self.dlg.treeWidget.addTopLevelItem(item)
                    self.layerNamesDict[data[row]['title']] = data[row]['name']
                QgsMessageLog.logMessage("layersLoaded")
            else:
                url = self.URI+'/rest/layers'
                r = self.requestWrapper("GET", url, payload = None, files = None)     
                dataAll = r.json()
                permissions = ""
                for row in range(0, len(dataAll)):
                    if self.laymanUsername in dataAll[row]['access_rights']['read'] or "EVERYONE" in dataAll[row]['access_rights']['read']:
                        permissions = "read"
                    if self.laymanUsername in dataAll[row]['access_rights']['write'] or "EVERYONE" in dataAll[row]['access_rights']['write']:
                        permissions = "write"
                    if dataAll[row] in data:
                        permissions = "own"
                    if permissions != "":
                        if "native_crs" in dataAll[row]:
                            item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions,dataAll[row]['native_crs']])
                        else:
                            item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions])                       
                        
                        self.layerNamesDict[dataAll[row]['title']] = dataAll[row]['name']
                        self.dlg.treeWidget.addTopLevelItem(item)
                QgsMessageLog.logMessage("layersLoaded")
        else:
            url = self.URI+'/rest/layers'   
            r = self.requestWrapper("GET", url, payload = None, files = None)
            data = r.json()
            for row in range(0, len(data)):
                if "EVERYONE" in data[row]['access_rights']['read']:
                    permissions = "read"
                if "EVERYONE" in data[row]['access_rights']['write']:
                    permissions = "write"
                if "native_crs" in dataAll[row]:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],permissions,data[row]['native_crs']])
                else:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],permissions])
                self.layerNamesDict[data[row]['title']] = data[row]['name']
                self.dlg.treeWidget.addTopLevelItem(item)
            QgsMessageLog.logMessage("layersLoaded")
    def addExternalWMSToComposite(self, name):       
        nameInList = name
        name = self.removeUnacceptableChars(name).lower()
        self.addExistingWMSLayerToCompositeThread2(name, nameInList)        
  
    def listToString(self, s):

        str1 = ","
        return (str1.join(s))
    def checkAddedItemDuplicity(self, type):
        itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
        itemsTextListWrite =  [str(self.dlg.listWidget_write.item(i).text()) for i in range(self.dlg.listWidget_write.count())]
        
        allItems = [self.dlg.comboBox_users.itemText(i) for i in range(self.dlg.comboBox_users.count())]      
        if self.dlg.comboBox_users.currentText() in allItems:
            if type == "read":
              
                if ((self.dlg.comboBox_users.currentText() not in itemsTextListRead)):                  
                    self.dlg.listWidget_read.addItem(self.dlg.comboBox_users.currentText())
                    return True
                else:
                    
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Tento uživatel se již v seznamu vyskytuje!")
                    else:
                        QMessageBox.information(None, "Layman", "This user already exists in the list!")
                    return False
            else:              
                if ((self.dlg.comboBox_users.currentText() not in itemsTextListWrite) and type == "write"):               
                    return True
                else:                    
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Tento uživatel se již v seznamu vyskytuje!")
                    else:
                        QMessageBox.information(None, "Layman", "This user already exists in the list!")
                    return False
    def askForMapPermissionChanges(self,layerName, userDict, type):
        self.failed = list()
        self.statusHelper = True       
        threading.Thread(target=lambda: self.updatePermissions(layerName, userDict, type)).start()
    def askForLayerPermissionChanges(self,layerName, userDict, type):
        self.failed = list()
        self.statusHelper = True
        if self.hasLaymanLayer(layerName[0]):
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Nastavení práv", "Chcete tato práva nastavit i na jednotlivé vrstvy, které mapová kompozice obsahuje?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Update permissions", "Do you want set these permissions to layers included in map composition?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):  
                threading.Thread(target=lambda: self.updatePermissions(layerName,userDict,type, False)).start()
                threading.Thread(target=lambda: self.updateAllLayersPermission(userDict, layerName, False)).start()
            else:
                threading.Thread(target=lambda: self.updatePermissions(layerName,userDict,type, False)).start()
        else:
            threading.Thread(target=lambda: self.updatePermissions(layerName,userDict,type, False)).start()

    def hasLaymanLayer(self, name):
        url = self.URI + "/rest/"+self.laymanUsername+"/maps/"+name+"/file"
        r = self.requestWrapper("GET", url, payload = None, files = None)
        composition = r.json()
        for layer in composition['layers']:
            if layer['className'] == "OpenLayers.Layer.Vector":
                if '/geoserver/' in layer['protocol']['url']:
                    return True
            if layer['className'] == "HSLayers.Layer.WMS":
                if '/geoserver/' in layer['url']:
                    return True
        return False
    def updateAllLayersPermission(self, userDict, layerName, loaded = False):      
        if loaded:
            composition = self.instance.getComposition()
        else:
            url = self.URI + "/rest/"+self.laymanUsername+"/maps/"+layerName[0]+"/file"
            r = self.requestWrapper("GET", url, payload = None, files = None)
            composition = r.json()
        itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
        itemsTextListWrite =  [str(self.dlg.listWidget_write.item(i).text()) for i in range(self.dlg.listWidget_write.count())]
        userNamesRead = list()
        for pom in itemsTextListRead:         
            if pom == "VŠICHNI":
                userNamesRead.append("EVERYONE")          
            else:
                userNamesRead.append(userDict[pom])
        userNamesWrite = list()    
        for pom in itemsTextListWrite:
            if pom == "VŠICHNI":
                userNamesWrite.append("EVERYONE")
            else:
                print(userDict[pom])
                userNamesWrite.append(userDict[pom])
        data = {'access_rights.read': self.listToString(userNamesRead),   'access_rights.write': self.listToString(userNamesWrite)}       
        for layer in composition['layers']:
            name = None
            if (layer['className'] == 'OpenLayers.Layer.Vector'):
                name = layer['protocol']['LAYERS']
            if (layer['className'] == 'HSLayers.Layer.WMS'):
                name = layer['params']['LAYERS']
            if name is not None:
                response = requests.patch(self.URI+'/rest/'+self.laymanUsername+'/layers/'+name, data = data,  headers = self.getAuthHeader(self.authCfg))  
                
                if (response.status_code != 200):        
                    try:
                        if self.fromByteToJson(response.content)["code"] == 15:
                            print("layer not present")
                            return
                    except:
                        pass                                      
                    self.showErr.emit(["Práva nebyla uložena! - " + name,"Permissions was not saved' - "+ name], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)
            else:
                print("there is not possible set permissions for layer")
          
    def updatePermissions(self,layerName, userDict, type, check=False):       
        itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
        itemsTextListWrite =  [str(self.dlg.listWidget_write.item(i).text()) for i in range(self.dlg.listWidget_write.count())]
        userNamesRead = list()  
        print(itemsTextListRead)
        for pom in itemsTextListRead:         
            if pom == "VŠICHNI":            
                userNamesRead.append("EVERYONE")          
            else:
                print(pom)
                if "," in pom:
                    pom = pom.split(", ")[1]                                
                userNamesRead.append(userDict[pom])
        userNamesWrite = list()      
        for pom in itemsTextListWrite:
            if pom == "VŠICHNI":
                userNamesWrite.append("EVERYONE")
            else:
                if "," in pom:
                    pom = pom.split(", ")[1]
                userNamesWrite.append(userDict[pom])
        data = {'access_rights.read': self.listToString(userNamesRead),   'access_rights.write': self.listToString(userNamesWrite)}     
        
      
        for layer in layerName:
            layer = self.removeUnacceptableChars(layer)      
            url = self.URI+'/rest/'+self.laymanUsername+'/'+type+'/'+layer
            response = requests.patch(url, data = data,  headers = self.getAuthHeader(self.authCfg))  
            if (response.status_code != 200):
                self.failed.append(layer)         
                self.showErr.emit(["Práva nebyla uložena! - " + layer,"Permissions was not saved' - "+ layer], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)
                self.statusHelper = False
                   
        ## rekurzivni zmeny        
        if (type == "maps" and check):
            if self.statusHelper:
                layerList = list()              
                for i in range (0,len(self.compositeList)):
                    if self.compositeList[i]['name'] == self.removeUnacceptableChars(layerName[0]):
                        for j in range (0,len(self.compositeList[i]['layers'])):
                            if self.compositeList[i]['layers'][j]['className'] == "HSLayers.Layer.WMS":
                                layerList.append(self.compositeList[i]['layers'][j]['params']['LAYERS'])
                            if self.compositeList[i]['layers'][j]['className'] == "OpenLayers.Layer.Vector":                            
                                layerList.append(self.removeUnacceptableChars(self.compositeList[i]['layers'][j]['title']))
                print("updating permissions for layers:" + str(layerList))
                threading.Thread(target=self.updatePermissions(layerList,userDict, "layers")).start()
                return
            else:
                self.permissionInfo.emit(False, self.failed, 0)              

        elif (type == "layers" and check):
            for name in layerName:
                compositionList = self.getCompositionsByLayer(name)
                for comp in compositionList:
                    self.updatePermissions([comp],userDict, "maps", False)
                    return      
        else:      
            if (self.statusHelper and self.info == 0):
                print(self.failed)
                self.permissionInfo.emit(True, self.failed, 0)                
            else:
                self.permissionInfo.emit(False, self.failed, 0)               
    def afterPermissionDone(self, success, failed, info):
        if self.dlg.objectName() == "PermissionsDialog":
            self.dlg.progressBar_loader.hide()             
            if success:
                if self.locale == "cs":
                    QMessageBox.information(None, "Uloženo", "Práva byla úspěšně uložena.")
                else:
                    QMessageBox.information(None, "Saved", "Permissions was saved successfully.")
                self.dlg.close()                    
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Chyba", "Práva nebyla uložena pro vrstvu/mapu: " + str(failed).replace("[","").replace("]",""))
                else:
                    QMessageBox.information(None, "Error", "Permissions was not saved for layer/map: " + str(failed).replace("[","").replace("]",""))

    def disableExport(self):
        if self.dlg.treeWidget.selectedItems() == []:
            self.dlg.pushButton.setEnabled(False)
        else:
            self.dlg.pushButton.setEnabled(True)
    def checkIfRasterInSelected(self):
        value = False
        for item in self.dlg.treeWidget.selectedItems():
            layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
            if isinstance(layer, QgsRasterLayer):
               value = True 
        self.dlg.comboBox_resampling.setEnabled(value)
            
                            
    def disableButtonsAddMap(self):
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.pushButton_delete.setEnabled(False)
    def filterResults(self, value):

        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if value.lower() not in item.text(0).lower():
                item.setHidden(True)
            else:
                item.setHidden(False)             
            iterator +=1

    def setExtent(self, it, col):
        layer = QgsProject.instance().mapLayersByName(it.text(0))
        ext = layer[0].extent()       
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        if QgsProject.instance().crs().authid() == 'EPSG:5514' and layer[0].crs().authid() == 'EPSG:4326':         
            max = self.krovakToWgs(xmax, ymax)
            min = self.krovakToWgs(xmin, ymin)
            xmin = min[0]
            xmax = max[0]
            ymin = min[1]
            ymax = max[1]
        if QgsProject.instance().crs().authid() == 'EPSG:4326' and layer[0].crs().authid() == 'EPSG:5514':
            max = self.wgsToKrovak(xmax, ymax)
            min = self.wgsToKrovak(xmin, ymin)
            xmin = min[0]
            xmax = max[0]
            ymin = min[1]
            ymax = max[1]
        self.dlg.lineEdit_3.setText(str(xmin))
        self.dlg.lineEdit_4.setText(str(xmax))
        self.dlg.lineEdit_5.setText(str(ymin))
        self.dlg.lineEdit_6.setText(str(ymax))
        if self.locale == "cs":
            self.dlg.label_4.setText("Rozsah vrstvy: " + it.text(0))
        else:
            self.dlg.label_4.setText("Extent of layer: " + it.text(0))
    def wgsToKrovak(self, x, y):
        src = QgsCoordinateReferenceSystem(5514)
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        point = tform.transform(QgsPointXY(x, y))
        return [point.x(), point.y()]
    def krovakToWgs(self, x, y):
        src = QgsCoordinateReferenceSystem(4326)
        dest = QgsCoordinateReferenceSystem(5514)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        point = tform.transform(QgsPointXY(x, y))
        return [point.x(), point.y()]
    def selectSelectedLayer(self):
        try:
            layer = self.iface.activeLayer()
            layerName = layer.name()
        except:
            print("no layer in list")
            return
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if item.text(0) == layerName:
                self.dlg.treeWidget.setCurrentItem(item, 1)
            iterator +=1

    def checkPermissionButtons(self):
        try:
            if self.dlg.listWidget_read.currentItem().text() == self.name:
                self.dlg.pushButton_removeRead.setEnabled(False)
            else:
                self.dlg.pushButton_removeRead.setEnabled(True)
        except:
            self.dlg.pushButton_removeRead.setEnabled(False)
            print("neni vybrana polozka")
        try:
            if self.dlg.listWidget_write.currentItem().text() == self.name:
                self.dlg.pushButton_removeWrite.setEnabled(False)
            else:
                self.dlg.pushButton_removeWrite.setEnabled(True)
        except:
            self.dlg.pushButton_removeWrite.setEnabled(False)
            print("neni vybrana polozka")

    def checkSelectedCount(self):
        if (len(self.dlg.treeWidget.selectedItems()) > 1):
            self.dlg.pushButton_setPermissions.setEnabled(True)            
            self.dlg.pushButton_delete.setEnabled(True)
            self.dlg.pushButton.setEnabled(True)
            self.dlg.checkBox_thumbnail.setCheckState(2)
        else:
            self.dlg.pushButton_setPermissions.setEnabled(True)            
            self.dlg.pushButton_delete.setEnabled(True)
            self.dlg.pushButton.setEnabled(True)

    def enableDeleteButton(self, item, col):
        self.dlg.pushButton.setEnabled(True)
        self.dlg.pushButton_urlWfs.setEnabled(True)
        self.dlg.pushButton_urlWms.setEnabled(True)
        
        self.dlg.pushButton_layerRedirect.setEnabled(True)
        self.dlg.pushButton_delete.setEnabled(True)
        self.dlg.pushButton_setPermissions.setEnabled(True)          
        self.checkSelectedCount()
        threading.Thread(target=self.checkServiceButtons).start()

    def checkServiceButtons(self): 
        if self.dlg.objectName() == "AddLayerDialog":  
            if self.checkFileType(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.selectedItems()[0].text(1)) == "vector": 
                if self.dlg.objectName() == "AddLayerDialog":                      
                    self.enableWfsButton.emit(True, self.dlg.pushButton_wfs)      
            elif self.checkFileType(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.selectedItems()[0].text(1)) == "raster":
                if self.dlg.objectName() == "AddLayerDialog":                  
                    self.enableWfsButton.emit(False, self.dlg.pushButton_wfs)        
            else:
                if self.dlg.objectName() == "AddLayerDialog":            
                    self.enableWfsButton.emit(True, self.dlg.pushButton_wfs)
        
    def onWfsButton(self, enable, button):
        try:    
            button.setEnabled(enable)
        except:
            pass            
    def checkFileType(self, name, workspace):
        name = self.layerNamesDict[name]   
        url = self.URI+'/rest/'+workspace+'/layers/'+self.removeUnacceptableChars(name)
        response = self.requestWrapper("GET", url, payload = None, files = None)
        res = self.fromByteToJson(response.content)
        if "file" in res:
            return res['file']['file_type']
        else:
            return ""
    def enableButton(self, item, col):


        self.dlg.pushButton.setEnabled(True)        
        self.dlg.pushButton_mapWFS.setEnabled(True)     
        self.dlg.pushButton_deleteLayers.setEnabled(True)
        self.dlg.pushButton_editMeta.setEnabled(True)
        self.dlg.pushButton_setMapPermissions.setEnabled(True)
        self.dlg.pushButton_addRaster.setEnabled(True)
        try:
            if (self.WMSenable):
                self.dlg.pushButton_addWMS.setEnabled(True)
        except:
            pass
  
    def getVersion(self):
        config = configparser.ConfigParser()
        config.read(os.path.join(self.plugin_dir ,'metadata.txt'))
        version = config.get('general', 'version')
        return(version)
    def checkUsername(self, name):
        n = name.split("@")
        if(len(n[0]) > 0):
            self.dlg.pushButton_Connect.setEnabled(True)        
            self.Agrimail = name
        else:
            self.dlg.pushButton_Connect.setEnabled(False)

    def setListLayer(self):       
        count = self.dlg.treeWidget_listLayers.topLevelItemCount()
        if count == 0:
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.dlg.pushButton_up.setEnabled(False)
            self.dlg.pushButton_down.setEnabled(False)
        else:         
            self.dlg.treeWidget_listLayers.setCurrentItem(self.dlg.treeWidget_listLayers.topLevelItem(0),0)
            self.dlg.pushButton_deleteLayers.setEnabled(True)
            self.dlg.pushButton_up.setEnabled(True)
            self.dlg.pushButton_down.setEnabled(True)

    def csvToArray(self, path):
        results = []
        with open(path) as csvfile:
            reader = csv.reader(csvfile,delimiter=',') # change contents to floats
            for row in reader: # each row is a list
                results.append(row)
        return results
    def copyLayerUrl(self, name, workspace, service):
        url = self.URI+'/rest/'+workspace+'/layers/'+self.removeUnacceptableChars(name)
        response = self.requestWrapper("GET", url, payload = None, files = None)
        res = self.fromByteToJson(response.content)
        if res == None:
            return
        
        try:
            df=pd.DataFrame([res[service]['url']])
            df.to_clipboard(index=False,header=False)
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL uloženo do schránky."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL saved to clipboard."), Qgis.Success, duration=3)
        except:
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL nebylo uloženo do schránky."), Qgis.Warning)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL was not saved to clipboard."), Qgis.Warning)




    def setReg(self, str):
        registerSuffix = "/home?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&saveLastPath=false&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Fcreate_account"
        if self.locale == "cs":
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Registrovat</a>')
        else:
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Register</a>')
    def loginReject(self):                
        if self.dlg.pushButton_Continue.isEnabled():
            self.getToken()
        else:          
            self.dlg.close()
            
    def logout(self):
        self.loggedThrowProject = False
        self.disableEnvironment()          
        userEndpoint = self.URI+ "/rest/current-user"
        r = self.requestWrapper("DELETE", userEndpoint, payload = None, files = None)
        QgsApplication.authManager().clearCachedConfig(self.authCfg)         
        ## flush variables             
        try:
            self.textbox.setText("Layman")
            self.dlg.close() 
            self.dlg.pushButton_NoLogin.setEnabled(True)
            self.dlg.pushButton_Connect.setEnabled(True)
        except:
            pass
        try:
            QgsProject.instance().crsChanged.disconnect()
        except:
            print("crs changed not connected")
        self.menu_UserInfoDialog.setEnabled(True)
        self.laymanUsername = ""
        self.isAuthorized = False        
        self.current = None
        self.liferayServer = None     
        self.compositeList = []
       
     
    def disableEnvironment(self):
        self.menu_saveLocalFile.setEnabled(False)
        self.menu_loadJson.setEnabled(False)
        self.menu_ImportLayerDialog.setEnabled(False)
        self.menu_AddMickaDialog.setEnabled(False)
        self.menu_AddLayerDialog.setEnabled(False)
        self.menu_AddMapDialog.setEnabled(False)
        self.menu_ImportLayerDialog.setEnabled(False)   
        self.menu_UserInfoDialog.setEnabled(False)
        self.menu_CurrentCompositionDialog.setEnabled(False)
    def setServers(self, servers, i):      
        self.URI = servers[i][1]
        self.liferayServer = servers[i][0]
        self.client_id = servers[i][2]    
        try:
            self.client_secret = servers[i][3]
            self.authCfg = servers[i][4]
        except:
            pass 

    def enableLoadMapButtons(self, item):
        self.dlg.pushButton_mapWFS.setEnabled(True)
        self.dlg.pushButton_map.setEnabled(True)
    def setPermissionsButton(self, item):
        if item.text(2) != "own":
            self.dlg.pushButton_setPermissions.setEnabled(False)
            self.dlg.pushButton_delete.setEnabled(False)
        else:
            self.dlg.pushButton_setPermissions.setEnabled(True)
            self.dlg.pushButton_delete.setEnabled(True)
    def enableButtonImport(self, item, column):
        if (len(self.dlg.treeWidget.selectedItems()) > 0):
            self.dlg.pushButton.setEnabled(True)
        else:
            self.dlg.pushButton.setEnabled(False)


    def enableButton(self, item):
        self.dlg.pushButton_copyUrl.setEnabled(True)
        try:
            if (self.WMSenable):
                self.dlg.pushButton_addWMS.setEnabled(True)
        except:
            pass
        try: ## addMap nemá combobox
            if (self.dlg.mMapLayerComboBox.count() > 0):            
                self.dlg.pushButton_map.setEnabled(True)
            else:
                self.dlg.pushButton.setEnabled(False)
        except:
            self.dlg.pushButton.setEnabled(True) ## addMap nemá combobox nastavujeme funkční tlačítko
 
    def listCompositeLayers(self, it):
         self.dlg.listWidget_listLayers2.clear()
         for i in range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])):

            self.dlg.listWidget_listLayers2.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
    def deleteLayerThrowCompositions(self, name, title):

        name = self.removeUnacceptableChars(name).lower()

    def checkLayersInComopsitions(self, name):
        name = self.removeUnacceptableChars(name)      
        inComposite = False
        for x in range (0,len(self.compositeList)):
            for i in range (0,len(self.compositeList[x]['layers'])):
                try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                    if (name == self.compositeList[x]['layers'][i]['params']['LAYERS']):
                        inComposite = True
                except:
                    pass
                try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                    if (name == self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['name'])):
                        inComposite = True
                except:
                    pass
        return inComposite
    def checkLayerInCurrentCompositon(self, name):
        composition = self.instance.getComposition()
        inComposite = False

        for i in range (0,len(composition['layers'])):
            try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                if (name == composition['layers'][i]['params']['LAYERS']):
                    inComposite = True
            except:
                pass
            try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                if (name == composition['layers'][i]['protocol']['LAYERS']):
                    inComposite = True
            except:
                pass
        return inComposite
    def getCompositionsByLayer(self, name):
        compositionList = list()
        for x in range (0,len(self.compositeList)):
            for i in range (0,len(self.compositeList[x]['layers'])):              
                if (self.removeUnacceptableChars(name) == self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['title'])):
                    compositionList.append(self.compositeList[x]['name'])
        return compositionList

    def refreshCompositeList(self, new=False):
        try:
            self.dlg.listWidget.clear()
        except:
            return


        for i in range (0, len(self.compositeList)):        
           self.dlg.listWidget.addItem(self.compositeList[i]['title'])
        if new:
            self.dlg.listWidget.setCurrentRow(self.dlg.listWidget.count() -1)
            self.dlg.pushButton_deleteMap.setEnabled(True)
            self.dlg.pushButton_editMeta.setEnabled(True)
            self.dlg.pushButton_setMapPermissions.setEnabled(True)
            self.dlg.pushButton_down.setEnabled(False)
            self.dlg.pushButton_up.setEnabled(False)
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.dlg.listWidget_listLayers.clear()
            self.dlg.treeWidget_listLayers.clear()


    def refreshLayerList(self):       
        self.dlg.treeWidget_listLayers.clear()
        for i in (range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers']))):           
            item = QTreeWidgetItem([self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'],self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['className'] ])
            self.dlg.treeWidget_listLayers.addTopLevelItem(item)           

    def refreshLayerListNonReversed(self):  
        self.dlg.treeWidget_listLayers.clear()
        for i in range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])):
            item = QTreeWidgetItem([self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['title'],self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['className'] ])
            self.dlg.treeWidget_listLayers.addTopLevelItem(item)       
    def refreshLayerListReversed(self):       
        self.dlg.treeWidget_listLayers.clear()
        for i in range (len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])-1,-1,-1):       
            item = QTreeWidgetItem([self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['title'],self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['className'] ])
            self.dlg.treeWidget_listLayers.addTopLevelItem(item)       
        try:
            self.dlg.treeWidget_listLayers.setCurrentItem(self.dlg.treeWidget_listLayers.topLevelItem(0),0)            
        except:
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.dlg.pushButton_up.setEnabled(False)
            self.dlg.pushButton_down.setEnabled(False)
    def transformLayer(self, layer):
        path = tempFile = tempfile.gettempdir() + os.sep + layer.name()
        parameter = {'INPUT': layer, 'TARGET_CRS': 'EPSG:4326', 'OUTPUT': path}
        processing.run('qgis:reprojectlayer', parameter)
        return path
    def refreshListWidgetMaps(self):
        self.dlg.treeWidget.clear()
        url = self.URI+'/rest/'+self.laymanUsername+'/maps'
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()
        for row in range(0, len(data)):
            item = QTreeWidgetItem([data[row]['name']])
            self.dlg.treeWidget.addTopLevelItem(item)

    def showAddMapDialog(self, fromCurrent=False):
        self.old_dlg = self.dlg
        self.run_CreateCompositeDialog(True, fromCurrent)

    ### connect
    def afterCloseCompositeDialog(self):
        self.dlg = self.old_dlg
        self.refreshCompositeList()
    def afterCloseCurrentMapDialog(self):
        self.dlg = self.old_dlg

    def afterCloseEditMapDialog(self):
        self.dlg = self.old_dlg
        self.refreshCompositeList()
    def afterCloseNewMapDialog(self):
        self.dlg.close()
        self.dlg = self.old_dlg
        # self.dlg.close()
        self.run_CurrentCompositionDialog(True)
    def afterClosePermissionMapDialog(self):
        self.dlg = self.old_dlg

    def showMapPermissionsDialog(self, x, fromAddMap = False):
        if fromAddMap:
            self.dlg.pushButton_map.setEnabled(True)
            self.dlg.progressBar_loader.hide()
        self.old_dlg = self.dlg
        self.run_SetMapPermission(x, fromAddMap)
    def showPermissionsDialog(self, x):
        self.old_dlg = self.dlg
        names = list()
        for i in range (0, len(self.dlg.treeWidget.selectedItems())):
            names.append(self.dlg.treeWidget.selectedItems()[i].text(0))
        self.run_SetPermission(names)
    def showEditMapDialog(self):
        self.old_dlg = self.dlg      
        self.run_EditCurrentMap()
          
    def refreshItems(self):

         self.dlg.listWidget_listLayers.clear()
         for i in range (0,len(self.compositeList)):         
           self.dlg.listWidget_listLayers.addItem(self.compositeList[i]['title'])

    def saveEditedToComposite(self,x):
        self.compositeList[x]['abstract'] =  self.dlg.lineEdit_abstract.text()
        self.compositeList[x]['title'] =  self.dlg.lineEdit_title.text()
    def callDeleteLayer(self, layers, layerNames):       
        items = list()
        for i in range (0, len(self.dlg.treeWidget.selectedItems())):
            items.append(self.dlg.treeWidget.selectedItems()[i].text(0))
        question = True            
        if len(items) > 1:
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Chcete opravdu smazat vybrané vrstvy?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Do you want delete selected layers?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):                
                question = False
        for j in range (0, len(items)):
            
            self.layerDelete(items[j], layerNames, question)
    def layerDelete(self, name,layerNames, question = True):
        title = name
        name = layerNames[title]
        if question:
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Chcete opravdu smazat vrstvu "+str(name)+"?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Do you want delete layer "+str(name)+"?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
        else:
            reply = QMessageBox.Yes             
        if (reply == QMessageBox.Yes):
            if (self.checkLayersInComopsitions(name) == True):
                if self.locale == "cs":
                    msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Vrstva " +name +" je obsažena v některých mapových kompozicích. Pokud budete pokračovat, bude smazána také z těchto kompozic.")
                else:
                    msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Layer " +name +"  is included in other compositions. It will be deleted from every composition.")
                msgbox.addButton(QMessageBox.Yes)
                msgbox.addButton(QMessageBox.No)
                msgbox.setDefaultButton(QMessageBox.No)
                reply = msgbox.exec()
                if (reply == QMessageBox.Yes):
                    # name = self.removeUnacceptableChars(name).lower()
                    threading.Thread(target=lambda: self.layerDeleteThread(name)).start()
                    self.dlg.progressBar_loader.show()                    
                    self.deleteLayerThrowCompositions(name, title)
               
            else:
                name = self.removeUnacceptableChars(name).lower()
                threading.Thread(target=lambda: self.layerDeleteThread(name)).start()
                self.dlg.progressBar_loader.show()


    def layerDeleteThread(self, name):
        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name
        response = self.requestWrapper("DELETE", url, payload = None, files = None)      
        try:
            checked = self.getConfigItem("layercheckbox")
        except:
            checked = False
        if checked == "0":
            checked = False
        if checked == "1":
            checked = True
        self.loadLayersThread(checked)

        if response.status_code == 200:
            QgsMessageLog.logMessage("delLay")
        else:
            self.showErr.emit(["Vrstva nebyla smazána!", "Layer was not deleted!"], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)
    def deleteItemFromTreeWidget(self,name):     
        iterator= QTreeWidgetItemIterator(self.dlg.treeWidget);
        items = []
        while iterator.value():
            item = iterator.value()
            iterator+=1
            if (self.removeUnacceptableChars(item.text(0)) == self.removeUnacceptableChars(name)):
                print("vyhodit")
            else:
                items.append(item.text(0))
        self.dlg.treeWidget.clear()
        for i in items:
            item = QTreeWidgetItem([i])
            self.dlg.treeWidget.addTopLevelItem(item)

   
    def syncOrder2(self, layers):
        self.showExportInfo.emit("Aktualizace pořadí vrstev" if self.locale == "cs" else "Update layer order")
        serverOrder = self.instance.getLayerNamesList()
        composition = self.instance.getComposition()   
        print(composition)
        if len(serverOrder) != len(QgsProject.instance().mapLayers()):
            print("pocet vrstev na serveru a v projektu je jiný. Není možné synchronizovat pořadí.")
            return   
        backup = copy.deepcopy(composition)
        composition['layers'] = []
        print(serverOrder)
        
        for layer in layers:
            if self.removeUnacceptableChars(layer.name()) in serverOrder:
                print(layer.name())
                for lay in backup['layers']:
                    if self.removeUnacceptableChars(layer.name()) == self.removeUnacceptableChars(lay['title']):
                        composition['layers'].append(lay)
        if len(serverOrder) != len(composition['layers']):
            composition = copy.deepcopy(backup)
            print("změna pořadí selhala vracím zpět.")
        print("order changed to:")
        print(composition['layers'])
    
    def updateComposition(self, checkD = True):       
        self.currentSet = list()
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        try:
            while iterator.value():
                item = iterator.value()
                self.currentSet.append([item.text(0),self.dlg.treeWidget_layers.itemWidget(item,1).currentText(),self.dlg.treeWidget_layers.itemWidget(item,2).currentText()])
                iterator +=1
        except:
            print("neni v canvasu")        
        self.ThreadsUploadsA = set()
        for thread in threading.enumerate():
            self.ThreadsUploadsA.add(thread.name)
   
        #self.differentThanBefore() zvýraznit
        if self.duplicateLayers():
            if self.locale == "cs":
                QMessageBox.information(None, "Warning", "Duplicita v názvech vrstev!")
            else:
                QMessageBox.information(None, "Warning", "Duplicity in layer names!")
            return
        ## hlidani nove pridanych vrstev pro symbologii      
        composition = self.instance.getComposition()
        layerList = []
        for i in range (0, len(composition['layers'])):
            layerList.append(self.removeUnacceptableChars(composition['layers'][i]['title']))           
        layers = list()

        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            self.itemClick(item,0) ## check for subgroups
            if item.checkState(0) == 2 and  self.removeUnacceptableChars(item.text(0)) not in layerList:                
                lay = QgsProject.instance().mapLayersByName(item.text(0))[0]
                lay.styleChanged.connect(self.layerStyleToUpdate)
            iterator +=1


        threading.Thread(target=lambda: self.updateCompositionThread()).start()




        self.dlg.progressBar_loader.show()
        self.dlg.pushButton_save.setEnabled(False)
    def updateLayerPropsInComposition(self):
        self.showExportInfo.emit("Aktualizace viditelnost vrstev" if self.locale == "cs" else "Update layer visibility")
        composition = self.instance.getComposition()
        root = QgsProject.instance().layerTreeRoot()
        sublayers = root.children()     
        for lay in composition['layers']:
            for sublayer in sublayers:                
                if isinstance(sublayer, QgsLayerTreeLayer):                   
                    if self.removeUnacceptableChars(sublayer.name()) == self.removeUnacceptableChars(lay['title']):                     
                        self.modifyPathOfLayer(sublayer.name(),"")
                        self.modifyVisibilityOfLayer(sublayer.name(),sublayer.isVisible())
                        self.modifyScaleOfLayer(sublayer.layer(), sublayer.layer().hasScaleBasedVisibility())
                        self.modifyOpacity(sublayer)
              
                if isinstance(sublayer, QgsLayerTreeGroup):
                    for layer in sublayer.findLayers():
                        if self.removeUnacceptableChars(layer.name()) == self.removeUnacceptableChars(lay['title']):      
                            self.modifyPathOfLayer(layer.name(),sublayer.name())
                            self.modifyVisibilityOfLayer(layer.name(),layer.isVisible())
                            if (isinstance(layer, QgsLayerTreeLayer)):
                                layer = layer.layer()      
                            self.modifyScaleOfLayer(layer, layer.hasScaleBasedVisibility())       
                            self.modifyOpacity(layer)                    
        
    
    def updateCompositionThread(self):      
        composition = self.instance.getComposition()
        i= 0
        for item in self.currentSet:
            service = self.instance.getServiceForLayer(item[0])
            if service == "HSLayers.Layer.WMS" and item[1] == "WFS":
                self.wms_wfs3(item[0], i, item[1])                
            if service == "OpenLayers.Layer.Vector" and item[1] == "WMS":                
                self.wms_wfs3(item[0], i, item[1])
            i = i +1    
        
        duplicityCheck = self.saveMapLayers()
        if not duplicityCheck:
            QgsMessageLog.logMessage("layersLoaded")            
            return
        self.modified = False 
        if len(self.stylesToUpdate) > 0:
            layerList = set()
            for layer in self.stylesToUpdate:
                layerList.add(self.removeUnacceptableChars(layer.name()))
            for lay in composition['layers']:
                if self.removeUnacceptableChars(lay['title']) in layerList:
                    try:
                        self.updateLayerStyle(lay['title'], lay['workspace'])
                    except:
                        self.updateLayerStyle(lay['title'], self.laymanUsername) ## pokud je starší typ kompozice
                    try:
                        self.stylesToUpdate.remove(QgsProject.instance().mapLayersByName(lay['title'])[0])
                    except:
                        print("neni v poli")
        
        self.updateLayerPropsInComposition()       
        self.syncOrder2(self.getLayersOrder())    
        self.patchMap2()        
        self.writeValuesToProject(self.URI, composition['name'])   
        QgsMessageLog.logMessage("updateMapDone")
        QgsMessageLog.logMessage("layersUploaded")
        self.showExportInfo.emit("F")
        self.onRefreshCurrentForm.emit()
    def updateLayerStyle(self, layer_name, workspace):
        title = layer_name       
        layer_name = self.removeUnacceptableChars(layer_name)
        layer = QgsProject.instance().mapLayersByName(title)[0]
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0") and qgis.core.Qgis.QGIS_VERSION_INT <= 32603:
            tempFile = self.getTempPath(os.path.basename(layer_name))
            stylePath = tempFile + ".qml"
            layer.saveNamedStyle(stylePath)
            
        else:
            tempFile = self.getTempPath(os.path.basename(layer_name))
            stylePath = tempFile + ".sld"
            layer.saveSldStyle(stylePath)
            
        files = [('style', open(stylePath, 'rb'))]
        url = self.URI+'/rest/'+workspace+"/layers/" + layer_name
        data = { 'name' :  layer_name, 'title' : str(layer.name())}

        url = self.URI+'/rest/'+workspace+"/layers/" + layer_name
        r = self.requestWrapper("PATCH", url, data, files)      
        

   
    def checkCompositionChanges(self, layers):
        composition = self.instance.getComposition()
        check = False
       
        matched = 0
        j = 0
        try:
            len(composition['layers']) == None
        except:
            print("excepted")
            return True
       
        for i in range (len(layers)-1,-1,-1):
            
            if (i - j) < len(composition['layers']):
                name = self.removeUnacceptableChars(composition['layers'][i - j]['title'])
                print(name,self.removeUnacceptableChars(layers[i].name()))
                if name == self.removeUnacceptableChars(layers[i].name()):
                    #check = True
                    print("matched")
                    matched = matched + 1
                    lastMatchIndex = i
                else:
                    print("no matched")
                    j = j + 1 ## pokud se jména nepotkaji j reprezentuje "zpozdeni indexu" kompozice vuci vrstvam v layertree
            else:
                print("no matched")
                j = j + 1

            i = i + 1
        if (matched == len(composition['layers'])):            
            return True
        else:            
            return False
    def addLayerRefresh(self):
        self.dlg.treeWidget.clear()
        url = self.URI+'/rest/'+self.laymanUsername+'/layers'
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()
        for row in range(0, len(data)):

            item = QTreeWidgetItem([self.getLayerTitle(data[row]['name'])])
            self.dlg.treeWidget.addTopLevelItem(item)
    def checkIfMapExist(self, name):
        url = self.URI + "/rest/"+self.laymanUsername+"/maps/"+str(name)+"/file"
        r = self.requestWrapper("GET", url, payload = None, files = None)


        if (r.status_code == 404):
            return False
        else:
            return True  

    def wms_wfs3(self, layerName, index, type):        
        somethingChanged = False
        composition = self.instance.getComposition()
        layerName = self.removeUnacceptableChars(layerName)
        for layer in composition['layers']:
            if self.removeUnacceptableChars(layer['title']) == layerName:
                if type == "WFS":
                    print("set layer to wfs")                 
                    styleUrl = self.URI+'/rest/'+self.laymanUsername+'/layers/'+ layerName + "/style"
                    composition['style'] = styleUrl
                    try:
                        name = layer['params']['LAYERS']
                    except:
                        print("convert wms to wfs failed")  
                        return
                    url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name                  
                    r = self.requestWrapper("GET", url, payload = None, files = None)
                    data = r.json()
                    url = data['wfs']['url']

                    layer['className'] = "OpenLayers.Layer.Vector"
                    layer['protocol'] = {
                        "FROMCRS": "EPSG:3857",
                        "INFO_FORMAT": "application/vnd.ogc.gml",
                        "LAYERS": name,
                        "format": "hs.format.WFS",
                        "url": url
                      }

                    del layer['params']
                    del layer['url']
                    self.layerServices[self.removeUnacceptableChars(layer['title'])] = 'OpenLayers.Layer.Vector'                    
                    somethingChanged = True

                if type == 'WMS':
                    print("set layer to wms")                 
                    composition['style'] = '' 
                    url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layerName         
                    r = self.requestWrapper("GET", url, payload = None, files = None)
                    data = r.json()
                    url = data['wms']['url']

                    layer['className'] = "HSLayers.Layer.WMS"
                    layer['url'] = url
                    layer['params'] = {
                        "FORMAT": "image/png",
                        "FROMCRS": "EPSG:3857",
                        "LAYERS": self.removeUnacceptableChars(layerName),
                        "VERSION": "1.3.0"
                      }
                    del layer['protocol']
                    self.layerServices[self.removeUnacceptableChars(layer['title'])] = "HSLayers.Layer.WMS"                    

                    somethingChanged = True             


    def checkIfPostgis(self, it):
        layer = self.removeUnacceptableChars(it.text(0))
        workspace = it.text(1)
        url = self.URI+'/rest/'+workspace+'/layers/'+str(layer).lower() 
        r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        if "db" in r.json():
            if "external_uri" in r.json()["db"]:
                self.postgisFound.emit(True)
            else:
                self.postgisFound.emit(False)            
        else:
            self.postgisFound.emit(False) 
    def showThumbnail2(self, it):        
        layer = it.text(0) ##pro QTreeWidget
        workspace = it.text(1)
        if self.dlg.checkBox_thumbnail.checkState() == 0:
            try:
                layer = self.layerNamesDict[layer]        
                url = self.URI+'/rest/' +workspace+'/layers/'+layer+'/thumbnail'
                
                r = requests.get(url, headers = self.getAuthHeader(self.authCfg))                  
                data = r.content      
                pixmap = QPixmap(200, 200)
                pixmap.loadFromData(data)
                smaller_pixmap = pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.FastTransformation)
                self.dlg.label_thumbnail.setPixmap(smaller_pixmap)
                self.dlg.label_thumbnail.setAlignment(Qt.AlignCenter)
            except:
                pass             

    def showThumbnailMap2(self, it, workspace):
        
        map = it ##pro QTreeWidget
        if self.dlg.checkBox_thumbnail.checkState() == 0:
            try:
                map = self.removeUnacceptableChars(str(map))
                url = self.URI+'/rest/'+workspace+'/maps/'+str(map).lower()+'/thumbnail'            
                r = requests.get(url, headers = self.getAuthHeader(self.authCfg))               
                data = r.content             
                pixmap = QPixmap(200, 200)
                pixmap.loadFromData(data)
                smaller_pixmap = pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.FastTransformation)
                self.dlg.label_thumbnail.setPixmap(smaller_pixmap)      
            except:
                pass
    def setup_oauth(self, authcfg_id, authcfg_name):
      
        if authcfg_id != '7f22y3f' and authcfg_id != '7f22y3d' and authcfg_id != '7f22y3e' and authcfg_id != '7f22y3g' and authcfg_id != 'a67e5fc' and authcfg_id != '7f22y3h': ## prozatím pro test toto id ma wagtail
            cfgjson = {
            "accessMethod": 0,
            "apiKey": "",
            "clientId": self.client_id,
            "clientSecret": self.client_secret,
            "configType": 1,
            "description": "",
            "grantFlow": 0,
            "id": "esa2024",
            "name": "auth",
            "objectName": "",
            "password": "",
            "persistToken": False,
            "queryPairs": {
            },
            "redirectPort": int(self.port),
            "redirectUrl": "client/oauthn2-liferay/callback",
            "refreshTokenUrl": "",
            "requestTimeout": 60,
            "requestUrl": self.liferayServer + "/o/oauth2/authorize",
            "scope": "",
            "tokenUrl": self.liferayServer + "/o/oauth2/token",
            "username": "",
            "version": 1
            }
        else:
            cfgjson = {
            "accessMethod": 0,
            "apiKey": "",
            "clientId": self.client_id,
            "clientSecret": self.client_secret,
            "configType": 1,
            "description": "",
            "grantFlow": 0,
            "id": "esa2024",
            "name": "auth",
            "objectName": "",
            "password": "",
            "persistToken": False,
            "queryPairs": {
            },
            "redirectPort": int(self.port),
            "redirectUrl": "client/oauthn2-liferay/callback",
            "refreshTokenUrl": "",
            "requestTimeout": 60,
            "requestUrl": self.liferayServer + "/o/authorize",
            "scope": "",
            "tokenUrl": self.liferayServer + "/o/token/",
            "username": "",
            "version": 1
            }

        if authcfg_id not in QgsApplication.authManager().availableAuthMethodConfigs():
            authConfig = QgsAuthMethodConfig('OAuth2')
            authConfig.setId(authcfg_id)
            authConfig.setName(authcfg_name)
            authConfig.setUri(self.liferayServer)
            authConfig.setConfig('oauth2config', json.dumps(cfgjson))
            if QgsApplication.authManager().storeAuthenticationConfig(authConfig):
                return authcfg_id
        else:
            authConfig = QgsAuthMethodConfig()
            QgsApplication.authManager().loadAuthenticationConfig(authcfg_id, authConfig, True)
            authConfig.setName(authcfg_name)
            authConfig.setUri(self.liferayServer)
            authConfig.setConfig('oauth2config', json.dumps(cfgjson))
            if QgsApplication.authManager().updateAuthenticationConfig(authConfig):
                return authcfg_id

        return None
    def checkForSpecialChars(self, s):
        special_characters = "!@#$%^&*()+?=,<>/"
        if any(c in special_characters for c in s):
            return True
        else:
            return False
    def checkForChars(self, string):
        if self.checkForSpecialChars(string):
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nepodporovaný znak.")
            else:
                QMessageBox.information(None, "Layman", "Unsupported char.")
        else:
            self.dlg.pushButton_CreateComposition.setEnabled(True)
            self.dlg.label_info.setText("")
    def checkNameCreateMap(self):
        text = self.dlg.lineEdit_2.text()
        if text != "":
            text = self.removeUnacceptableChars(text)

            ### map check
            url = self.URI + "/rest/"+self.laymanUsername+"/maps/"+str(text)+"/file"

            r = requests.get(url, headers = self.getAuthHeader(self.authCfg)) 

            res = r.json()            
            ch = True
            e = False
            try:
                if res['code'] == 2:
                    ch = False
                else:
                    ch = True
            except:
                ch = True
                e = True ## kdyz nevraci rescode tak je to v poradku

            #if not ch:
            if False:
                self.dlg.pushButton_CreateComposition.setEnabled(False)
                self.dlg.label_info.show()
                if self.locale == "cs":
                    self.dlg.label_info.setText("Nepřípustný znak v názvu!")
                else:
                    self.dlg.label_info.setText("Unacceptable char in title!")
            elif (not e):
                self.dlg.pushButton_CreateComposition.setEnabled(True)
                self.dlg.label_info.hide()

            else:
                self.dlg.pushButton_CreateComposition.setEnabled(False)
                self.dlg.label_info.show()
                if self.locale == "cs":
                    self.dlg.label_info.setText("Kompozice s tímto jménem již existuje!")
                else:
                    self.dlg.label_info.setText("Composition name already exists!")
           
            self.dlg.label_info.setStyleSheet("color: red;")
             
    def readLayerJson(self,layerName, service):
        self.dlg.progressBar_loader.show()         
        for i in range (0, len(self.dlg.treeWidget.selectedItems())):
            name = self.dlg.treeWidget.selectedItems()[i].text(0)
            workspace = self.dlg.treeWidget.selectedItems()[i].text(1)
            self.selectedWorkspace = workspace
            threading.Thread(target=lambda: self.readLayerJsonThread(name,service, workspace)).start()           
         
    def readLayerJsonThread(self, layerName,service, workspace):
        layerNameTitle =layerName
        layerName = self.layerNamesDict[layerName]
        if self.checkLayerOnLayman(layerName):            
            layerName = self.removeUnacceptableChars(layerName)        
            url = self.URI+'/rest/'+workspace+'/layers/'+layerName       
            r = self.requestWrapper("GET", url, payload = None, files = None)
            try:
                data = r.json()            
            except:
                self.showErr.emit(["Vrstva není k dispozici!", "Layer is not available!"], "code: " + str(r.status_code), str(r.content), Qgis.Warning, url)                         
                return      
            if (service == "WMS"):
                try:
                    wmsUrl = data['wms']['url']
                except:
                    self.showErr.emit(["Vrstva není k dispozici!", "Layer is not available!"], "code: " + str(r.status_code), str(r.content), Qgis.Warning, url)                
                    return
                format = 'png'
                epsg = 'EPSG:5514'
                everyone = False
                if 'EVERYONE' in data['access_rights']['read']:
                    everyone = True
                timeDimension = {}
                if 'time' in data['wms']:
                    timeDimension = data['wms']
                
                groupName=""
                subgroup=""
                visibility = ''              
                success = self.loadWms(wmsUrl, layerName,layerNameTitle, format, epsg, groupName,subgroup, timeDimension,visibility, everyone)
                if not success:
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Vrstva: "+layerName + " je poškozena a nebude načtena.")
                    else:
                        QMessageBox.information(None, "Layman", "Layer: "+layerName + " is corrupted and will not be loaded.")
            if (service == "WFS"):
                try:
                    wfsUrl = data['wfs']['url']
                except:
                    self.showErr.emit(["Vrstva není k dispozici!", "Layer is not available!"], "code: " + str(r.status_code), str(r.content), Qgis.Warning, url)                 
                    return
                print("loading WFS")
                success = self.loadWfs(wfsUrl, layerName, layerNameTitle)           
                if not success:
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Vrstva: "+layerName + " je poškozena a nebude načtena.")
                    else:
                        QMessageBox.information(None, "Layman", "Layer: "+layerName + " is corrupted and will not be loaded.")
            QgsMessageLog.logMessage("disableProgressBar")
        else:
            self.emitMessageBox.emit(["Vrstva "+layerName+ " nelze nahrát","Something went wrong with layer: " + layerName])      
            QgsMessageLog.logMessage("disableProgressBar")    
    
    def write_log_message(self,message, tag, level):   
        if message[0:15] == "notifyTwoGroups":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva " + message[15:100] +" je vnořena do dvou skupin. Uložena bude pouze nadřazená.")
            else:
                QMessageBox.information(None, "Layman", "Layer " + message[15:100] +" is nested in two groups. Only parent group will be saved.")
         
        if message == "updateMapDone":
            try:
                self.dlg.progressBar_loader.hide()
                self.dlg.pushButton_save.setEnabled(True)
            except:
                print("formular jiz byl uzavren")
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Změny v kompozici byly uloženy."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Changes in composition were saved."), Qgis.Success, duration=3)
            try:
                self.dlg.label_raster.hide()
            except:
                pass
        if message == "qfieldExport":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Export proběhl úspěšně."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Export was successfull"), Qgis.Success, duration=3)
            try:
                self.dlg2.progressBar.hide()
            except:
                print("progressbar doesnt exist")
        if message == "uniqLayers":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Jména vrstev jsou duplicitní.")
            else:
                QMessageBox.information(None, "Layman", "Layer names are duplicated.")

        if message == "errConnection":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Připojení k serveru selhalo!"), Qgis.Warning)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Connection with server failed!"), Qgis.Warning)
            try:
                self.dlg.progressBar_loader.hide()
            except:
                print("progressbar doesnt exist")       

        if message == "layersUploaded":         
            try:
                
                if (self.toUpload <= 1):
                    try:
                        self.dlg.progressBar_loader.hide()
                    except:
                        self.old_dlg.progressBar_loader.hide()
            except:
                print("different form")
        if message == "afterCompositionLoaded":
            self.afterCompositionLoaded()
        if message == "layersLoaded":          
            try:
                self.dlg.progressBar_loader.hide()                
            except:
                pass
        if message == "disableProgressBar":
            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
        if message == "authOptained":
            self.authOptained()
            self.getToken()
            try:
                self.dlg.progressBar.hide()
            except:
                pass
        if message == "showLoader":
            try:
                self.dlg.progressBar_loader.show()
            except:
                pass       

        if message =="requestError":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Chyba spojení se serverem!"), Qgis.Error, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Connection with server lost!"), Qgis.Error, duration=3)
        if message =="compositionSchemaError":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Schéma kompozice není ve validním formátu.")
            else:
                QMessageBox.information(None, "Layman", "Composition is not in valid format.")
            self.dlg.progressBar_loader.hide()
   
        # if message[:13] == "loadSymbology": ## slovník random
        #     num = message[13:]
        #     if (isinstance(self.currentLayerDict[num], QgsVectorLayer)):
        #         style = self.getStyle(self.currentLayerDict[num].name())                  
        #         layerName = self.currentLayerDict[num].name()
        #         if (style[0] == 200):
        #             if (style[1] == "sld"):
        #                 tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
        #                 self.currentLayerDict[num].loadSldStyle(tempf)
        #                 self.currentLayerDict[num].triggerRepaint()
        #             if (style[1] == "qml"):
        #                 tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
        #                 self.currentLayerDict[num].loadNamedStyle(tempf)
        #                 self.currentLayerDict[num].triggerRepaint()
        
        if message == "refreshComposite":
            try:
                self.refreshCompositeList()        ## pouze pro import Form
            except:
                pass
        if message == "loadMaps":
            try:
                self.dlg.progressBar_loader.hide()
                self.dlg.label_loading.hide()
            except:
                pass
        if message == "delLayComposite":
            try:
                self.dlg.progressBar.hide()
                self.dlg.label_import.hide()
                self.refreshLayerListReversed()
                self.dlg.pushButton_addMap.setEnabled(True)
                self.dlg.pushButton_deleteMap.setEnabled(True)
                self.dlg.pushButton_editMeta.setEnabled(True)
                self.dlg.pushButton_setMapPermissions.setEnabled(True)
                self.dlg.pushButton_addRaster.setEnabled(True)
                if (self.dlg.mMapLayerComboBox.count() > 0):
                    self.dlg.pushButton.setEnabled(True)
            except:
                pass
        if message == "unsupportedCRS":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Nepodporované CRS souboru"), Qgis.Warning)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Unsupported CRS of data file"), Qgis.Warning)


        if message == "resetProgressbar":
            try:
                self.dlg.progressBar.hide()
                self.dlg.progressBar.setValue(0)
            except:
                pass
        if message == "disableProgress":
            try:
                self.dlg.progressBar_loader.hide()
                self.dlg.label_raster.hide()
            except:
                pass
        if message == "enableProgress":
            try:
                self.dlg.progressBar_loader.show()
                self.dlg.label_raster.show()
            except:
                pass
        if message == "errorConnection":
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Spojení se serverem selhalo! Vrstva nebyla nahrána.")
            else:
                QMessageBox.information(None, "Error", "Connection with server failed! Layer was not exported.")
        if message == "export":
            #try:
            threadsB = set()
            for thread in threading.enumerate():
                threadsB.add(thread.name)
            try:
                if(self.ThreadsA == threadsB):
                    self.dlg.progressBar.hide()
                    self.dlg.label_import.hide()

            except:
                pass      

        if message == "limitSize":
            if self.locale == "cs":
                QMessageBox.information(None, "Upozornění", "Tato vrstva je větší než 2GB. Může být serverem odmítnuta.")
            else:
                QMessageBox.information(None, "Warning", "This layer is bigger than 2GB. It can be refused by server.")
        if message == "exportPatch":
            try:
                threadsB = set()
                for thread in threading.enumerate():
                    threadsB.add(thread.name)

                if(self.ThreadsA == threadsB):
                    self.dlg.progressBar.hide()
                    self.dlg.label_import.hide()


            except:
                pass
            try: ## některé formuláře nemají progress bar
                ## resime situaci kdy se dela patch v kompozici
                self.dlg.pushButton.setEnabled(True)
                self.dlg.pushButton_deleteMap.setEnabled(True)
                self.dlg.pushButton_editMeta.setEnabled(True)
                self.dlg.pushButton_setMapPermissions.setEnabled(True)
                self.dlg.pushButton_down.setEnabled(True)
                self.dlg.pushButton_up.setEnabled(True)
                self.dlg.pushButton_deleteLayers.setEnabled(True)
                self.dlg.pushButton_up.setEnabled(True)
                self.dlg.pushButton_addRaster.setEnabled(True)
                self.dlg.progressBar.hide()
                self.dlg.label_import.hide()


            except:
                pass
            
        
        if message == "delLay":
            try:
                self.dlg.label_thumbnail.setText(' ')
            except:
                pass
            try:
                if not (self.threadLayers.is_alive()):

                    self.dlg.progressBar_loader.hide()

            except:
                pass          

        
        if message[0:8] == "importl_":
            try:
                self.progressColor(message[8:100], False)
            except:
                pass
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+message[8:100]+" nebyla nahrána, protože je příliž velká."), Qgis.Warning)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+message[8:100]+" was not successfully exported because is too large"), Qgis.Warning)
            done = 0

            for i in range (0, len(self.processingList)):
                if self.processingList[i][2] == 1:
                    self.processingList[i][2] = 2
                   
                    done = done + 1
            try:
                if self.locale == "cs":
                    self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(self.uploaded) + " / " + str(self.batchLength) )
                else:
                    self.dlg.label_progress.setText("Sucessfully exported: " +  str(self.uploaded) + " / " + str(self.batchLength) )
            except:
                pass
            try:
                if self.uploaded == self.batchLength:
                    self.dlg.progressBar.hide()
            except:
                pass
       
     
        if message == "wrongName":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nepodporovaný znak v názvu.")
            else:
                QMessageBox.information(None, "Layman", "Unsupported char in name.")
        if message == "invalid":
            try:
                self.dlg.progressBar.hide()
            except:
                pass

            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva není validní!")
            else:
                QMessageBox.information(None, "Layman", "Layer is invalid!")
        if message == "wrongCrs":
            try:
                self.dlg.progressBar.hide()
            except:
                pass

            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nastavena naplatná projekce.")
            else:
                QMessageBox.information(None, "Layman", "Invalid projection.")
        if message[:9] == "wrongCrss":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nastaveno neplatné crs pro vrstvy:" + "\n" + message[9:])
            else:
                QMessageBox.information(None, "Layman", "Invalid projection for layers:" + "\n" +  message[9:])
        if message == "BmpNotSupported":
            try:
                self.dlg.progressBar.hide()
            except:
                pass

            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Formát rastru BMP není podporován.")
            else:
                QMessageBox.information(None, "Layman", "Raster format BMP is not supported.")
            try:
                self.dlg.progressBar.hide()
            except:
                pass 
        if message == "addRaster":
            try:
                self.dlg.progressBar.hide()
                self.dlg.label_import.hide()
                self.dlg.pushBuqgistton_down.setEnabled(True)
                self.dlg.pushButton_up.setEnabled(True)
                self.dlg.pushButton_deleteLayers.setEnabled(True)
                self.dlg.label_raster.hide()
            except:
                pass

            try:
                self.dlg.pushButton_addRaster.setEnabled(True)
                self.importMapEnvironmnet(True)

            except:
                pass # pro formulár kde neni progressbar

            try:
                self.dlg.label_thumbnail.setText(' ')
            except:
                pass  
    def _loadStyle(self, layer):
        if (isinstance(layer, QgsVectorLayer)):
            style = self.getStyle(layer.name())                  
            layerName = layer.name()
            if (style[0] == 200):
                if (style[1] == "sld"):
                    tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                    layer.loadSldStyle(tempf)
                    layer.triggerRepaint()
                if (style[1] == "qml"):
                    tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
                    layer.loadNamedStyle(tempf)
                    layer.triggerRepaint()                     
    def onRasterUpload(self, progress, max):   
        if self.dlg.objectName() == "ImportLayerDialog":
            self.dlg.progressBar.setMaximum(max)
            self.dlg.progressBar.setValue(progress)   
    def reorderGroups(self, groups, groupsSet, groupsPosition):
    
        for g in groups:                               
            self.reorderToTop(g[0], groupsSet, groupsPosition, g[1])    
      
        self.reorderGroup(groupsPosition, groupsSet)    
                         
    def loadAllComposites(self):
        url = self.URI+'/rest/' + self.laymanUsername + '/maps'        
       
        r = self.requestWrapper("GET", url, payload = None, files = None)     
        try:
            data = r.json()
        except:
            self.showErr.emit([" Připojení k serveru selhalo!", " Connection with server failed!"], "code: " + str(r.status_code), str(r.content), Qgis.Warning, url)            
            return
        for i in data:           
            url = self.URI+'/rest/' + self.laymanUsername + '/maps/'+i['name']+'/file'           
            r = self.requestWrapper("GET", url, payload = None, files = None)
            try:
                map = r.json()
            except:
                self.showErr.emit([" Připojení k serveru selhalo!", " Connection with server failed!"], "code: " + str(r.status_code), str(r.content), Qgis.Warning, url) 
            self.compositeList.append (map)
        
    def _onReprojectionFailed(self, layerName):        
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+layerName+" má nastavenou špatnou projekci!"), Qgis.Warning)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+layerName+" has wrong projection!"), Qgis.Warning)
        done = 0
        
        for i in range (0, len(self.processingList)):
            if self.processingList[i][2] == 1:        
                self.processingList[i][2] = 2                
                done = done + 1
        try:
            self.dlg.progressBar.hide()
        except:
            print("current dialog")
    def _onExportLayerSuccessful(self, layerName):
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+layerName+" byla úspěšně nahrána "), Qgis.Success, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+layerName+" was successfully exported"), Qgis.Success, duration=3)
        done = 0

        for i in range (0, len(self.processingList)):
            if self.processingList[i][2] == 1:
                self.processingList[i][2] = 2
               
                done = done + 1
        try:
            if self.locale == "cs":
                self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(self.uploaded) + " / " + str(self.batchLength) )
            else:
                self.dlg.label_progress.setText("Sucessfully exported: " +  str(self.uploaded) + " / " + str(self.batchLength) )
        except:
            pass
        try:
            if self.uploaded == self.batchLength:
                self.dlg.progressBar.hide()
        except:
            pass
    def _onReadCompositionFailed(self):
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Špatný formát kompozice."), Qgis.Warning, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Wrong format of composition"), Qgis.Warning, duration=3)     
        if self.dlg.objectName() == "AddMapDialog":
            self.dlg.progressBar_loader.hide()
    def _onExportLayerFailed(self, layerName):
        try:
            self.progressColor(layerName, False)
        except:
            pass
        try:
            self.dlg.pushButton_errLog.show()
        except:
            pass            
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+layerName+" nebyla nahrána "), Qgis.Warning)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+layerName+" was not exported successfully"), Qgis.Warning)
        done = 0

        for i in range (0, len(self.processingList)):
            if self.processingList[i][2] == 1:
                self.processingList[i][2] = 2                
                done = done + 1
    def loadAllCompositesT(self):
        self.compositeList = list()
        url = self.URI+'/rest/' + self.laymanUsername + '/maps'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        try:
            data = r.json()
        except:
            QgsMessageLog.logMessage("errConnection")
            QgsMessageLog.logMessage(url)
            self.disableEnvironment()
            return
        for i in data:
            url = self.URI+'/rest/' + i['workspace'] + '/maps/'+i['name']+'/file'            
            r = self.requestWrapper("GET", url, payload = None, files = None)
            try:
                map = r.json()
            except:
                QgsMessageLog.logMessage("errConnection")
                QgsMessageLog.logMessage(map)
                self.disableEnvironment()
                return
            self.compositeList.append(map)
           
    def readMapJson(self,name, service, workspace=""):        
        QgsProject.instance().setTitle(name)
        url = self.URI+'/rest/'+workspace+'/maps/'+name+'/file'       
        
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()
    
        projection = data['projection'].replace("epsg:","").replace("EPSG:","")
        if projection != "":
            crs=QgsCoordinateReferenceSystem(int(projection))


            if self.crsChangedConnect == False:
                QgsProject.instance().setCrs(crs)
                QgsProject.instance().crsChanged.connect(self.crsChanged)
                self.crsChangedConnect = True
            else:
                self.crsChangedConnect = False
                QgsProject.instance().setCrs(crs)
                self.crsChangedConnect = True
      
        self.dlg.pushButton_map.setEnabled(False) 
        self.loadComposition.emit(name, service, workspace)
      
    def readMapJson2(self,name, service, workspace=""):    
        self.unloadedLayers = list()
        self.processingRequest = True   
        self.current = name
        if workspace != "":### nactemdef loadData(self,name):

            self.selectedWorkspace = workspace
            
            url = self.URI+'/rest/'+workspace+'/maps/'+name+'/file'          
         
            r = self.requestWrapper("GET", url, payload = None, files = None)
            data = r.json()
            self.instance = CurrentComposition(self.URI, name, workspace, self.getAuthHeader(self.authCfg),self.laymanUsername)
            self.instance.setComposition(data)   
        else:
            print("workspace nepredan")       
        self.readMapJsonThread(name,service)
       

     
    def layerStyleToUpdate(self):
        layer = iface.activeLayer()
        self.stylesToUpdate.add(layer)
        print("symbology was changed")
    def readMapJsonThread(self,name, service):        
        name = self.removeUnacceptableChars(name) 
        print("debug in readMapJson - false")
        workspace = self.getCompositionWorkspace(name)
        self.selectedWorkspace = workspace           
        try:
            url = self.URI+'/rest/'+workspace+'/maps/'+name+'/file'
        except:
            QgsMessageLog.logMessage("compositionSchemaError")
            return
            #r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()
            ## rozvetveni zdali chce uzivatel otevrit kompozici v novem projektu
            #layers = iface.mapCanvas().layers() ## pokud neexistuej vrstva otazka nema smysl
        layers = QgsProject.instance().mapLayers()
        if len(layers) > 0:
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Chcete otevřít kompozici v prázdném projektu QGIS? Váš stávající projekt se zavře. Pokud zvolíte Ne, kompozice se sloučí se stávajícím mapovým obsahem.")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Do you want open a composition in an empty QGIS project? Your existing project will be closed. If you select No, the composition will be merged with the existing map content.")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):
                iface.newProject()
                projection = data['projection'].replace("epsg:","").replace("EPSG:","")
                crs=QgsCoordinateReferenceSystem(int(projection))
                self.crsChangedConnect = False
                QgsProject.instance().setCrs(crs)
                self.crsChangedConnect = True
                QgsProject.instance().setTitle(data['title'])

                self.loadService2(data,service, name)
            else:
                self.loadService2(data,service, name)
        else:
            self.loadService2(data,service, name)

    def afterCompositionLoaded(self):      
        
        permissions = self.instance.getPermissions()
        print("afterCompositionLoaded") 
        if permissions == "w" or permissions == "n" :            
            # startuje naslouchani na zmenu do groupy
            # prj = QgsProject().instance()
            # root = prj.layerTreeRoot()           
            # composition = self.instance.getComposition()            
            # self.project.removeAll.connect(self.removeSignals)        
            layers = self.project.mapLayers().values() 
            self.instance.setIds(layers)
            for layer in layers:                
                 layerType = layer.type()
                 if layerType == QgsMapLayer.VectorLayer:
                     layer.editingStopped.connect(self.layerEditStopped)
                     layer.styleChanged.connect(self.layerStyleToUpdate)    
        ## load opacity info
        composition = self.instance.getComposition() 
        map_layers = QgsProject.instance().mapLayers().values()
        print(map_layers)
        for layer in map_layers:
            for i in range (0, len(composition['layers'])):  
                if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(layer.name())):  
                    layer.setOpacity(composition['layers'][i]['opacity'])      
        QgsMessageLog.logMessage("layersLoaded")
    def changeVisibility(self, layerTreeNode):        
        if layerTreeNode.nodeType() == 0:
            print ("Group " + layerTreeNode.name())
            print(layerTreeNode.isVisible())
            sublayers = layerTreeNode.children()
            for lay in sublayers:
                print ("sub " + lay.name())
                self.modifyVisibilityOfLayer(lay.name(), lay.isVisible())
        else:
            if layerTreeNode.nodeType() == 1:
                print ("Layer " + layerTreeNode.name())
                self.modifyVisibilityOfLayer(layerTreeNode.name(), layerTreeNode.isVisible())
            else:
                print ("Error")
    def modifyPathOfLayer(self, name, path):
        composition = self.instance.getComposition()       
        for i in range (0, len(composition['layers'])):
           
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)):
                composition['layers'][i]['path'] = path

    def modifyVisibilityOfLayer(self, name, checked):
        composition = self.instance.getComposition()      
        for i in range (0, len(composition['layers'])):         
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)):             
                composition['layers'][i]['visibility'] = checked              
    def modifyScaleOfLayer(self, layer, checked):
        composition = self.instance.getComposition()    
        if checked:            
            for i in range (0, len(composition['layers'])):           
                if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(layer.name())):              
                    composition['layers'][i]['maxResolution'] = (self.scaleToResolution(layer.minimumScale()))
                    composition['layers'][i]['minResolution'] = (self.scaleToResolution(layer.maximumScale()))
                    
        else:
            for i in range (0, len(composition['layers'])):           
                if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(layer.name())):              
                    composition['layers'][i]['maxResolution'] = None
                    composition['layers'][i]['minResolution'] = 0 
    def modifyOpacity(self, layer):
        self.showExportInfo.emit("Aktualizace průhlednosti vrstev" if self.locale == "cs" else "Update layer opacity")
        layer = layer.layer()
        composition = self.instance.getComposition() 
        for i in range (0, len(composition['layers'])):  
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(layer.name())):            
                composition['layers'][i]['opacity'] = layer.opacity()                
    def removeSignals(self):
        print("removing signals")
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            try:
                layer.editingStopped.disconnect()
            except:
                print("TypeError: disconnect() failed between 'editingStopped' and all its connections")

    def layerAdded(self, layer):
        self.run_CurrentCompositionDialog()

    def layerEditStopped(self):
        layer = iface.activeLayer()
        try:
            self.postRequest(layer.name(), True)
        except:
            pass

    def deleteMapFromServer(self,name):

        url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name
        response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))        
       
        if (response.status_code == 200):
            if self.locale == "cs":          
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " byla úspešně smazána."), Qgis.Success, duration=3)
            else:          
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was sucessfully deleted."), Qgis.Success, duration=3)
        else:
            self.showErr.emit([" Kompozice  " + name + " nebyla smazána.", " Composition  " + name + " was not sucessfully deleted."], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)     
 
        self.refreshListWidgetMaps() ## pro treewidget

    def deleteCurrentMap(self):
        composition = self.instance.getComposition()
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Chcete opravdu smazat tuto kompozici?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Do you want really delete this composition?")
        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+composition['name']           
            response = self.requestWrapper("DELETE", url, payload = None, files = None)
            if (response.status_code == 200):
                if self.locale == "cs":     
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + composition['name'] + " byla úspešně smazána."), Qgis.Success, duration=3)
                else:         
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + composition['name'] + " was sucessfully deleted."), Qgis.Success, duration=3)
            else:
                self.showErr.emit([" Kompozice  " + composition['name'] + " nebyla smazána.", " Composition  " + composition['name'] + " was not sucessfully deleted."], "code: " + str(response.status_code), str(response.content), Qgis.Warning)               

            self.instance = None
            self.current = None
            self.dlg.close()
    def deleteMap(self,name, x):
   
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Chcete opravdu smazat kompozici "+name+"?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Do you want really delete composition "+name+"?")

        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            name = self.removeUnacceptableChars(name)
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name
            response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))           
            if (response.status_code == 200):
                if self.locale == "cs":             
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " byla úspešně smazána."), Qgis.Success, duration=3)
                else:             
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was sucessfully deleted."), Qgis.Success, duration=3)
            else:
                if self.locale == "cs":             
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " nebyla smazána."), Qgis.Warning)
                else:              
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was not sucessfully deleted."), Qgis.Warning)

            try:
                del (self.compositeList[x])
                self.refreshCompositeList()## pro import map form
                self.dlg.treeWidget_listLayers.clear()
                self.dlg.treeWidget_listLayers.addTopLevelItem(item)
                self.dlg.pushButton_deleteMap.setEnabled(False)
                self.dlg.pushButton_editMeta.setEnabled(False)
                self.dlg.pushButton_setMapPermissions.setEnabled(False)
                self.dlg.pushButton.setEnabled(False)
                self.dlg.pushButton_addRaster.setEnabled(False)

            except:
                pass
           
            try:
                checked = self.getConfigItem("mapcheckbox")
                print(checked)
            except:
                checked = False
            if checked == "0":
                checked = False
            if checked == "1":
                checked = True
            print(checked)
            self.loadMapsThread(checked)
            
    def deleteMapX(self,name, x):
   
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Chcete opravdu smazat kompozici "+name+"?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Do you want really delete composition "+name+"?")

        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        
        def deleteMapThread(name):
            name = self.removeUnacceptableChars(name)
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name
            response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))           
            #response = self.requestWrapper("DELETE", url, payload = None, files = None)
            if (response.status_code == 200):                
                self.successWrapper.emit([" Kompozice  " + name + " byla úspešně smazána."," Composition  " + name + " was sucessfully deleted."])               
            else:
                self.showErr.emit([" Kompozice  " + name + " nebyla smazána.", " Composition  " + name + " was not sucessfully deleted."], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)          

            try:            
                self.refreshCompositeList()## pro import map form
                self.dlg.treeWidget_listLayers.clear()                
                self.dlg.pushButton_deleteMap.setEnabled(False)
                self.dlg.pushButton_editMeta.setEnabled(False)
                self.dlg.pushButton_setMapPermissions.setEnabled(False)
                self.dlg.pushButton.setEnabled(False)
                self.dlg.pushButton_addRaster.setEnabled(False)

            except:
                pass
        
            try:
                checked = self.getConfigItem("mapcheckbox")
                print(checked)
            except:
                checked = False
            if checked == "0":
                checked = False
            if checked == "1":
                checked = True
            print(checked)
            self.loadMapsThread(checked)
        if (reply == QMessageBox.Yes):
            deleteMapThread(name)           
    def deleteLayerFromCanvas(self, name):
        lay = QgsProject.instance().mapLayersByName(name)[0]
        if (lay != None and lay.type() != QgsMapLayer.VectorLayer):
            QgsProject.instance().removeMapLayer(lay.id())


    def getSelectedLayers(self):
        arr = self.dlg.listWidget_listLayers2.selectedItems()
        layers = []
        for a in arr:
            layer = QgsProject.instance().mapLayersByName(a.text())
            for lay in layer:

                if (lay.type() == QgsMapLayer.VectorLayer):
                    layers.append(lay)

        return layers

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING Atlas"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)      
        self.pluginIsActive = False
    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        authm = QgsApplication.authManager()
        authm.clearCachedConfig(self.authCfg)
        #print "** UNLOAD Atlas"
      ## killing daemons       
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Layman'),
                action)
            self.iface.removeToolBarIcon(action)
        del self.toolbar

    #--------------------------------------------------------------------------
    def bounds(self, layers):

        extent = None
        for layer in layers:
            if layer.type() == 0:
                transform = QgsCoordinateTransform(layer.crs(), QgsCoordinateReferenceSystem('EPSG:4326'), QgsProject.instance()) # WGS 84 / UTM zone 33N
                try:
                    layerExtent = transform.transform(layer.extent())
                except QgsCsException:
                    print("exception in transform layer srs")
                    layerExtent = QgsRectangle(-180, -90, 180, 90)
                if extent is None:
                    extent = layerExtent
                else:
                    extent.combineExtentWith(layerExtent)

        return (extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum())
    def copySymbols(self,symbol, tempPath, fileNames):
        for i in range(symbol.symbolLayerCount()):
            sl = symbol.symbolLayer(i)
            if isinstance(sl, QgsSvgMarkerSymbolLayer):
                symbolPath = sl.path();
                shutil.copy(symbolPath, tempPath)
                print("Copying " + str(sl.path()))
                fileNames.append(tempPath + os.sep + os.path.basename(symbolPath))
            else:
                print("Ignoring " + str(sl))

    def setDefaultExtent (self, ext):
        self.dlg.lineEdit_3.setText(str(ext.xMinimum()))
        self.dlg.lineEdit_4.setText(str(ext.xMaximum()))
        self.dlg.lineEdit_5.setText(str(ext.yMinimum()))
        self.dlg.lineEdit_6.setText(str(ext.yMaximum()))

    def setWritePermissionList(self):
        allItems = [self.dlg.comboBox_users.itemText(i) for i in range(self.dlg.comboBox_users.count())]    
        if self.dlg.comboBox_users.currentText() in allItems:
            if self.checkAddedItemDuplicity("write"):
                itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
              
                if (self.dlg.comboBox_users.currentText() in itemsTextListRead):
                  
                    self.dlg.listWidget_write.addItem(self.dlg.comboBox_users.currentText())
                    print("1")
                else:            
                    self.dlg.listWidget_write.addItem(self.dlg.comboBox_users.currentText())
                    self.dlg.listWidget_read.addItem(self.dlg.comboBox_users.currentText())
                    print("2")
    def removeWritePermissionList(self):
        self.deleteItem(self.dlg.listWidget_read.currentItem().text())
        self.dlg.listWidget_read.removeItemWidget(self.dlg.listWidget_read.takeItem(self.dlg.listWidget_read.currentRow()))
       

    def deleteItem(self, itemName):

        items_list = self.dlg.listWidget_write.findItems(itemName,QtCore.Qt.MatchExactly)

        for item in items_list:
            r = self.dlg.listWidget_write.row(item)
            self.dlg.listWidget_write.takeItem(r)
    def loadJsonLayer(self, fileName):
        name = (os.path.splitext(os.path.basename(fileName))[0])
        vlayer = QgsVectorLayer(fileName, name,"ogr")
        sldPath = os.path.splitext(fileName[:-4])[0] + ".sld"
        qmlPath = os.path.splitext(fileName[:-4])[0] + ".qml"

        sldExists = os.path.isfile(sldPath)
        qmlExists = os.path.isfile(qmlPath)
        if (qmlExists):
            print("qml loaded")
            vlayer.loadNamedStyle(qmlPath)
        elif (sldExists):
            vlayer.loadSldStyle(os.path.splitext(fileName)[0]+ ".sld")
            print("sld loaded")
        QgsProject.instance().addMapLayer(vlayer)
        vlayer.triggerRepaint()
    def checkLoadedLayer(self):
        layers = iface.layerTreeView().selectedLayers()
        if (len(layers) > 0):
            self.json_export()
        else:
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není načtena vrstva!")
            else:
                QMessageBox.information(None, "Message", "You must load layer first!")
    def tranformExtent(self, ext):
        src = QgsProject.instance().crs()
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        transfomedExtent = tform.transform(ext)
        return transfomedExtent


    def getEmptyComposite(self, compositeName, compositeTitle):      
        compositeEPSG = QgsProject.instance().crs().authid().lower()
        ## nativeExtent is project extent
        ext = iface.mapCanvas().extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        ## convert to extent
        if QgsProject.instance().crs().authid() != "4326":
            src = QgsProject.instance().crs()
            dest = QgsCoordinateReferenceSystem(4326)
            tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
            max = tform.transform(QgsPointXY(float(xmax),float(ymax)))
            min = tform.transform(QgsPointXY(float(xmin),float(ymin)))
            exmin = min.x()
            exmax = max.x()
            eymin = min.y()
            eymax = max.y()
        else:
            exmin = xmin
            exmax = xmax
            eymin = ymin
            eymax = ymax       
        
        center = QgsPointXY(iface.mapCanvas().extent().center().x(), iface.mapCanvas().extent().center().y())
        abstract = self.dlg.lineEdit_7.text()
        self.schemaURl= "https://raw.githubusercontent.com/hslayers/map-compositions/2.0.0/schema.json"
        self.schemaVersion = "2.0.0"
        
        if LooseVersion(self.laymanVersion) > LooseVersion("1.16.0"):
            comp = {"abstract":abstract,"center":[center.x(),center.y()],"current_base_layer":{"title":"Composite_base_layer"},"describedBy": self.schemaURl,"schema_version": self.schemaVersion,"nativeExtent": [xmin,ymin,xmax,ymax],"extent":[exmin,eymin,exmax,eymax],"groups":{"guest":"w"},"layers":[],"name":compositeName,"projection":compositeEPSG,"scale":1,"title":compositeTitle,"units":"m","user":{"email":"","name":self.laymanUsername}}
        else:
            comp = {"abstract":abstract,"center":[center.x(),center.y()],"current_base_layer":{"title":"Composite_base_layer"},"extent":[str(exmin),str(eymin),str(exmax),str(eymax)],"groups":{"guest":"w"},"layers":[],"name":compositeName,"projection":compositeEPSG,"scale":1,"title":compositeTitle,"units":"m","user":{"email":"","name":self.laymanUsername}}        

       
        return comp
    def loadLocalFile(self):
        options = QFileDialog.Options()
        dialog = QFileDialog()
        dialog.setStyleSheet("QPushButton {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} QPushButton:hover{background: #66ab27 ;}QPushButton:disabled{background: #64818b ;}");
        try:
            if self.locale == "cs":
                fileName = dialog.getOpenFileName(None,"Načíst soubor", "","GeoJson Files (*.geojson);;Json Files (*.json)", options=options)
            else:
                fileName = dialog.getOpenFileName(None,"Load file", "","GeoJson Files (*.geojson);;Json Files (*.json)", options=options)

            print ("načítám json ze souboru:" + fileName[0])
            if (fileName[0] != ""):
                self.loadJsonLayer(fileName[0])
        except:
            pass
    
    def modifyMapNew(self):
        composition = self.instance.getComposition()       
        self.compositionDict[composition['name']] = self.dlg.lineEdit_title.text()    
        composition['abstract'] = self.dlg.lineEdit_abstract.text()
        composition['title'] = self.dlg.lineEdit_title.text()
        src = QgsProject.instance().crs()
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        #transformace extentu
        composition['extent'][0] = float(self.dlg.lineEdit_xmin.text().replace(",","."))
        composition['extent'][2] = float(self.dlg.lineEdit_xmax.text().replace(",","."))
        composition['extent'][1] = float(self.dlg.lineEdit_ymin.text().replace(",","."))
        composition['extent'][3] = float(self.dlg.lineEdit_ymax.text().replace(",","."))
        center = tform.transform(QgsPointXY(iface.mapCanvas().extent().center().x(), iface.mapCanvas().extent().center().y()))
        composition['center'][0] = float(center.x())
        composition['center'][1] = float(center.y())
        response = self.patchMap2()
        if (response.status_code == 200):
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Metadata byla úspěšně upravena."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Map metadata was saved successfully."), Qgis.Success, duration=3)
        else:
            self.showErr.emit([" Metadata nebyla upravena.", " Map metadata was not saved."], "code: " + str(response.status_code), str(response.content), Qgis.Warning, "")            

        self.dlg.close()
        composition = self.instance.getComposition()
        try:
            if self.locale == "cs":
                self.dlg.setWindowTitle("Kompozice: "+composition['title'])
            else:
                self.dlg.setWindowTitle("Composition: "+composition['title'])
        except:
            pass
    def saveLocalFile(self):

        layer = self.iface.activeLayer()
        print(layer.commitChanges()) ## změny uloženy
        path = iface.activeLayer().dataProvider().dataSourceUri()
        path = path.split("|")[0].replace("'","")
        if (layer == None):
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není načtena vrstva!")
            else:
                QMessageBox.information(None, "Message", "You must load layer first!")
        else:           
            defaultDir = os.path.dirname(path)            
            dialog = QFileDialog()
            dialog.setFileMode(1)
            dialog.setDirectory(defaultDir)       
         
            if self.locale == "cs":
                layer_name = dialog.getSaveFileName(None, "Uložit soubor", defaultDir +os.sep+ str(layer.name()) + ".geojson", "*.geojson")
            else:
                layer_name = dialog.getSaveFileName(None, "Save file", defaultDir +os.sep+ str(layer.name()) + ".geojson", "*.geojson")

            self.json_export_local(layer_name[0], layer)

    def json_export_local(self, layer_name, lay):
        import shutil
        filePath = self.getTempPath(layer_name)
        ogr_driver_name = "GeoJSON"
        project = QgsProject.instance()
        fileNames = []
        ## zde musí být zajištěna vektorová vrstva
        layer = lay
        layerType = layer.type()
        if layerType == QgsMapLayer.VectorLayer:

            renderer = layer.renderer()
            hasIcon = False
            if isinstance(renderer, QgsSingleSymbolRenderer):

                self.copySymbols(renderer.symbol(), tempfile.gettempdir(), fileNames)
                hasIcon = True


            layerCrs = qgis.utils.iface.activeLayer().crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)
            result2 = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, layer_name, "utf-8", crs, ogr_driver_name) # export jsonu do souboru

            if(result2[0] == 2): ## testujeme zda není soubor otevřený v jiném procesu / návratový kod 2

                tempFile = self.getTempPath(os.path.basename(layer_name.replace(".geojson", "") ))
                print(tempFile)              
                sld_temp_filename = tempFile.replace("geojson", "sld")
                qml_temp_filename = tempFile.replace("geojson", "qml")
                layer.saveSldStyle(sld_temp_filename)
                layer.saveNamedStyle(qml_temp_filename)
                result2 = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, tempFile, "utf-8", crs, ogr_driver_name)
                print(result2)
                if(result2[0] == 2):
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Soubor není možné přepsat. Je již otevřený jiným procesem.")
                    else:
                        QMessageBox.information(None, "Layman", "It is not possible overwrite this file. File is already open in other process.")
                    return
                if os.path.basename(layer_name.replace(".geojson", "")) != '':
                    QgsProject.instance().removeMapLayer(layer.id())
                    print(tempFile, layer_name)
                    shutil.copy(tempFile, layer_name)
                    shutil.copy(sld_temp_filename, layer_name.replace(".geojson", ".sld"))
                    shutil.copy(qml_temp_filename, layer_name.replace(".geojson", ".qml"))
                    self.loadJsonLayer(layer_name)

            else:
                sld_filename = layer_name.replace("geojson", "sld")
                qml_filename = layer_name.replace("geojson", "qml")
                result3 = False
                layer.saveSldStyle(sld_filename)
                layer.saveNamedStyle(qml_filename)

    def json_export(self, layer_name, id=None):

        filePath = self.getTempPath(self.removeUnacceptableChars(layer_name).lower())
        ogr_driver_name = "GeoJSON"
        project = QgsProject.instance()
        fileNames = []
        if id != None:
            layers = QgsProject.instance().mapLayersByName(layer_name)            
            for lay in layers:
                if lay.id() == id:
                    layer = lay
                    
        else:
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]

        layerType = layer.type()
        if layerType == QgsMapLayer.VectorLayer:

            renderer = layer.renderer()
            hasIcon = False
            if isinstance(renderer, QgsSingleSymbolRenderer):
                self.copySymbols(renderer.symbol(), tempfile.gettempdir(), fileNames)
                hasIcon = True         
            layerCrs = layer.crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)# původně bylo
            layer_filename = filePath          
            if os.path.exists(layer_filename):
                try:
                    os.remove(layer_filename)        
                except PermissionError as e:         
                    print(f"PermissionError exception: {e}")          
            epsg = layer.crs().authid()
            if not epsg in self.supportedEpsg:
                epsg = QgsProject.instance().crs().authid()
            parameter = {'INPUT': layer, 'TARGET_CRS': epsg, 'OUTPUT': layer_filename}
            try:
                processing.run('qgis:reprojectlayer', parameter)
            except:
                print("wrong reprojection")
                return False   
            sld_filename = filePath.replace("geojson", "sld").lower()
            qml_filename = filePath.replace("geojson", "qml").lower()
            if os.path.exists(sld_filename):
                os.remove(sld_filename)        
            if os.path.exists(qml_filename):
                os.remove(qml_filename)       
            result3 = False
            layer.saveSldStyle(sld_filename)
            self.insertPictureToQML(layer)
            layer.saveNamedStyle(qml_filename)
            self.insertBinaryToQml(layer, qml_filename)           
            return True
    def json_exportMix(self, layer):

        filePath = self.getTempPath(self.removeUnacceptableChars(layer.name() + str(layer.geometryType())).lower())
        ogr_driver_name = "GeoJSON"
        project = QgsProject.instance()
        fileNames = []

        layerType = layer.type()
        if layerType == QgsMapLayer.VectorLayer:

            renderer = layer.renderer()
            hasIcon = False
            if isinstance(renderer, QgsSingleSymbolRenderer):

                self.copySymbols(renderer.symbol(), tempfile.gettempdir(), fileNames)
                hasIcon = True


           
            layerCrs = layer.crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)# původně bylo
            layer_filename = filePath
            ## transform test
            parameter = {'INPUT': layer, 'TARGET_CRS': 'EPSG:4326', 'OUTPUT': layer_filename}
            processing.run('qgis:reprojectlayer', parameter)
            ## transforma test
         

            sld_filename = filePath.replace("geojson", "sld").lower()
            result3 = False
            layer.saveSldStyle(sld_filename)
        return layer_filename
    def _cleanTemp(self, basename):     
        temp_dir = tempfile.gettempdir()     
        files = [f for f in os.listdir(temp_dir) if f.startswith(basename)]       
        print(files) 
        for file in files:
            try:
                print(temp_dir + os.sep + file)
                os.remove(temp_dir + os.sep + file)
            except OSError as e:
                pass       
    def checkValidAttributes(self, layer_name):
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if len(layers) > 1:
            for l in layers:
                if (isinstance(l, QgsVectorLayer)):

                    layers.clear()
                    layers.append(l)
                    break
        isValid = True
        if (isinstance(layers[0], QgsVectorLayer)):
            pom =layers[0].getFeature(1)
        else:
            return True
        for nam in pom.fields().names():
            if (nam == ''):
                isValid = False
        return isValid


    def checkWgsExtent(self, layer):
        WgsXmax = 180
        WgsXmin = -180
        WgsYmax = 90
        WgsYmin = -90
        extent = layer.extent()
        if (extent.xMaximum() > WgsXmax or extent.xMinimum() < WgsXmin or extent.yMaximum() > WgsYmax or extent.yMinimum() < WgsYmin ):
            return False
        else:
            return True

    def insertBinaryToQml(self,layer, stylePath):
        single_symbol_renderer = layer.renderer()       
        layer.saveNamedStyle(stylePath)
        if isinstance(single_symbol_renderer, QgsCategorizedSymbolRenderer):           
            symbol  = layer.renderer().categories()
            for i in symbol:               
                if isinstance(i.symbol().symbolLayer(0), QgsMarkerLineSymbolLayer):    
                    if isinstance(i.symbol().symbolLayer(0).subSymbol().symbolLayer(0), QgsSvgMarkerSymbolLayer):
                        path = (i.symbol().symbolLayer(0).subSymbol().symbolLayer(0).path())
                        if path[:4] != "base":
                            if os.path.exists(path):
                                with open(path, "rb") as image_file:
                                    encoded_string = base64.b64encode(image_file.read())                             
                                path2 = i.symbol().symbolLayer(0).subSymbol().symbolLayer(0).path()
                                pathRelative = path2.split("svg/")[1] if len(path2.split("svg/"))>1 else ""
                                decoded =   encoded_string.decode("utf-8")
                                path3 = ("base64:"  + decoded) 
                                with open(stylePath, 'r') as file :
                                        filedata = file.read()  
                                if pathRelative != "":
                                    filedata = filedata.replace(pathRelative, path3)
                                else:
                                    filedata = filedata.replace(path2, path3)    
                                with open(stylePath, 'w') as file:
                                    file.write(filedata)
                    
                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()
                    print(type(i.symbol().symbolLayer(0).subSymbol() ))
                    if path[:4] != "base":
                        if os.path.exists(path):
                            with open(path, "rb") as image_file:
                                encoded_string = base64.b64encode(image_file.read())                             
                            path2 = i.symbol().symbolLayer(0).path()
                            pathRelative = path2.split("svg/")[1] if len(path2.split("svg/"))>1 else ""
                            decoded =   encoded_string.decode("utf-8")
                            path3 = ("base64:"  + decoded) 

                            print(path3)
                            with open(stylePath, 'r') as file :
                                filedata = file.read() 
                            if pathRelative != "":
                                filedata = filedata.replace(pathRelative, path3)
                            else:
                                filedata = filedata.replace(path2, path3)     
                            with open(stylePath, 'w') as file:
                                file.write(filedata)                            
                j = 0                                   

        elif isinstance(single_symbol_renderer, QgsRuleBasedRenderer):           
            symbol  = layer.renderer().rootRule().children()
            for i in symbol:              

                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()

                    if os.path.exists(path):
                        with open(path, "rb") as image_file:
                            encoded_string = base64.b64encode(image_file.read())                           
                        path2 = i.symbol().symbolLayer(0).path()
                        decoded =   encoded_string.decode("utf-8")                      
                        path3 = ("base64:"  + decoded)
                        with open(stylePath, 'r') as file :
                            filedata = file.read()

                        filedata = filedata.replace(path2, path3)

                        with open(stylePath, 'w') as file:
                            file.write(filedata)
    def insertPictureToQML(self, layer):
        single_symbol_renderer = layer.renderer()

        if isinstance(single_symbol_renderer, QgsCategorizedSymbolRenderer):
            symbol  = layer.renderer().categories()
            for i in symbol:
                

                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()
                    try:
                        if os.path.exists(path):
                            with open(path, "rb") as image_file:
                                encoded_string = base64.b64encode(image_file.read())                              
                            decoded =   encoded_string.decode("utf-8")
                        
                            i.symbol().symbolLayer(0).setPath("base64:"  + decoded)
                           
                    except:
                        print("binary path")
        elif isinstance(single_symbol_renderer, QgsRuleBasedRenderer):            
            symbol  = layer.renderer().rootRule().children()
            for i in symbol:                

                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()

                    if os.path.exists(path):
                        with open(path, "rb") as image_file:
                            encoded_string = base64.b64encode(image_file.read())
                    
                        decoded =   encoded_string.decode("utf-8")                    
                        i.symbol().symbolLayer(0).setPath("base64:"  + decoded)
                        
        elif isinstance(single_symbol_renderer, QgsSingleSymbolRenderer):
            try:
                symbols = single_symbol_renderer.symbol()

            except:
                print("nevhodny typ" + str(type(single_symbol_renderer)))
                return
            for symbol in symbols:
                if isinstance(symbol, QgsSvgMarkerSymbolLayer) or isinstance(symbol, QgsRasterMarkerSymbolLayer):
                    path = symbol.path()
                    try:
                        if os.path.exists(path):
                            with open(path, "rb") as image_file:
                                encoded_string = base64.b64encode(image_file.read())
                              
                            decoded =   encoded_string.decode("utf-8")                            
                            symbol.setPath("base64:"  + decoded)
                            
                    except:
                        print("binary path")

    def mergeGeojsons(self, paths, output, layerName):
        feats = list()
      
        top = '''
        {
        "type": "FeatureCollection",
        "name": "'''+layerName+'''",
        "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG:3857" } },
        "features": ['''
        bottom = """]
        }
        """
        for path in paths:
            with open(path) as json_file:
                data = json.load(json_file)
                for p in data['features']:

                    feats.append(p)

        

        text_file = open(output, "w")
        text_file.write((top + str(feats)[1:-1] + bottom).replace("'", "\""))
        text_file.close()
    def checkIfAllLayerAreRaster(self, layers): 
        if len(layers) == 1:
            return False
        for item in layers:
            layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
            if layer.type() == QgsMapLayer.RasterLayer:
                raster_layer = layer
                if raster_layer.providerType() != "wms":
                    path = raster_layer.source()
                    print("File raster layer:", path)
            else:
                return False  
        return True    
    def callPostRequest(self, layers):        
        resamplingMethod = self.dlg.comboBox_resampling.currentText()
        if resamplingMethod == "No value":
            resamplingMethod = "Není vybrán"
        def showPostgreDialog(layer):
            self.dlgPostgres = PostgrePasswordDialog()   
            self.dlgPostgres.show()
            self.dlgPostgres.pushButton_pass.clicked.connect(lambda: self.postPostreLayer(layer, self.dlgPostgres.lineEdit_username.text(), self.dlgPostgres.lineEdit_pass.text()))
            self.dlgPostgres.pushButton_pass.setStyleSheet("#pushButton_pass {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_pass:hover{background: #66ab27 ;}#pushButton_pass:disabled{background: #64818b ;}")
        self.dlg.pushButton_errLog.hide()
        self.ThreadsA = set()
        for thread in threading.enumerate():
            self.ThreadsA.add(thread.name)
        self.uploaded = 0
        self.batchLength = len(layers)        
        if self.checkIfAllLayerAreRaster(layers):
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Je vybráno více rastrových vrstev. Chcete je exportovat jako časové? Symbologie bude přebrána z prvního rastru.")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Multiple raster layers are selected. Do you want to export them as time series? The symbology will be taken from the first raster.")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):
                self.showTSDialog()
                return
        self.dlg.label_progress.show()        
        if self.locale == "cs":
            self.dlg.label_progress.setText("Úspěšně exportováno: 0 / " + str(len(layers)) )
        else:
            self.dlg.label_progress.setText("Sucessfully exported 0 / " + str(len(layers)) )        
        self.layersToUpload = len(layers)
        bulk = False
        if self.layersToUpload > 1:
            for item in layers:
                if (self.checkExistingLayer(item.text(0))):
                    if self.locale == "cs":
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Je vybráno více vrstev a některé z nich již na serveru existují. Chcete je hromadně přepsat?")
                    else:
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Multiple layers are selected and some of them already exist on the server. Do you want to overwrite them?")
                    msgbox.addButton(QMessageBox.Yes)
                    msgbox.addButton(QMessageBox.No)
                    msgbox.setDefaultButton(QMessageBox.No)
                    reply = msgbox.exec()
                    if (reply == QMessageBox.Yes):  
                        bulk = True     
                        break  
                    else:
                        return              
        for item in layers:
            layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
            if self.isLayerPostgres(layer):
                showPostgreDialog(layer)                
            else:                
                if not bulk:   
                    self.postRequest(item.text(0), False, True, False, resamplingMethod)
                else:
                    self.postRequest(item.text(0), False, True, True, resamplingMethod)
    def setCurrentLayer(name):
        layers = QgsProject.instance().mapLayersByName(name)
        if(len(layers) >1):
            layerss = QgsProject.instance().mapLayers().values()
            i = 0
            for layer in layerss:
                if layers[0].name == layer.name():
                    if (i == item.currentIndex()):
                        i = i + 1
                        break
                    i = i + 1
        return i
    def transformLayer(self, layer):
        layer = iface.activeLayer()
        crsSrc = layer.crs()        
        crsDest = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)        
        xform = QgsCoordinateTransform(crsSrc, crsDest, 5514, 4326)
        feats=[]

        if (layer.geometryType() == 0):
            destLayer = QgsVectorLayer("Point?crs=EPSG:4326","lay","memory")
        if (layer.geometryType() == 1):
            destLayer = QgsVectorLayer("Linestring?crs=EPSG:4326","lay","memory")
        if (layer.geometryType() == 2):
            destLayer = QgsVectorLayer("Polygon?crs=EPSG:4326","lay","memory")

        for f in layer.getFeatures():
            g = f.geometry()

            g.transform(xform)           
            f.setGeometry(g)
            feats.append(f)

        destLayer.dataProvider().addFeatures(feats)
        return destLayer
    def setChunkSizeBigger(self):
        self.CHUNK_SIZE = 2098152
    def checkFileSizeLimit(self, size):
        if size > 2000000000:
            QgsMessageLog.logMessage("limitSize")
    def patchThread2(self, layer_name, data, id):    
        if not (self.json_export(layer_name, id)):
            self.reprojectionFailed.emit(layer_name)
            return

        #try:
        geoPath = self.getTempPath(self.removeUnacceptableChars(layer_name))

        if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
            if os.path.getsize(geoPath) > 800000000:
                self.checkFileSizeLimit(os.path.getsize(geoPath))
                self.setChunkSizeBigger()
            self.postInChunks(layer_name, "patch")
        else:
            self.patchLayer(layer_name, data)
    def patchThread(self, layer_name, data,q, progress): 
        if layer_name in self.mixedLayers:
            layers = QgsProject.instance().mapLayersByName(layer_name)
            paths = list()
            for layer in layers:
                print(paths.append(self.json_exportMix(layer)))
            self.mergeGeojsons(paths, self.getTempPath(self.removeUnacceptableChars(layer.name())),self.removeUnacceptableChars(layer.name()))

        else:
            if not (self.json_export(layer_name)):
                self.reprojectionFailed.emit(layer_name)
                return
            

        geoPath = self.getTempPath(self.removeUnacceptableChars(layer_name))
  
        if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
            if os.path.getsize(geoPath) > 800000000:
                self.checkFileSizeLimit(os.path.getsize(geoPath))
                self.setChunkSizeBigger()
            self.postInChunks(layer_name, "patch")
        else:
            response = self.patchLayer(layer_name, data)   
        if progress:

            self.importedLayer = layer_name
            self.processingList[q][2] = 1
            if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
                try:
                    url = self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)
                    response = requests.get(url , headers = self.getAuthHeader(self.authCfg))
                    #response = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name), payload = None, files = None)
                    if (response.status_code == 400):
                        time.sleep(3)                    
                        response = requests.get(url , headers = self.getAuthHeader(self.authCfg))
                except:
                    self.showErr.emit(["Připojení se serverem selhalo!", "Connection with server failed!"], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)                
                    return

            if (response.status_code == 200):
                try:
                    self.uploaded = self.uploaded + 1
                except:
                    pass
                #QgsMessageLog.logMessage("imports_"+layer_name)
                self.exportLayerSuccessful.emit(layer_name)

            else:
                #QgsMessageLog.logMessage("importn_"+layer_name)
                self.exportLayerFailed.emit(layer_name)
                self.writePostLog(str(layer_name), str(response.status_code), str(response.content))       
            QgsMessageLog.logMessage("exportPatch")
            try:
                self.toUpload - 1
                QgsMessageLog.logMessage("layersUploaded")
            except:
                pass
        self.cleanTemp.emit(self.removeUnacceptableChars(layer_name))    
    def returnPathIfFileExists(self, path, ext, onlyExt = False):        
        pathWithoutExt = path.replace(ext,"")
        ext = ext.lower()
        if ext == ".tif" or ".tiff":
            if os.path.exists(pathWithoutExt + ".tfw") or os.path.exists(pathWithoutExt + ".TFW"):
                print("external file detected")
                if not onlyExt:
                    return pathWithoutExt + ".tfw"
                else:
                    return ".tfw"
            else:
                return None
        if ext == ".jp2":
            if os.path.exists(pathWithoutExt + ".j2w"):
                if not onlyExt:
                    return pathWithoutExt + ".j2w"
                else:
                    return ".j2w"
            else:
                return None
        if ext == ".jpg":
            if os.path.exists(pathWithoutExt + ".jgw"):
                if not onlyExt:
                    return pathWithoutExt + ".jgw"
                else:
                    return ".jgw"
            else:
                return None
        if ext == ".png":
            if os.path.exists(pathWithoutExt + ".pgw"):
                if not onlyExt:
                    return pathWithoutExt + ".pgw"
                else:
                    return ".pgw"
            else:
                return None

    def replaceInfiniteInSLD(self, filepath):
        with open(filepath, 'r') as file :
          filedata = file.read()      
        filedata = filedata.replace('"inf"', '"9999"')     
        with open(filepath, 'w') as file:
          file.write(filedata)

    def removeUnsupportedLaymanTag(self, stylePath, layer):
        provider = layer.dataProvider()      
        stats = provider.bandStatistics(1, QgsRasterBandStats.All, layer.extent(), 0)
        min_value = stats.minimumValue
        max_value = stats.maximumValue   
        with open(stylePath, 'r') as file:
            sld_style = file.read()
        if min_value != 0 and 'quantity="0"' in sld_style:        
            start_tag = r'<sld:Normalize>[\s\S]*?</sld:Normalize>'
            updated_sld_style = re.sub(start_tag, '', sld_style)                            
            updated_sld_style = updated_sld_style.replace('quantity="0"', 'quantity="' + str(min_value)+ '"')
            updated_sld_style = updated_sld_style.replace('quantity="255"', 'quantity="' + str(max_value)+ '"')  
            with open(stylePath, 'w') as file:
                file.write(updated_sld_style)
    
    def postRasterThread(self, layers,data, q,progress, patch, resamplingMethod = "Není vybrán"):
        resamplingMethod = self.resamplingMethods[resamplingMethod]
        print(resamplingMethod)
        for lay in layers:
            if lay.dataProvider().name() != 'wms':
                layer = lay
        if resamplingMethod == "No value" or resamplingMethod == "Není vybrán":
            resamplingMethod = ""
        QgsMessageLog.logMessage("enableProgress")
        data['crs'] = layer.crs().authid()        
        stylePath = self.getTempPath(self.removeUnacceptableChars(layer.name())).replace("geojson", "sld")
        layer.saveSldStyle(stylePath)
        self.removeUnsupportedLaymanTag(stylePath, layer)
        self.replaceInfiniteInSLD(stylePath)
        layer_name = layer.name()
        title = layer_name
        path = layer.dataProvider().dataSourceUri()
        basename = os.path.basename(path)
        if basename == 'OUTPUT.tif':
            name = self.removeUnacceptableChars(layer_name)
            newPath = path.replace(basename, name+ ".tif")
            shutil.copy2(path, newPath)
            path = newPath
        ext = (layer.dataProvider().dataSourceUri()[-4:])
        if (r'/vsizip/') in layer.source():
            path = layer.source().replace("/"+os.path.basename(layer.source()),"").replace(r'/vsizip/','')
            
        files = {'file': (path, open(path, 'rb')),'style': open(stylePath, 'rb')}
        if os.path.getsize(path) > 800000000:
            self.checkFileSizeLimit(os.path.getsize(path))
            self.setChunkSizeBigger()
        externalFile = self.returnPathIfFileExists(path,ext)       
        if (os.path.getsize(path) > self.CHUNK_SIZE):
            if patch:           
                url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+self.removeUnacceptableChars(layer_name)
                r = requests.delete(url,headers = self.getAuthHeader(self.authCfg)) 
            url = self.URI + "/rest/"+self.laymanUsername+"/layers"
            name = self.removeUnacceptableChars(layer_name)           
            if externalFile:
                payload = {     
                'file': [name.lower()+ext,name.lower() + self.returnPathIfFileExists(path,ext, True)],
                'title': title,
                'crs': str(layer.crs().authid()),
                'style': open(stylePath, 'rb'),
                'overview_resampling': resamplingMethod
                }
            else:
                payload = {
                'file': name.lower()+ext,
                'title': title,
                'crs': str(layer.crs().authid()),
                'overview_resampling': resamplingMethod
                }
            files = {'style': open(stylePath, 'rb')}    
            response = self.requestWrapper("POST", url, payload, files)          
            layer_name = self.removeUnacceptableChars(layer_name)
            filePath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) ## chunky se ukládají do adresáře v tempu
            if not (os.path.exists(filePath)):
                os.mkdir(filePath)           
            if externalFile:
                #### externi soubory
                f = open(externalFile, 'rb')
                externalExt = externalFile[-4:]
                arr = []

                for piece in self.read_in_chunks(f):
                    arr.append(piece)
                resumableFilename = layer_name+ externalExt
                layman_original_parameter = "file"
                resumableTotalChunks = len(arr)   
                self.processChunks(arr, resumableFilename, layman_original_parameter,resumableTotalChunks, layer_name,filePath,externalExt)          
            f = open(path, 'rb')
            arr = []
            for piece in self.read_in_chunks(f):
                arr.append(piece) 
            resumableFilename = layer_name+ ext
            layman_original_parameter = "file"
            resumableTotalChunks = len(arr)       
            print(resumableTotalChunks)
            self.processChunks(arr, resumableFilename, layman_original_parameter,resumableTotalChunks, layer_name,filePath,ext)    
        else:        
            if patch:
                url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+self.removeUnacceptableChars(layer_name)         
                r = self.requestWrapper("DELETE", url, payload = None, files = None)
            if externalFile:
                zipPath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) + os.sep +self.removeUnacceptableChars(layer_name)+".zip"
                zipObj = ZipFile(zipPath, 'w') 
                zipObj.write(externalFile, os.path.basename(externalFile))
                zipObj.write(path,os.path.basename(path))
                zipObj.close()
                files = {'file': (zipPath, open(zipPath, 'rb')),'style': open(stylePath, 'rb')}
            data['crs'] = 'EPSG:4326'
            response = self.requestWrapper("POST", self.URI+'/rest/'+self.laymanUsername+'/layers', data, files)
            print(response.content)
            res = self.fromByteToJson(response.content)            
            try:
                if res['code'] == 4:
                    QgsMessageLog.logMessage("unsupportedCRS")
                    QgsMessageLog.logMessage("resetProgressbar")
                    return
            except:
                print("uuid")

        if self.layersToUpload == 1:
            QgsMessageLog.logMessage("resetProgressbar")
            if self.locale == "cs":
                self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(1) + " / " + str(1) )
            else:
                self.dlg.label_progress.setText("Sucessfully exported: " +  str(1) + " / " + str(1) )

        QgsMessageLog.logMessage("export")
        QgsMessageLog.logMessage("disableProgress")
    def processChunks(self, arr, resumableFilename, layman_original_parameter,resumableTotalChunks, layer_name,filePath,ext ):
        for i in range (1, len(arr)+1):  ##chunky jsou počítané od 1 proto +1
            failedRequest = -1
            print("chunk" + str(i))
            file = arr[i-1] # rozsekaná část souboru
            resumableChunkNumber = i  # cislo casti
            payload = {
            'file' : "chunk"+str(i)+ ext,
            'resumableFilename': resumableFilename,
            'layman_original_parameter': layman_original_parameter,
            'resumableChunkNumber': i,
            'resumableTotalChunks': resumableTotalChunks
            }
            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layer_name+'/chunk'
            f = open(filePath + os.sep+"chunk"+str(i)+ ext, "wb")
            f.write(bytearray(arr[i-1]))
            f.close()
            files = {'file': (layer_name.lower().replace(" ", "_")+ext, open(filePath +os.sep+ "chunk"+str(i)+ext, 'rb')),}         
            while failedRequest != 0:
                try:
                    failedRequest = 0                   
                    response = self.requestWrapper("POST", url, payload, files)
                    
                except:
                    failedRequest = failedRequest + 1
                    if failedRequest == 3:
                        QgsMessageLog.logMessage("errorConnection")
                        QgsMessageLog.logMessage("resetProgressbar")
                        if self.locale == "cs":
                            self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(0) + " / " + str(1) )
                        else:
                            self.dlg.label_progress.setText("Sucessfully exported: " +  str(0) + " / " + str(1) )
                        return

            try:
                if self.layersToUpload == 1:
                    self.processingRaster.emit(i,resumableTotalChunks)                    
            except:
                pass
                  
             

        QgsMessageLog.logMessage("export")
    def postThread(self, layer_name,data, q,progress):
        if layer_name in self.mixedLayers:
            layers = QgsProject.instance().mapLayersByName(layer_name)
            paths = list()
            for layer in layers:
                paths.append(self.json_exportMix(layer))
            self.mergeGeojsons(paths, self.getTempPath(self.removeUnacceptableChars(layer.name()))),self.removeUnacceptableChars(layer.name())

        else:
            if not (self.json_export(layer_name)):
                self.reprojectionFailed.emit(layer_name)
                return      
        geoPath = self.getTempPath(self.removeUnacceptableChars(layer_name))
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0") and qgis.core.Qgis.QGIS_VERSION_INT <= 32603:
            stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "qml")
        else:
            stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "sld")
        if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
            if os.path.getsize(geoPath) > 800000000:
                self.checkFileSizeLimit(os.path.getsize(geoPath))
                self.setChunkSizeBigger()
            self.postInChunks(layer_name, "post")
        else:
            if(os.path.isfile(stylePath)): ## existuje style?    
                files = [('file', open(geoPath, 'rb')), ('style', open(stylePath, 'rb'))]
            else:
                files = {'file': (geoPath, open(geoPath, 'rb')),}


            response = self.requestWrapper("POST", self.URI+'/rest/'+self.laymanUsername+'/layers', data, files)
            
            status = response.status_code
            print(status)
       
        if progress:      
            
            if (os.path.getsize(geoPath) > self.CHUNK_SIZE): 
                response = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name), payload = None, files = None)
            if (response.status_code == 200):
                try:
                    self.uploaded = self.uploaded + 1
                except:
                    pass              
                self.exportLayerSuccessful.emit(layer_name)
            elif (response.status_code == 413):
                QgsMessageLog.logMessage("importl_"+layer_name)
                self.writePostLog(str(layer_name), str(response.status_code), str(response.content))
            else:
                self.exportLayerFailed.emit(layer_name)
                self.writePostLog(str(layer_name), str(response.status_code), str(response.content))
            self.importedLayer = layer_name
            self.processingList[q][2] = 1         
            QgsMessageLog.logMessage("export")
        self.cleanTemp.emit(self.removeUnacceptableChars(layer_name))
    def writePostLog(self, name, code, ret):        
        filename = tempFile = tempfile.gettempdir() + os.sep + "import_log.txt"
        with open(filename, 'a') as file:    
            file.write(name + ";" + code +";"+ ret)      
    def copyErrLog(self):            
        filename = tempFile = tempfile.gettempdir() + os.sep + "import_log.txt"
        with open(filename, 'r') as file:
            file_contents = file.read()
        PyQt5.QtGui.QGuiApplication.clipboard().setText(file_contents)   

    def getLayersOrder(self):
        bridge = iface.layerTreeCanvasBridge()
        root = bridge.rootGroup()
        return root.layerOrder()
    
    def addLayerToPath(self, name, groupName):     
        composition = self.instance.getComposition()    
        for i in range (0, len(composition['layers'])):
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)): #
                composition['layers'][i]['path'] = groupName
                print("modifing " + composition['name'] + "adding group name " + groupName)
             


    def checkLayerPath(self, name):        
        composition = self.instance.getComposition()
        for i in range (0, len(composition['layers'])):
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)):
                try:
                    if composition['layers'][i]['path'] != "":
                        del composition['layers'][i]['path']
                        print("modifing " + composition['name'] + "layer " + name)                   
                    else:
                        pass
                except:
                    print("path not found. Skipping")

    def getCompositionIndexByName(self, name=""):
        if name == "":
            current = self.current
        else:
            current = name
        
        for x in range (0, len(self.compositeList)):
            if self.removeUnacceptableChars(self.compositeList[x]['title']) == self.removeUnacceptableChars(current):
                return x
    def checkPossibleChars(self, layername):
        unacceptable = "/*+%!?:><&@#'"
        for ch in layername:
            if ch in unacceptable:
                return False
        return True

    def readDimFromCapatibilites(self, url, name):
        r = requests.get(url + "?service=wms&request=GetCapabilities")   
        dimension = ""
        e = ET.ElementTree(ET.fromstring(r.content))       
        check = False
        for elt in e.iter():
            if (elt.tag.split("}")[1] == "Title"):
                if (self.removeUnacceptableChars(elt.text)== self.removeUnacceptableChars(name)):
                    check = True
            if (elt.tag.split("}")[1] == "Dimension"):
                if check:
                    print(elt.text)
                    dimension = elt.text
                    check = False
                    return dimension
    def postRequest(self, layer_name, auto=False, thread=False, bulk = False, resamplingMethod = "Není vybrán"):
        nameCheck = True
        validExtent = True
        layers = QgsProject.instance().mapLayersByName(layer_name)    
        layers[0].setName(layer_name)
        if len(layers) > 1:
            for l in layers:
                if (isinstance(l, QgsVectorLayer)):
                    layers.clear()
                    layers.append(l)
                    break     
        if not self.checkPossibleChars(layer_name):
            QgsMessageLog.logMessage("wrongName")
            return      
        if (nameCheck and validExtent):       
            data = { 'name' :  str(layer_name).lower(), 'title' : str(layer_name)}
            if (self.checkValidAttributes(layer_name)):
                if (self.checkExistingLayer(layer_name)):
                    if not auto:
                        if not bulk:
                            if self.locale == "cs":
                                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Vrstva "+layer_name+" již na serveru existuje. Chcete přepsat její geometrii?")
                            else:
                                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Layer "+layer_name+" already exists in server. Do you want overwrite it´s geometry?")
                            msgbox.addButton(QMessageBox.Yes)
                            msgbox.addButton(QMessageBox.No)
                            msgbox.setDefaultButton(QMessageBox.No)
                            reply = msgbox.exec()
                        else:
                             reply = QMessageBox.Yes                           
                        if (reply == QMessageBox.Yes):
                            self.dlg.progressBar.show()
                            self.dlg.label_import.show()
                            q = self.setProcessingItem(layer_name)
                            if (isinstance(layers[0], QgsVectorLayer)):
                                if layers[0].crs().authid() in self.supportedEPSG:
                                    threading.Thread(target=lambda: self.patchThread(layer_name,data, q, True)).start()
                                else:
                                    QgsMessageLog.logMessage("wrongCrs")                                    
                            if (isinstance(layers[0], QgsRasterLayer)):
                                if layers[0].isValid():
                                    if layers[0].crs().authid() in self.supportedEPSG:
                                        ext = layers[0].dataProvider().dataSourceUri()[-4:]
                                        if ext.lower() != ".bmp":
                                            threading.Thread(target=lambda: self.postRasterThread(layers,data, q,True, True, resamplingMethod)).start()
                                        else:
                                            QgsMessageLog.logMessage("BmpNotSupported")
                                    else:
                                        QgsMessageLog.logMessage("wrongCrs")
                                else:
                                    QgsMessageLog.logMessage("invalid")                           

                        else:
                            self.batchLength = self.batchLength - 1
                    else:

                        q = self.setProcessingItem(layer_name)
                        if (isinstance(layers[0], QgsVectorLayer)):
                            if thread:
                                threading.Thread(target=lambda: self.patchThread(layer_name,data, q, True)).start()
                            else:
                                self.patchThread(layer_name,data, q, True)
                        if (isinstance(layers[0], QgsRasterLayer)):
                            if layers[0].isValid():
                                if layers[0].crs().authid()  in self.supportedEPSG:
                                    ext = layers[0].dataProvider().dataSourceUri()[-4:]
                                    if ext.lower() != ".bmp":
                                        if thread:
                                            threading.Thread(target=lambda: self.postRasterThread(layers,data, q,True, True, resamplingMethod)).start()
                                        else:
                                            self.postRasterThread(layers,data, q,True, True, resamplingMethod)
                                    else:
                                        QgsMessageLog.logMessage("BmpNotSupported")
                                else:
                                    QgsMessageLog.logMessage("wrongCrs")
                            else:
                                QgsMessageLog.logMessage("invalid")
                else:

                    self.layerName = layer_name                   
                    if(True): ##Pravděpodobně nebude třeba testovat EPSG, pokud se detekuje, je vrstva transformována.                      
                        if not auto:
                            self.dlg.progressBar.show()
                            self.dlg.label_import.show()
                        if auto:
                            read = self.instance.getAllPermissions()['read']
                            write = self.instance.getAllPermissions()['write']
                            data['access_rights.read'] =  self.listToString(read)
                            data['access_rights.write'] = self.listToString(write)

                            
                        q = self.setProcessingItem(layer_name)

                        if (isinstance(layers[0], QgsVectorLayer)):
                            if thread:
                                if layers[0].crs().authid() in self.supportedEPSG:
                                    threading.Thread(target=lambda: self.postThread(layer_name,data, q,True)).start()
                                else:
                                    QgsMessageLog.logMessage("wrongCrs")                                    
                            else:
                                self.postThread(layer_name,data, q,True)
                        if (isinstance(layers[0], QgsRasterLayer)):
                            if layers[0].isValid():
                                if layers[0].crs().authid()  in self.supportedEPSG:
                                    ext = layers[0].dataProvider().dataSourceUri()[-4:]
                                    if ext.lower() != ".bmp":
                                        if thread:
                                            threading.Thread(target=lambda: self.postRasterThread(layers,data, q,True, False, resamplingMethod)).start()
                                        else:
                                            self.postRasterThread(layers,data, q,True, False, resamplingMethod)

                                    else:
                                        QgsMessageLog.logMessage("BmpNotSupported")
                                else:
                                    QgsMessageLog.logMessage("wrongCrs")
                            else:
                                QgsMessageLog.logMessage("invalid")                  
                    else:
                        if self.locale == "cs":
                            QMessageBox.information(None, "Layman", "Použijte EPSG:4326")
                        else:
                            QMessageBox.information(None, "Layman", "Use EPSG:4326")
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Layman", "Vrstva "+layer_name+" nemá atributy!")
                else:
                    QMessageBox.information(None, "Layman", "Layer "+layer_name+" does not have attributes!")
    def setProcessingItem(self, layer_name):
        queue = len(self.processingList)
        self.processingList.append([queue, layer_name, 0])
        return queue  
    def isXYZ(self, name):
        layer = QgsProject.instance().mapLayersByName(name)[0]
        params = layer.dataProvider().dataSourceUri().split("&")
        layers = list()
        for p in params:  
            if(str(p) == "type=xyz"):
                return True

        return False
    
    def saveXYZ(self, layer):        
        title = layer.name()
        dimension = ""
        params = layer.dataProvider().dataSourceUri().split("&")
        composition = self.instance.getComposition()
        for p in params:
            param = p.split("=")            
            if(param[0] == "url"):
                url = param[1]
        crs = layer.crs().authid()
        if layer.hasScaleBasedVisibility():
            minScale = (self.scaleToResolution(layer.minimumScale()))           
        else:
            minScale = None
        composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":title,"className":"XYZ","singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution": minScale,"minResolution":(self.scaleToResolution(layer.maximumScale())),"url": url ,"params":{"LAYERS": "","INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
    def scaleToResolution(self, denominator):   
        map_settings = iface.mapCanvas().mapSettings()
        crs = map_settings.destinationCrs()
        units = crs.mapUnits()
        dpi = 25.4 / 0.28
        mpu = QgsUnitTypes.fromUnitToUnitFactor(QgsUnitTypes.DistanceMeters, units)    
        return denominator / (mpu * 39.37 * dpi)    

    def resolutionRounder(self,x):
        rounded = int(round(x / 5000.0) * 5000)
        power = len(str(rounded)) - 1
        first_digit = int(str(rounded)[0])
        return first_digit * 10**power    
    def resolutionToScale(self, resolution):
        map_settings = iface.mapCanvas().mapSettings()
        crs = map_settings.destinationCrs()        
        dpi = 25.4 / 0.28  #  96 dpi         
        if resolution < 0.72: ##  hranice spatneho zaorouhleni
            return round(resolution * 39.37 * dpi, -3)
        else:
            return self.resolutionRounder(round(resolution * 39.37 * dpi))
    def getGreyScaleMode(self, layer):
        pipe  = layer.pipe()        
        greyscale = False if pipe.hueSaturationFilter().grayscaleMode() == 0 else True
        return greyscale
    def getLegendUrlFromCapatibilites(self, layer):
        layers = list()
        for item in layer.dataProvider().uri().uri().split("&"):
            if "contextualWMSLegend=" in item:
                val = item.replace("contextualWMSLegend=","").replace("'","").replace(" ","")              
            if "url=" in item:
                url = item.replace("url=","").replace("'","")           
            if "layers=" in item:
                layer = item.replace("layers=","").replace("'","")
                layers.append(layer)            
      
        r = requests.get(url+"?service=wms&version=1.1.1&request=GetCapabilities")        


        tree = ET.ElementTree(ET.fromstring(r.content))
        root = tree.getroot()
        ret = list()
        for layer in layers:
            i = 0
            for name in  root.findall("./Capability/Layer/Layer/Name"):      
                name = name.text   
                if name == layer:
                    break
                i = i + 1
            link = root.findall("./Capability/Layer/Layer/Style/LegendURL/OnlineResource")
            for key in link[i].attrib:
                if "href" in key:
                    link = link[i].attrib[key].replace("service=wms","")
                    ret.append(link)
        return [val, ret]

    def addExistingWMSLayerToCompositeThread2(self, title,nameInList):
        composition = self.instance.getComposition()
        print("nameInList"+ nameInList)
        name = self.removeUnacceptableChars(title).lower() 
        dimension = ""
        layer = QgsProject.instance().mapLayersByName(nameInList)[0]
        legend = list()
        try:
            legend = self.getLegendUrlFromCapatibilites(layer)
        except:
            print("legend failed")
            legend.append("0")
        greyScale = self.getGreyScaleMode(layer)
        arc = False
        if layer.dataProvider().name() == "arcgismapserver":
            arc = True
        if "&" in layer.dataProvider().dataSourceUri():
            params = layer.dataProvider().dataSourceUri().split("&")            
        else:
            params = layer.dataProvider().dataSourceUri().split(" ") ## arcgis use whitespace
            
        if not (self.isXYZ(layer.name())): 
            layers = list()
            for p in params:     
                param = p.split("=")
                if(str(param[0]) == "crs"):
                    crs = (param[1])
                if(str(param[0]) == "format"):
                    format = (param[1])   
                    format = format.replace("'", "")
                if(str(param[0]) == "url"):
                    url = (param[1]) 
                    url = url.replace("'", "")                   
                if(str(param[0]) == "layers"):
                    layers.append(param[1])
                if(str(param[0]) == "timeDimensionExtent"):
                    dimension = (param[1])
             
            if (len(layers) == 1):
                layers = str(layers).replace("[", "").replace("]", "").replace("'", "")
            else:
                layers = str(layers).replace("'", "")
            self.existLayer = False
            print(dimension)
            if dimension == "":
                composition['layers'].append({"metadata":{},"visibility":True,"opacity":layer.opacity(),"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS" if not arc else "ArcGISRest","dimensions":{},"singleTile":False, "greyscale": greyScale,  "base": False,"wmsMaxScale":0,"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
            else:              

                composition['layers'].append({"metadata":{},"visibility":True,"opacity":layer.opacity(),"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS" if not arc else "ArcGISRest","dimensions": { "time": { "default": dimension.split(",")[0], "name": "time", "unitSymbol": None, "units": "ISO8601", "value": dimension.split(",")[0], "values": dimension} },"singleTile":True,"greyscale": greyScale, "base": False,"wmsMaxScale":0,"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5})
           
        else:           
            for p in params:
                param = p.split("=")
                #print(p)
                if(param[0] == "url"):
                    url = param[1]
            crs = layer.crs().authid()
            composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"XYZ","singleTile":False,"greyscale": greyScale, "base": False,"wmsMaxScale":0,"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": "","INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
        print("legend set to:")
        print(legend[0])
        
        if legend[0] == "1":
            composition["legends"] = legend[1]         
        
        QgsMessageLog.logMessage("addRaster")
    def saveExternalStyle(self,style, layer_name):
        suffix = ".sld"
        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layer_name) + suffix
        with open(tempf, 'wb') as f:
            f.write(style.encode())        
    def getStyle(self, layer_name, style = None, workspace = None):
        if workspace:
            self.selectedWorkspace = workspace
        if style is not None:
            suffix = ".sld"
            self.saveExternalStyle(style, layer_name)     
            return 200, suffix.replace(".","")
        if self.selectedWorkspace:
            response = requests.get(self.URI+'/rest/'+self.selectedWorkspace+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', headers = self.getAuthHeader(self.authCfg))
            #response = self.requestWrapper("GET", self.URI+'/rest/'+self.selectedWorkspace+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', payload = None, files = None)
        else:
            #response = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', payload = None, files = None)
            response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', headers = self.getAuthHeader(self.authCfg))      
        res = response.content
        res = res.decode("utf-8")
        if (res[0:5] == "<qgis" and response.status_code == 200):
            print("got qml")
            suffix = ".qml"

        if (res[0:5] == "<?xml" and response.status_code == 200):
            print("got sld")
            suffix = ".sld"
        try:
            tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layer_name) + suffix
        except:
            print("symbologie nenalezena")
            return (400,"")
        
        with open(tempf, 'wb') as f:
            f.write(response.content)                 
        return response.status_code, suffix.replace(".","")
    def getSLD(self, layer_name):       
        response = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', payload = None, files = None)
        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layer_name)+ ".sld"
   
        with open(tempf, 'wb') as f:
            f.write(response.content)       
        return response.status_code
    
    def layerInfoRedirect(self, name):
        url = self.URI+'/rest/'+self.laymanUsername+"/layers/" + name     
        response = self.requestWrapper("GET", url, payload = None, files = None)
        r = self.fromByteToJson(response.content)
        try:
            url = r['metadata']['record_url']
            webbrowser.open(url, new=2) ## redirect na micku pro více info
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Odkaz není k dispozici.")
            else:
                QMessageBox.information(None, "Layman", "Link is unavailable.")
    def checkLayerOnLayman(self, layer_name, workspace=""):
        if self.selectedWorkspace:
            url = self.URI+'/rest/'+self.selectedWorkspace+"/layers/"+layer_name
        else:
            url = self.URI+'/rest/'+self.laymanUsername+"/layers/"+layer_name
        print(url)
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))        
        try:
            data = r.json()

            if data['wms']['status'] == 'NOT_AVAILABLE' or data['wms']['status'] == 'PENDING':
                return False
            else:
                return True
        except:
            return True # validní vrstva nemá status

    def checkServiceAvailability(self):
        try:
            if (isinstance(self.dlg.mMapLayerComboBox.currentLayer(),QgsRasterLayer)):
                self.dlg.radioButton_wfs.setEnabled(False)
            else:
                self.dlg.radioButton_wfs.setEnabled(True)
        except:
            pass
    
    def findParamForWfs(self, param, layer):
        string = layer.dataProvider().uri().uri()
        start = layer.dataProvider().uri().uri().find(param) + len(param)
        end = string.find("'", start)
        value = string[start:end]   
        return value                                        
    def addLayerToComposite2(self,composition, layersList):        
        print(layersList)
        for layer in layersList:
            self.showExportInfo.emit("Nahrávání vrstvy: " + layer.name() if self.locale == "cs" else "Uploading layer: " + layer.name())
            if (isinstance(layer,QgsRasterLayer)) and layer.dataProvider().uri().uri() != "":
                print("External WMS detected")
                self.addExternalWMSToComposite(layer.name())
            if layer.type() == QgsMapLayer.VectorLayer and layer.dataProvider().name() == 'WFS':
                print("External WFS detected")
                path = ""
                path = self.getGroupOfLayer(layer)
                if path == 'root':
                    path = ""
                url = self.findParamForWfs("url='", layer)  
                title = self.findParamForWfs("typename='", layer)  
                layerTreeRoot = QgsProject.instance().layerTreeRoot()
                layerTreeNode = layerTreeRoot.findLayer(layer.id())    
                layerName = self.removeUnacceptableChars(layer.name()).lower() 
                if layer.hasScaleBasedVisibility():
                    minScale = (self.scaleToResolution(layer.minimumScale()))                    
                else:
                    minScale = None    
                composition['layers'].append({"metadata":{}, 'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":layer.opacity(),"title":layer.name(),"className":"OpenLayers.Layer.Vector","style": "","singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution":minScale,"minResolution":(self.scaleToResolution(layer.maximumScale())),"name": str(title),"protocol":{"format": "hs.format.externalWFS","url": url},"ratio":1.5,"visibility": layerTreeNode.isVisible(),"dimensions":{}})
            elif (isinstance(layer,QgsVectorLayer))  or layer.dataProvider().uri().uri() == "":

                layers = []
                layers.append(layer)
                successful = 0                
                path = ""
                path = self.getGroupOfLayer(layer)
                if path == 'root':
                    path = ""


              
                for i in range (0, len(layers)):
                    for item in self.currentSet:
                        if self.removeUnacceptableChars(item[0]) == self.removeUnacceptableChars(layers[i].name()):
                            service = item[1].lower()
                    self.dlg.progressBar_loader.show()
                    layerName = self.removeUnacceptableChars(layers[i].name()).lower()                   
                    if layers[i].hasScaleBasedVisibility():
                        minScale = (self.scaleToResolution(layers[i].minimumScale()))
                    
                    else:
                        minScale = None
                    if service == 'wms':                      
                        
                        if True:
                            if self.isXYZ(layers[i].name()):
                                self.saveXYZ(layers[i])
                            else:
                                wmsUrl = self.URI.replace("/client","")+'/geoserver/'+self.laymanUsername+'_wms/ows'
                                composition['layers'].append({"metadata":{},'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":layer.opacity(),"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution":minScale,"minResolution":(self.scaleToResolution(layers[i].maximumScale())),"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5, "visibility": True,"dimensions":{}})
                                               
                    elif service == 'wfs':
                        wmsUrl = self.URI.replace("/client","")+'/geoserver/'+self.laymanUsername+'/wfs'
                        styleUrl = self.URI+'/rest/'+self.laymanUsername+'/layers/'+ str(layerName) + "/style"

                        composition['layers'].append({"metadata":{}, 'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":layer.opacity(),"title":str(layers[i].name()),"className":"OpenLayers.Layer.Vector","style": styleUrl,"singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution":minScale,"minResolution":(self.scaleToResolution(layers[i].maximumScale())),"name": str(layerName),"protocol":{"format": "hs.format.WFS","url": wmsUrl},"ratio":1.5,"visibility": True,"dimensions":{}})


                    else:
                        wmsUrl = self.URI.replace("/client", "") +'/geoserver/'+self.laymanUsername+'_wms/ows'
                        composition['layers'].append({"metadata":{},'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":layer.opacity(),"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":False, "base": False,"wmsMaxScale":0,"maxResolution":minScale,"minResolution":(self.scaleToResolution(layers[i].maximumScale())),"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"visibility": True,"dimensions":{}})
                    successful = successful + 1
                print("saving layer records to composition")
               

                for i in range (0, len(layers)):



                    inComposite = False
                    layerName = self.removeUnacceptableChars(layers[i].name()).lower()
                    if (self.checkExistingLayer(layers[i].name()) and inComposite):
                        j = self.getLayerInCompositePosition(x)                        
                        if self.isXYZ(layers[i].name()):                       
                            pass
                        else:
                            self.postRequest(layers[i].name(), True)
                            layerName = self.removeUnacceptableChars(layers[i].name())

                    else:
                        if self.isXYZ(layers[i].name()):                           
                            pass
                        else:
                            self.postRequest(layers[i].name(), True)
                     
        self.processingRequest = False
    def removeRastersWithoutCrs(self, layers):
        unacceptableLayers = list()
        nonValid = list()
        pom = 0
        for layer in layers:
            if not layer.isValid():
                nonValid.append(layer.name())
                layers = (set(layers)- set([layer]))
                pom = pom + 1
            if isinstance(layer, QgsRasterLayer):
                if layer.crs().authid() not in self.supportedEPSG:
                    pom = pom + 1
                    unacceptableLayers.append(layer.name())                    
                    layers = (set(layers)- set([layer]))                    

        if pom > 0 :
            toOutput = "\n".join(unacceptableLayers)
            if len(nonValid) > 0:
                if self.locale == "cs":
                    toOutput = toOutput + "\n" + "Nevalidní vrstvy:" + "\n" + "\n".join(nonValid)
                else:
                    toOutput = toOutput + "\n"+ "\n" + "Non valid layers:" + "\n" + "\n".join(nonValid)
            QgsMessageLog.logMessage("wrongCrss" + toOutput)
        return layers


    def getProgressBarStep(self, count):
        return (100/count)  

    def importCleanComposite(self,x):
        tempFile = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(tempFile, 'w') as outfile:
            json.dump(self.compositeList[x], outfile)
        with open(tempFile, 'rb') as f:
            d = json.load(f)
        files = {'file': (tempFile, open(tempFile, 'rb')),}       
        data = { 'name' :  self.compositeList[x]['name'], 'title' : self.compositeList[x]['title'], 'description' : self.compositeList[x]['abstract'], 'access_rights.read': self.laymanUsername,   'access_rights.write': self.laymanUsername}
        url = self.URI+'/rest/'+self.laymanUsername+'/maps'
        response = requests.post(url , files=files, data = data, headers = self.getAuthHeader(self.authCfg))  
        if (response.status_code == 200):
            if self.locale == "cs":     
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + self.compositeList[x]['name'] + " byla úspešně vytvořena."), Qgis.Success, duration=3)
            else:           
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + self.compositeList[x]['name'] + " was sucessfully created."), Qgis.Success, duration=3)
        else:
            self.showErr.emit([" Kompozice  " + self.compositeList[x]['name'] + " nebyla vytvořena.", " Composition  " + self.compositeList[x]['name'] + " was not sucessfully created."], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)        

    def showProgressBar(self, bar):
        bar = QProgressBar()
        bar.setRange(0,0) ## range 0,0 je nekonečný
        self.showProgressBar(bar)
        bar.show()
        iface.mainWindow().statusBar().addWidget(bar)
    def fromByteToJson(self, res):
        pom = res
        pom = pom.decode('utf_8')
        try:
            pom = json.loads(pom)
        except:
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Došlo k chybě při komunikaci se serverem.")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "An error occurred while communicating with the server.")
            return

        return pom
    
    def compositionToClipboard(self):

        composition = self.instance.getComposition()
        df=pd.DataFrame([composition])
        df.to_clipboard(index=False,header=False)
    def patchMap2(self):
        self.showExportInfo.emit("Ukládání kompozice" if self.locale == "cs" else "Saving composition")
        composition = self.instance.getComposition()        
        print("composition")
        print(composition)
        tempFile = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(tempFile, 'w') as outfile:
            json.dump(composition, outfile)
        jsonPath = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(jsonPath, 'rb') as f:
            d = json.load(f)
        
        files = {'file': (jsonPath, open(jsonPath, 'rb')),}
       # data = { 'name' :  composition['name'], 'title' : composition['title'], 'description' : composition['abstract'], 'access_rights.read': self.laymanUsername + ', EVERYONE',   'access_rights.write': self.laymanUsername}
        data = { 'name' :  composition['name'], 'title' : composition['title'], 'description' : composition['abstract']}

        read = self.instance.getAllPermissions()['read']
        write = self.instance.getAllPermissions()['write']
        data['access_rights.read'] =  self.listToString(read)
        data['access_rights.write'] = self.listToString(write)
        print("export map")      
        workspace = self.instance.getWorkspace()       
        r = self.requestWrapper("DELETE", self.URI+'/rest/'+workspace+'/maps/'+composition['name'], payload = None, files = None)      
        time.sleep(1)
        # response = requests.request("POST", self.URI + '/rest/' + workspace + '/maps', headers=self.getAuthHeader(self.authCfg),data=data, files=files)
        response = self.requestWrapper("POST", self.URI+'/rest/'+workspace+'/maps', data, files)   
        self.processingRequest = False        
        res = self.fromByteToJson(response.content)
        return response   

    def deleteLayer(self, layerName):
        url = self.URI+'/rest/'+self.laymanUsername+"/layers/" + layerName     
        r = self.requestWrapper("DELETE", url, payload = None, files = None)

    # def getActiveLayer(self):
    #     layer = self.iface.activeLayer()
    #     return layer

    def createComposite(self, name, title, setCurrent = False):         
        if QgsProject.instance().crs().authid() not in self.supportedEpsg:
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není nastaveno podporované EPSG projektu.")
            else:
                QMessageBox.information(None, "Message", "Project EPSG is not supported.")
            return
        if (title == ""):
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není vyplněn titulek!")
            else:
                QMessageBox.information(None, "Message", "Title is not filled!")
        else:
            name = self.removeUnacceptableChars(title)
            
            data = self.getEmptyComposite(name,title)
            print(name)
            self.compositeList.append(data)
            x = len(self.compositeList) - 1
            self.importCleanComposite(x)
            try:
                self.refreshCompositeList(True)
            except:
                print("err")
            if setCurrent:                
                self.current = name
                self.selectedWorkspace = self.laymanUsername
                url = self.URI+'/rest/'+self.selectedWorkspace+'/maps/'+name+'/file'  
                r = self.requestWrapper("GET", url, payload = None, files = None)
                data = r.json()
                print(data)
                self.instance = CurrentComposition(self.URI, name, self.selectedWorkspace, self.getAuthHeader(self.authCfg),self.laymanUsername)
                self.instance.setComposition(data)
                self.compositionDict[name] = title
                ## sync start
                prj = QgsProject().instance()
                QgsProject().instance().setTitle(title)
                root = prj.layerTreeRoot()                         
             
                self.prj=QgsProject.instance()
                self.prj.removeAll.connect(self.removeSignals)
                self.menu_CurrentCompositionDialog.setEnabled(True)    
                self.processingRequest = False
                composition = self.instance.getComposition()
                root = QgsProject.instance().layerTreeRoot()             
                
                QgsProject.instance().setTitle(title)
                self.afterCloseNewMapDialog()


    def patchLayer(self, layer_name, data):
        print("patchLayer")      
        self.layerName = self.removeUnacceptableChars(layer_name)

        geoPath = self.getTempPath(self.layerName)

        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0")  and qgis.core.Qgis.QGIS_VERSION_INT <= 32603:
            stylePath = self.getTempPath(self.layerName).replace("geojson", "qml")
        else:
            stylePath = self.getTempPath(self.layerName).replace("geojson", "sld")      

        if(os.path.isfile(stylePath)): ## existuje styl?
            files = [('file', open(geoPath, 'rb')), ('style', open(stylePath, 'rb'))]

        else:
            files = {'file': (geoPath, open(geoPath, 'rb')),}

        layer_name = layer_name.lower()
        layer_name = layer_name.replace(" ", "_")
        layer_name = self.removeUnacceptableChars(layer_name)
        url = self.URI+'/rest/' + self.laymanUsername + "/layers/" + layer_name
        r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        #r = self.requestWrapper("GET", url, payload = None, files = None)
        res = r.json()
        read = res['access_rights']['read']
        write = res['access_rights']['write']
        data['access_rights.read'] =  self.listToString(read)
        data['access_rights.write'] = self.listToString(write)
        if r.status_code == 200:
            #r = requests.delete(url, headers = self.getAuthHeader(self.authCfg))  
            r = self.requestWrapper("DELETE", url, payload = None, files = None)     
        time.sleep(0.5)
        url = self.URI+'/rest/' + self.laymanUsername + "/layers/"        
        #r = requests.post(self.URI+'/rest/'+self.laymanUsername+'/layers', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        r = self.requestWrapper("POST", self.URI+'/rest/'+self.laymanUsername+'/layers', data, files)
        return r       
       

    def getTempPath(self, name):
        if type(name) is tuple:
            return (name[0] +  name[1])
        else:
            tempFile = tempfile.gettempdir() + os.sep + name +'.geojson'
            return tempFile
    def getExistingLayers(self):
        url = self.URI+'/rest/'+self.laymanUsername+"/layers"
       # r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()
        for x in range(len(data)):
            print(data[x]['name'])
        return data
    
    def checkExistingLayer(self, layerName):
        layerName = self.removeUnacceptableChars(layerName)
        url = self.URI+'/rest/'+self.laymanUsername+"/layers"
        r = self.requestWrapper("GET", url, payload = None, files = None)      
        if not r:
            return
        data = r.json()

        pom = set()
        for x in range(len(data)):
            pom.add((data[x]['name']))
        layerName = layerName.replace(" ", "_").lower()     
        if (layerName in pom):
            return True
        else:
            return False

    def removeUnacceptableChars(self, input):
        if input[0] == " ":
            input = input[1:]
        input = input.lower()
        input = input.replace("ř","r")
        input = input.replace("š","s")
        input = input.replace("ž","z")
        input = input.replace("ů","u")
        input = input.replace("ú","u")
        input = input.replace(" ","_")
        input = input.replace("é","e")
        input = input.replace("í","i")
        input = input.replace("ý","y")
        input = input.replace("á","a")
        input = input.replace("ň","n")
        input = input.replace("ó","o")
        input = input.replace("č","c")
        input = input.replace("ď","d")
        input = input.replace("ě","e")
        input = input.replace("ť","t")
        input = input.replace("-","_")
        input = input.replace(".","_")
        input = input.replace(",","")
        input = input.replace(":","")
        input = input.replace("/","_")
        input = input.replace("(","")
        input = input.replace(")","")
        input = input.replace("___","_")
        input = input.replace("__","_")
        input = re.sub(r'[?|$|.|!]',r'',input)
        try:
            if input[len(input) - 1] == "_":
                input = input[:-1]
        except:
            print("removechars exception")
        return input

    def test (self):
        item = self.dlgGetLayers.items.currentItem().text()     

    def isLayerInComposite(self, x):
        layers =[]
        layers.append(self.dlg.mMapLayerComboBox.currentLayer())          
        req = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file', payload = None, files = None)
        data = req.json()
   
        existingLayers = []
        for i in range (0, len(data['layers'])):
            for j in range (0, len(layers)):
                if (data['layers'][i]['title'] in layers[j].name() ):
                    existingLayers.append(data['layers'][i]['title'])              

        return existingLayers
    def getLayerInCompositePosition(self, x):
        layers =[]
        layers.append(self.dlg.mMapLayerComboBox.currentLayer())     
   
        req = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file', payload = None, files = None)
        data = req.json()       
        existingLayers = []
        j = 0
        for i in range (0, len(data['layers'])):
            for j in range (0, len(layers)):
                try:                    
                    layer = data['layers'][i]['params']['LAYERS'] # wms
                except:
                    layer = data['layers'][i]['name']
                if (layer in layers[j].name()):                  
                   j = i 
        return j
    def isRasterLayerInComposite(self, x, name):
        name = self.removeUnacceptableChars(name).lower()
        req = self.requestWrapper("GET", self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file', payload = None, files = None)
        data = req.json()
        existingLayers = []
        for i in reversed(range (0, len(data['layers']))):       
             if (self.removeUnacceptableChars(data['layers'][i]['title']) ==  name ):
                existingLayers.append(self.removeUnacceptableChars(data['layers'][i]['title']))        
        return existingLayers

    def addComposite(self, data, service, groupName = ''):  
        for x in range(len(data['layers'])- 1, -1, -1):        
            repairUrl = self.URI+"/geoserver/"+self.laymanUsername+"/ows"
            layerName = data['layers'][x]['params']['LAYERS']
            format = data['layers'][x]['params']['FORMAT']        
            epsg = 'EPSG:4326'           
            wmsName = data['layers'][x]['params']['LAYERS']
            className = data['layers'][x]['className']
            layerNameTitle = self.getLayerTitle(layerName)
            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layerName           
            r = self.requestWrapper("GET", url, payload = None, files = None)
            res = r.json()
            if service == 'WMS':
                UrlWms = data['layers'][x]['url']
                if className == 'XYZ':
                    self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName)
                else:
                    self.loadWms(UrlWms, layerName,layerNameTitle, format,epsg, groupName)

            if service == 'WFS':                
                UrlWms = data['layers'][x]['url']
                self.loadWfs(UrlWfs, layerName,layerNameTitle, groupName)

    def convertUrlFromHex(self, url):
        url = url.replace('%3A',':')
        url = url.replace('%2F','/')
        url = url.replace('%3F','?')
        url = url.replace('%3D','=')
        url = url.replace('%26','&')
        return url
    def getCompositionWorkspace(self, name):
        url = self.URI+'/rest/maps'        
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()
        for row in range(0, len(data)):
            if name == data[row]['name']:
                return data[row]['workspace']
    def loadService2(self, data, service, groupName = ''):    
        if not 'layers' in data:       
            print("corrupted composition")
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Kompozice je poškozena!")
            else:
                QMessageBox.information(None, "Layman", "Map composition is corrupted!")
            return      

        #self.service3 = threading.Thread(target=lambda: self.loadservice3(data))
        #self.service3.start()
        self.loadservice3(data)
    def loadservice3(self, data):
        groupName = ''
        threads = list()
        i=1
        groups = list()
        groupPositions = list()
        groupsSet = set()
        for x in range(len(data['layers'])- 1, -1, -1):       ## descending order
            print("iteration")
            try:
                subgroupName =  data['layers'][x]['path']
            except:
                print("path for layer not found")
                subgroupName = ""
            try:
                timeDimension = data['layers'][x]['dimensions']
            except:
                print("time dimensions for layer not found")
                timeDimension = ""
            className = data['layers'][x]['className']
            visibility = data['layers'][x]['visibility']            
            if className == 'XYZ':
                layerName = data['layers'][x]['title']
                self.layerServices[layerName] = 'XYZ'
            if className == 'HSLayers.Layer.WMS':
                layerName = data['layers'][x]['params']['LAYERS']
                self.layerServices[layerName] = 'HSLayers.Layer.WMS'

            if className == 'OpenLayers.Layer.Vector' or className == 'Vector':                
                try:
                    layerName = data['layers'][x]['name']
                except:
                    try:
                        layerName = data['layers'][x]['protocol']['LAYERS']
                    except:
                        QgsMessageLog.logMessage("compositionSchemaError")
                        self.instance = None
                        self.current = None
                        return
                self.layerServices[layerName] = 'OpenLayers.Layer.Vector'
            try:
                print(layerName)
            except:
                self.readCompositionFailed.emit()
                print("wrong format of composition")
                return

            if self.checkLayerOnLayman(layerName):              

                if className == 'HSLayers.Layer.WMS':                 
                    layerName = data['layers'][x]['params']['LAYERS']
                    format = data['layers'][x]['params']['FORMAT']
                    epsg = 'EPSG:4326'
                    minRes = data['layers'][x]['minResolution']
                    maxRes = data['layers'][x]['maxResolution']    
                    if "greyscale" in data['layers'][x]:
                        greyscale = data['layers'][x]['greyscale']
                    else:
                        greyscale = False

                    try:
                        groupName = data['layers'][x]['path']
                    except:
                        groupName = ""
                    wmsName = data['layers'][x]['params']['LAYERS']
                    layerNameTitle = data['layers'][x]['title']
                    repairUrl = data['layers'][x]['url']
                    repairUrl = self.convertUrlFromHex(repairUrl)                    
                    everyone = False
                    try:                        
                        workspace =  repairUrl.split("geoserver/")[1].split("_wms")[0]
                        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                        r = self.requestWrapper("GET", url, payload = None, files = None)
                        if 'EVERYONE' in r.json()['access_rights']['read']:
                            everyone = True
                        if 'time' in r.json()['wms']:       
                            timeDimension = r.json()['wms']                    
                    except:
                        print("permissions not found")

                    if groupName != "":
                        groups.append([groupName, len(data['layers']) - i])
                        groupsSet.add(groupName)
                        groupPositions.append([groupName, layerNameTitle, len(data['layers']) -i])
                    else:
                        groups.append([layerNameTitle, len(data['layers']) - i]) 
                    legends = "0"                        
                    if "legends" in data['layers'][x]:
                        legends = "1"   
                    #threads.append(threading.Thread(target=lambda: self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName, subgroupName, timeDimension, visibility, everyone,minRes, maxRes, greyscale, legends)).start())                   
                    self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName, subgroupName, timeDimension, visibility, everyone,minRes, maxRes, greyscale, legends)                  
                if className == 'ArcGISRest':
                   
                    url = data['layers'][x]['url']
                    layerNameTitle = data['layers'][x]['title']
                    #threads.append(threading.Thread(target=lambda: self.loadArcGisRest(url, layerNameTitle)).start())
                    self.loadArcGisRest(url, layerNameTitle)
                    
                if className == 'XYZ':                   
                    layerName = data['layers'][x]['title']
                    minRes = data['layers'][x]['minResolution']
                    maxRes = data['layers'][x]['maxResolution']                  
                    try:
                        groupName = data['layers'][x]['path']
                    except:
                        groupName = ""             
                    format = "XYZ"
                    epsg = 'EPSG:4326'
                    layerNameTitle = data['layers'][x]['title']
                    repairUrl = data['layers'][x]['url']
                    repairUrl = self.convertUrlFromHex(repairUrl)
                    if groupName != "":
                        groups.append([groupName, len(data['layers']) -i])
                        groupsSet.add(groupName)
                        groupPositions.append([groupName, layerNameTitle, len(data['layers']) -i])
                    else:
                        groups.append([layerNameTitle, len(data['layers']) - i])
                    #threads.append(threading.Thread(target=lambda: self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName, subgroupName, visibility,-1,minRes, maxRes)).start())
                    self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName, subgroupName, visibility,-1,minRes, maxRes)
                  

                if className == 'OpenLayers.Layer.Vector' or className == 'Vector':
                    epsg = 'EPSG:4326'
                    minRes = data['layers'][x]['minResolution']
                    maxRes = data['layers'][x]['maxResolution']                   
                    layerNameTitle = data['layers'][x]['title']
                    repairUrl = data['layers'][x]['protocol']['url']
                    repairUrl = self.convertUrlFromHex(repairUrl)
                    subgroupName = ""
                    everyone = False               
                 
                    if "path" in  data['layers'][x]:
                        groupName = data['layers'][x]['path']
                    else:
                        groupName = ""
                    if groupName != "":
                        groups.append([groupName, len(data['layers']) -i])
                        groupsSet.add(groupName)
                        groupPositions.append([groupName, layerNameTitle, len(data['layers']) -i])
                    else:
                        groups.append([layerNameTitle, len(data['layers']) - i])
                    try: ## nove rozdeleni
                       
                        if 'type' in data['layers'][x]['protocol']: ## old
                            if (data['layers'][x]['protocol']['type'] == "hs.format.WFS" or data['layers'][x]['protocol']['type'] == "hs.format.externalWFS"):
                                if 'workspace' in data:                                    
                                    #repairUrl = repairUrl.replace("hsl-layman", "geoserver") + data['workspace'] + "wfs"
                                    repairUrl = repairUrl.replace("hsl-layman", "") + data['workspace'] + "wfs"


                                #threads.append(threading.Thread(target=lambda: self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility,everyone, minRes, maxRes)).start())
                                self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility,everyone, minRes, maxRes)
                                
                        if "format" in data['layers'][x]['protocol']:    
                            if (data['layers'][x]['protocol']['format'] == "hs.format.externalWFS"):                            
                                #threads.append(threading.Thread(target=lambda: self.loadWfsExternal(data['layers'][x],epsg, groupName)).start())
                                self.loadWfsExternal(data['layers'][x],epsg, groupName)
                            if (data['layers'][x]['protocol']['format'] == "hs.format.WFS"):
                                if 'workspace' in data['layers'][x]:                                    
                                    repairUrl = repairUrl.replace("hsl-layman", "")


                                #threads.append(threading.Thread(target=lambda: self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility,everyone, minRes, maxRes)).start())
                                self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility,everyone, minRes, maxRes)
                   
                    except:                        
                        #threads.append(threading.Thread(target=lambda: self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility,everyone, minRes, maxRes)).start())                        
                        self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility,everyone, minRes, maxRes)                      

                
            else:
                self.wrongLayers = True              
            i = i + 1
        # threadsB = set()
        # while (self.ThreadsA != threadsB):
        #     threadsB = set()
        #     for thread in threading.enumerate():
        #         threadsB.add(thread.name) 
        #self.reoderComposition.emit(groups, groupsSet, groupPositions)
        
        self.reorderGroups(groups, groupsSet, groupPositions)
        self.afterCompositionLoaded()
        #self.afterLoadedComposition.emit()

    
    def Title(self, layerName):
        layerName = self.removeUnacceptableChars(layerName)
        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layerName      
        r = self.requestWrapper("GET", url, payload = None, files = None)
        data = r.json()

        title = data['title']

        return title
    def parseWMSlayers(self, layerString):
        ### ocekavany string je ve formatu pole napr [vrstva1,vrstva2,...]
        if (layerString[0] == "[" and layerString[-1:] == "]"):
            s = layerString.replace("[","").replace("]","").split(",")
            res = ""
            for i in range(0, len(s)):

                if (i == 0):
                    res = res+ s[i].replace(" ", "") + "&layers="
                elif (i == len(s)-1):
                    res = res+ s[i].replace(" ", "")
                else:
                    res = res+ s[i].replace(" ", "") + "&layers="


            for i in range(0, len(s)-1):
                res = res + "&styles"
            #return res.replace("_","")
            return res
        else:
            return layerString
    def loadArcGisRest(self, url, layerName,  groupName = '', subgroupName = '', timeDimension='', visibility='', everyone=False, minRes= None, maxRes=0, greyscale = False):        
        r = requests.get(url + "?f=json")
        #r = self.requestWrapper("GET", url + "?f=json", payload = None, files = None)
        print(r.content)
        res = json.loads(r.content)
        id = 0
        for layer in res['layers']:
            if layer['name'] == layerName:
                id = layer['id']    
        rlayer = QgsRasterLayer("url="+url+" layer='"+str(id)+"'", layerName, "arcgismapserver")          
        print(rlayer.isValid())
        if (rlayer.isValid()):
            if minRes != None and maxRes != None:
                rlayer.setMinimumScale(self.resolutionToScale(maxRes))
                rlayer.setMaximumScale(self.resolutionToScale(minRes))
                rlayer.setScaleBasedVisibility(True)
            if (groupName != '' or subgroupName != ''):            
                self.addWmsToGroup(subgroupName,rlayer, "")
                              
            else:
                self.params = []
                self.params.append(visibility)              
                rand = random.randint(0,10000)
                self.currentLayerDict[str(rand)] = rlayer

                self.loadLayer(rlayer)   
                self.setVisibility.emit(rlayer)   
            
            if greyscale:
                rlayer.pipe().hueSaturationFilter().setGrayscaleMode(1)
            return True
        else:
            rand = random.randint(0,10000)
            self.currentLayerDict[str(rand)] = rlayer
            self.loadLayer(rlayer)          
            return False
        QgsProject.instance().addMapLayer(layer)

    def loadWms(self, url, layerName,layerNameTitle, format, epsg, groupName = '', subgroupName = '', timeDimension='', visibility='', everyone=False, minRes= None, maxRes=0, greyscale = False, legend="0"):               
        layerName = self.parseWMSlayers(layerName) 
        epsg = QgsProject.instance().crs().authid()
        url = url.replace("%2F", "/").replace("%3A",":")
        urlWithParams = 'contextualWMSLegend='+legend+'&crs='+epsg+'&IgnoreReportedLayerExtents=1&dpiMode=7&featureCount=10&format=image/png&layers='+layerName+'&styles=&url=' + url            
        quri = QgsDataSourceUri()
        try:  
            if timeDimension != {}:  
                if 'values' in timeDimension['time']:           
                    print("wmst")             
                    quri.setParam("type", "wmst")
                      #quri.setParam("timeDimensionExtent", "1995-01-01/2021-12-31/PT5M")                        
                    quri.setParam("timeDimensionExtent", str(timeDimension['time']['values']))
                    quri.setParam("allowTemporalUpdates", "true")
                    quri.setParam("temporalSource", "provider")
                            
                else:
                    quri.setParam("type", "wmst")
                    quri.setParam("timeDimensionExtent", self.readDimFromCapatibilites(url, layerName))
                    quri.setParam("allowTemporalUpdates", "true")
                    quri.setParam("temporalSource", "provider")            
        except Exception as e:
            print(e)
            print("error with time wms")
        quri.setParam("layers", layerName.replace("'", ""))
        quri.setParam("styles", '')
        quri.setParam("format", 'image/png')  
        quri.setParam("crs", epsg)
        quri.setParam("dpiMode", '7')
        quri.setParam("featureCount", '10')  
        quri.setParam("IgnoreReportedLayerExtents", '1')   
        if (self.isAuthorized):
            if not everyone:
                quri.setParam("authcfg", self.authCfg)   # <---- here my authCfg url parameter
        quri.setParam("contextualWMSLegend", legend)
        quri.setParam("url", url)        
        rlayer = QgsRasterLayer(str(quri.encodedUri(), "utf-8").replace("%26","&").replace("%3D","="), layerNameTitle, 'wms')       
        
    
        
        if minRes != None and maxRes != None:
            rlayer.setMinimumScale(self.resolutionToScale(maxRes))
            rlayer.setMaximumScale(self.resolutionToScale(minRes))
            rlayer.setScaleBasedVisibility(True)
        if (groupName != '' or subgroupName != ''):                        
            self.addWmsToGroup(subgroupName,rlayer, "") ## vymena zrusena groupa v nazvu kompozice, nyni se nacita pouze vrstva s parametrem path            
                              
        else:             
            self.loadLayer(rlayer)  
            self.setVisibility.emit(rlayer)              
        if greyscale:
            rlayer.pipe().hueSaturationFilter().setGrayscaleMode(1)
        return True

    def loadXYZ(self, url, layerName,layerNameTitle, format, epsg, groupName = '', subgroupName= '', visibility= '', i = -1, minRes= 0, maxRes=None):


        layerName = self.removeUnacceptableChars(layerName)
        print("XYZ")

        epsg = "EPSG:4326"
        url = url.replace("%2F", "/").replace("%3A",":")



        rlayer = QgsRasterLayer("type=xyz&url="+url, layerNameTitle, "wms")
        print("xyz valid? " + str(rlayer.isValid()))
        try:
            print("extents")            
        except:
            print("ignoreExtents works only with qgis 3.10 and higher")
            pass # pro qgis 3.10 a vys
        if (rlayer.isValid()):
            if minRes != None and maxRes != None:
                rlayer.setMinimumScale(self.resolutionToScale(maxRes))
                rlayer.setMaximumScale(self.resolutionToScale(minRes))
                rlayer.setScaleBasedVisibility(True)
            if (groupName != ''):

                self.addWmsToGroup(subgroupName,rlayer, "")            


            else:
                self.params = []
                self.params.append(visibility)              
                rand = random.randint(0,10000)
                self.currentLayerDict[str(rand)] = rlayer

                self.loadLayer(rlayer)   
                self.setVisibility.emit(rlayer)                     
            if visibility == False:
                QgsProject.instance().layerTreeRoot().findLayer(rlayer.id()).setItemVisibilityChecked(False)
            return True
        else:
            return False

    def loadLayer(self, layer, style = None):
        QgsProject.instance().addMapLayer(layer)

        if (isinstance(layer, QgsVectorLayer)):
            if style is None:
                self.loadStyle.emit(layer)
            else:                
                style = self.getStyle(layer.name(), style)                    
                layerName = layer.name()
                if (style[0] == 200):
                    if (style[1] == "sld"):
                        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                        layer.loadSldStyle(tempf)
                        layer.triggerRepaint()
                    if (style[1] == "qml"):
                        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
                        layer.loadNamedStyle(tempf)
                        layer.triggerRepaint()
    def _setVisibility(self, layer):                    
        try:
            visibility = self.instance.getVisibilityForLayer(layer.name())
            QgsProject.instance().layerTreeRoot().findLayer(layer).setItemVisibilityChecked(visibility)
        except:
            print("missing visibility parameter")
            QgsProject.instance().layerTreeRoot().findLayer(layer).setItemVisibilityChecked(True)                    
    def loadWfsExternal(self, layer, epsg, groupName):       
        layer_name = layer["name"]
        minRes = layer['minResolution']
        maxRes = layer['maxResolution']  
        if "style" in layer:
            style = layer['style']
        else:
            style = None    
        wfs_url = layer["protocol"]["url"]+"?service=WFS&version=auto&request=GetFeature&typeName="+layer["name"]+"&SRSNAME=" + epsg                   
        layer = QgsVectorLayer(wfs_url, layer['title'], 'WFS')
        print(layer.isValid())
        
        
        if (layer.isValid()):         
            if minRes != None and maxRes != None:
                print("set scale")
                layer.setMinimumScale(self.resolutionToScale(maxRes))
                layer.setMaximumScale(self.resolutionToScale(minRes))
                layer.setScaleBasedVisibility(True)
                print(layer.hasScaleBasedVisibility())
        if (groupName != ''):                    
            self.addWmsToGroup(groupName,layer,"")      
            self.saveExternalStyle(style, layer_name)
            tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layer_name)+ ".sld"
            layer.loadSldStyle(tempf)
            layer.triggerRepaint()  
        else:
            self.loadLayer(layer, style)                     
    def loadWfs(self, url, layerName,layerNameTitle, groupName = '', subgroupName = '', visibility= '', everyone=False, minRes= 0, maxRes=None):                    
        layerName = self.removeUnacceptableChars(layerName)        
        epsg = iface.mapCanvas().mapSettings().destinationCrs().authid()       
        uri = self.URI+"/geoserver/"+self.laymanUsername+"/ows?srsname="+epsg+"&typename="+self.laymanUsername+":"+layerName+"&restrictToRequestBBOX=1&pagingEnabled=True&version=auto&request=GetFeature&service=WFS"
        url = url.replace("%2F", "/").replace("%3A",":").replace("/client","")
        r = url.split("/")
        acc = (r[len(r)-2])
        quri = QgsDataSourceUri()
        quri.setParam("srsname", epsg)
        quri.setParam("typename", acc+":"+layerName)
        quri.setParam("restrictToRequestBBOX", "1")
        quri.setParam("pagingEnabled", "true")
        quri.setParam("version", "auto")
        quri.setParam("request", "GetFeature")
        quri.setParam("service", "WFS")
        if (self.isAuthorized):
            print("add authcfg")
            if not everyone:
                quri.setParam("authcfg", self.authCfg)
        quri.setParam("url", url)
        vlayer = QgsVectorLayer(url+"?" + str(quri.encodedUri(), "utf-8"), layerNameTitle, "WFS")
        print("validity WFS")
        print(vlayer.isValid())
       
            
        if (vlayer.isValid()):         
            if minRes != None and maxRes != None:
                print("set scale")
                vlayer.setMinimumScale(self.resolutionToScale(maxRes))
                vlayer.setMaximumScale(self.resolutionToScale(minRes))
                vlayer.setScaleBasedVisibility(True)
                print(vlayer.hasScaleBasedVisibility())            

            
            if (self.getTypesOfGeom(vlayer) < 2):     
                if (groupName != ''):                    
                    self.addWmsToGroup(groupName,vlayer, subgroupName)

                    self.currentLayer.append(vlayer)                    
                    self.loadStyle.emit(vlayer)
                else:                 
                    self.currentLayer.append(vlayer)
                    rand = random.randint(0,10000)
                    self.currentLayerDict[str(rand)] = vlayer     
                    self.loadLayer(vlayer)    
                    self.setVisibility.emit(vlayer)                       
                    
     
            else: ### cast pro slozenou geometrii
                self.mixedLayers.append(layerName)
                pointFeats = list()
                polyFeats = list()
                lineFeats = list()
                feats = vlayer.getFeatures()       

                pol = 0
                line = 0
                point = 0
                for feat in feats:          
                    if (feat.geometry().type() == 0):
                        pointFeats.append(feat)
                        point = 1

                    if (feat.geometry().type() == 2):
                        polyFeats.append(feat)
                        pol = 1
                    if (feat.geometry().type() == 1):
                        lineFeats.append(feat)
                        line =  1
                if (point == 1):
                    vl = QgsVectorLayer("Point?crs="+epsg, layerName, "memory")
                    pr = vl.dataProvider()
                    pr.addFeatures(pointFeats)
                    vl.updateFields()
                    vl.updateExtents()
                    vl.commitChanges()
                    vl.nameChanged.connect(self.forbidRename)
                    if (groupName != ''):          
                        self.addWmsToGroup(groupName,vl, "")

                    else:
                        self.addLayerToGroup(layerName,vl)                   
                if (line == 1):
                    vl = QgsVectorLayer("LineString?crs="+epsg, layerName, "memory")
                    pr = vl.dataProvider()
                    pr.addFeatures(lineFeats)
                    vl.updateFields()
                    vl.updateExtents()
                    vl.commitChanges()
                    vl.nameChanged.connect(self.forbidRename)
                    if (groupName != ''):
                        self.addWmsToGroup(groupName,vl, True)
                    else:
                        self.addLayerToGroup(layerName,vl)

                if (pol == 1):
                    vl = QgsVectorLayer("Polygon?crs="+epsg, layerName, "memory")
                    pr = vl.dataProvider()
                    pr.addFeatures(polyFeats)
                    vl.updateExtents()
                    vl.updateFields()
                    vl.commitChanges()
                    vl.nameChanged.connect(self.forbidRename)
                    if (groupName != ''):
                        self.addWmsToGroup(groupName,vl, True)
                    else:
                        self.addLayerToGroup(layerName,vl)

            
            return True
        else:
            self.loadLayer(vlayer) 
            #QgsProject.instance().addMapLayer(vlayer)
            return False
          
    def forbidRename(self):
        if ((int(round(time.time() * 1000)) - self.millis)  > 3000):
            self.millis = int(round(time.time() * 1000))

            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva s kombinovanou geometií nemůže být přejmenována.")
            else:
                QMessageBox.information(None, "Layman", "Layer with mixed geometry can´t be renamed.")
 



    def getTypesOfGeom(self, vlayer):
        feats = vlayer.getFeatures()

        typesL = 0
        typesP = 0
        typesPol = 0
        for feat in feats:
            if (typesL == 0):
                if (feat.geometry().type() == 0):
                    typesL = 1
            if (typesP == 0):
                if (feat.geometry().type() == 2):
                    typesP = 1
            if (typesPol == 0):
                if (feat.geometry().type() == 1):
                    typesPol = 1
            if typesL+typesP+typesPol > 2:
                return typesL+typesP+typesPol
        return typesL+typesP+typesPol

    def addWmsToGroup(self, groupName, layer, subgroupName="", i = 1000):        
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(groupName)
        if groupName == "":
            QgsProject.instance().addMapLayer(layer,False)
            return
        if not(group):
            group = root.addGroup(groupName)    
        if subgroupName == "":
            QgsProject.instance().addMapLayer(layer,False)
            group.insertChildNode(1,QgsLayerTreeLayer(layer))
        else:
            subgroup = group.addGroup(subgroupName)
            subgroup.insertChildNode(1,QgsLayerTreeLayer(layer))
        visibility = self.instance.getVisibilityForLayer(layer.name())
        try:
            QgsProject.instance().layerTreeRoot().findLayer(layer).setItemVisibilityChecked(visibility)
        except:
            print("missing visibility parameter")
            QgsProject.instance().layerTreeRoot().findLayer(layer).setItemVisibilityChecked(True)
       
              
    def addLayerToGroup(self, groupName, layer):
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(groupName)
        if not(group):
            group = root.addGroup(groupName)     
        time.sleep(1)
        QgsProject.instance().addMapLayer(layer,False)
        group.insertChildNode(1000,QgsLayerTreeLayer(layer))
    def reorderToTop(self, name,groupsSet, groupsPositions, i= 1000):        
        _ch = ""
        root = QgsProject.instance().layerTreeRoot()
        for ch in root.children():
            if ch.name() == name:
                _ch = ch.clone()
                root.insertChildNode(i, _ch)
                root.removeChildNode(ch)

        return _ch
    def reorderGroup(self, groupsPositions, groupsSet):
        for group_name in groupsSet:
            root = QgsProject.instance().layerTreeRoot()
            new_order = list()
            for g in groupsPositions:
                new_order.append(g[1])
            # Find the group you want to reorder
            
            
            for cha in root.children():
                i = 0
                for name in new_order:
                    i = i + 1
                    print(name)
                    for ch in cha.children():  
                            
                        if ch.name() == name:
                            _ch = ch.clone()
                            cha.insertChildNode(i, _ch)
                            cha.removeChildNode(ch)

   
    def convertUrlFromHex(self, url):
        url = url.replace('%3A',':')
        url = url.replace('%2F','/')
        url = url.replace('%3F','?')
        url = url.replace('%3D','=')
        url = url.replace('%26','&')
        return url

    def checkEpsg(self, name):
        ret = False
        layer = QgsProject.instance().mapLayersByName(name)
        layerCRS = layer[0].crs().authid()
        if ((layerCRS == 'EPSG:4326') or (layerCRS == 'EPSG:3857')):
            ret = True
        return ret

    def registerLayer(self, title):        
        url = self.URI + "/rest/"+self.laymanUsername+"/layers"
        name = self.removeUnacceptableChars(title)
        geoPath = self.getTempPath(name).lower()
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0") and qgis.core.Qgis.QGIS_VERSION_INT <= 32603:
            stylePath = self.getTempPath(name).replace("geojson", "qml").lower()
        else:
            stylePath = self.getTempPath(name).replace("geojson", "sld")
        files = {'style': (stylePath, open(stylePath, 'rb')),} # nahrávám sld
        payload = {
            'file': name.lower()+".geojson",
            'title': title
            }
        
        response = self.requestWrapper("POST", url, payload, files)

    def writeState(self,value):
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt"
        if os.path.exists(path) == False:
            open(path, "w").close
        file = open(path, 'w+')
        file.write(str(value))
        file.close()
    def notifySuccess(self):
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Export:", " Vrstva "+str(self.importedLayer)+" byla úspěšně exportována."), Qgis.Success, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Export:", " Layer "+str(self.importedLayer)+" was exported successfully."), Qgis.Success, duration=3)

    def read_in_chunks(self, file_object): ## cca 1MB chunk převzato z laymana test klienta
        chunk_size=self.CHUNK_SIZE
        while True:
            data = file_object.read(chunk_size)
            if not data:
                break
            yield data

    def postInChunks(self, layer_name, reqType):
        if (reqType == "patch"):      
            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+self.removeUnacceptableChars(layer_name)
            #r = requests.delete(url,headers = self.getAuthHeader(self.authCfg))
            r = self.requestWrapper("DELETE", url, payload = None, files = None)


        self.registerLayer(layer_name)
        layer_name = self.removeUnacceptableChars(layer_name)
        filePath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) ## chunky se ukládají do adresáře v tempu
        print("chunk layer")
        if not (os.path.exists(filePath)):
            os.mkdir(filePath)
        file = self.getTempPath(layer_name)
        f = open(file, 'rb')
        arr = []
        for piece in self.read_in_chunks(f):
            arr.append(piece)    

        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layer_name+'/chunk'

        resumableFilename = layer_name+'.geojson'
        layman_original_parameter = "file"
        resumableTotalChunks = len(arr)
        #print ("resumable" + resumableFilename)
       
        for i in range (1, len(arr)+1):  ##chunky jsou počítané od 1 proto +1
                
            file = arr[i-1] # rozsekaná část souboru
            resumableChunkNumber = i  # cislo casti
            payload = {
            'file' : "chunk"+str(i)+".geojson",
            'resumableFilename': resumableFilename,
            'layman_original_parameter': layman_original_parameter,
            'resumableChunkNumber': i,
            'resumableTotalChunks': resumableTotalChunks
            }

            f = open(filePath + os.sep+"chunk"+str(i)+".geojson", "wb")
            f.write(bytearray(arr[i-1]))
            f.close()
            files = {'file': (layer_name.lower().replace(" ", "_")+".geojson", open(filePath +os.sep+ "chunk"+str(i)+".geojson", 'rb')),}   
            response = self.requestWrapper("POST", url, payload, files)              


    def authOptained(self):
        try:
            self.dlg.pushButton_Continue.setEnabled(True)
            self.dlg.pushButton_Connect.setEnabled(False)
        except:
            pass

        self.menu_Connection.setEnabled(True)
        self.menu_saveLocalFile.setEnabled(False)
        self.menu_loadJson.setEnabled(True)
        self.menu_ImportLayerDialog.setEnabled(True)
        self.menu_AddMickaDialog.setEnabled(True)
        self.menu_AddLayerDialog.setEnabled(True)
        self.menu_AddMapDialog.setEnabled(True)
        self.menu_ImportLayerDialog.setEnabled(True)
        self.menu_UserInfoDialog.setEnabled(True)
        self.menu_CurrentCompositionDialog.setEnabled(True)

    def getAuthHeader(self, authCfg):        
        if self.isAuthorized:
            config = QgsAuthMethodConfig()            
            url = QUrl(self.URI+ "/rest/current-user")
            xx = QNetworkRequest(url)   
            i = 0
            success = (QgsApplication.authManager().updateNetworkRequest(xx, authCfg))      
            if success[0] == True:
                header = (xx.rawHeader(QByteArray(b"Authorization")))                
                authHeader ={
                  "Authorization": str(header, 'utf-8')
                }
                return authHeader
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Message", "Autorizace nebyla úspěšná! Prosím zkuste to znovu.")
                else:
                    QMessageBox.information(None, "Message", "Autorization was not sucessfull! Please try it again.")
                return False
        else:
            return ""

    def getCodeVerifier(self):
        code_verifier = base64.urlsafe_b64encode(os.urandom(40)).decode('utf-8')
        code_verifier = re.sub('[^a-zA-Z0-9]+', '', code_verifier)
        self.code_verifier = code_verifier
        return (code_verifier)

    def getCodeChallenge(self, code_verifier):
        code_challenge = hashlib.sha256(code_verifier.encode('utf-8')).digest()
        code_challenge = base64.urlsafe_b64encode(code_challenge).decode('utf-8')
        code_challenge = code_challenge.replace('=', '')
        self.code_challenge = code_challenge
        return (code_challenge)

    

    def getAuthCode(self):
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt"
        f = open(path, "r")
        ret =  f.read()
        f.close()
        return ret

    
    def setAuthHeader(self):
        self.authHeader ={
          "Authorization": "Bearer " + self.access_token,
          "AuthorizationIssUrl" : self.liferayServer+'/o/oauth2/authorize'
        }

    def beforeAmp(self, s):
        ret = ""       
        for i in (s):
            if i == "@":
                break
            ret = ret + i
        
        return ret
    def strip_accents(self, s):
        text = ''.join(c for c in unicodedata.normalize('NFD', s) if unicodedata.category(c) != 'Mn')
        return text.lower().replace(" ","").replace("_","")
    def registerUserIfNotExists(self):
        
        userEndpoint = self.URI+ "/rest/current-user" 
        login = self.beforeAmp(self.Agrimail)        
        id = self.client_id.replace('-', '')
        login = login.replace(".","_")
        self.laymanUsername = login
        user = {'username':login}      
        print("authheader: "+ str(self.getAuthHeader(self.authCfg)))

        r = requests.patch(url = userEndpoint, data = user, headers = self.getAuthHeader(self.authCfg))
        #r = self.requestWrapper("PATCH", userEndpoint, user, files = None)
        res = r.text
        try:
            res = self.fromByteToJson(r.content)
            print (res)
            print(user)
            print(res)
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Layman server neodpověděl!")
            else:
                QMessageBox.information(None, "Error", "Layman server not respond!")
            self.disableEnvironment()
            return
        if res is None:
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Layman server neodpověděl!")
            else:
                QMessageBox.information(None, "Error", "Layman server not respond!")            
            self.logout()
            return               
        if 'code' in res:
           # if res['message'] == 'User already reserved username.': # res['code'] == 34, code 35 je pokud již jiný uživatel má účet, který chceme registrovat
           if res['code'] == 34: # res['code'] == 34, code 35 je pokud již jiný uživatel má účet, který chceme registrovat (code 35 pravděpodobně nemůže nastat)

                print("user exists")

                self.laymanUsername = res['detail']['username']
                print("username is: " + self.laymanUsername )
                url = self.liferayServer.replace('https:\\','').replace('.cz','').replace('http:\\','').replace('www.','').replace('.com','')               
                self.setPluginLabel.emit('<a href="'+self.liferayServer+'">' + url + '</a>')
                    
                
           if res['code'] == 32:
                self.disableEnvironment()
                if self.locale == "cs":
                    QMessageBox.information(None, "Error", "Oauth2 autorizace nebyla úspěšná!")
                else:
                    QMessageBox.information(None, "Error", "Oauth2 authorization was not successfull!")
                self.textbox.setText("Layman")
                return False
        else:          
            try:
                print("creating new user: " + res['username'])
                self.laymanUsername =  res['username']
                url = self.liferayServer.replace('https:\\','')
                self.textbox.setText('<a href="'+self.liferayServer+'">' + url + '</a>')                
            except Exception as ex:
                print(ex)
                print("Komunikace s Liferay nefunguje")

                if self.locale == "cs":
                    QMessageBox.information(None, "Error", "Komunikaci se serverem nelze navázat!")
                else:
                    QMessageBox.information(None, "Error", "Communication with the server cannot be established!")               
                self.logout()
                return False
        return True
    def onSetPluginLabel(self,string):
        self.textbox.setOpenExternalLinks(True)
        self.textbox.setText(string)        
   
    def getUserName(self):
        userEndpoint = self.URI+ "/rest/current-user"  
        r = self.requestWrapper("GET", userEndpoint, payload = None, files = None)
        res = self.fromByteToJson(r.content)      

        return res['username']
    def connectionLost(self):
        print("connection lost")
        self.disableEnvironment()   
        self.textbox.setText("Layman")
        ## flush variables
       
        self.menu_UserInfoDialog.setEnabled(True)
        self.laymanUsername = ""
        self.isAuthorized = False
        proj = QgsProject.instance()
        server, type_conversion_ok = proj.readEntry("Layman", "Server","")
        if server == "":
            self.current = None
        self.liferayServer = None
        self.compositeList = []
       
    def openAuthLiferayUrl2(self, load="", autoLog = False): 
        
        if hasattr(self, 'dlg'):            
            if isinstance(self.dlg, ConnectionManagerDialog):
                self.rememberLastServer(self.dlg.comboBox_server.currentIndex())
                self.dlg.pushButton_Connect.setEnabled(False)
        self.isAuthorized = True
        authcfg_id = self.authCfg     
        print(self.setup_oauth(authcfg_id, self.liferayServer))        
        authHeader = self.getAuthHeader(self.authCfg)        
        print(authHeader)
        if (authHeader):
            if self.registerUserIfNotExists():   
                if not autoLog:
                    self.saveIni()
                try:    
                    self.name = self.getUserName()
                except:
                    if self.locale == "cs":
                        QMessageBox.information(None, "Message", "Autorizace nebyla úspěšná!")
                    else:
                        QMessageBox.information(None, "Message", "Autorization was not sucessfull!")                    
                url = self.URI+ "/rest/about/version"
                print(url)              
                r = self.requestWrapper("GET", url, payload = None, files = None)                
                try:
                    res = self.fromByteToJson(r.content)
                    print(res['about']['applications']['layman']['version'])
                    self.laymanVersion = res['about']['applications']['layman']['version']
                except:
                    self.laymanVersion = "0.0.0"
          
                ## check for new version

                versionCheck = self.checkVersion()
                if versionCheck[0] == False:
                    if self.locale == "cs":
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Nová verze pluginu Layman k dispozici."), Qgis.Success, duration=15)
                    else:
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "New version of Layman plugin available."), Qgis.Success, duration=15)

                ##

                self.authHeader = authHeader
                self.authOptained()     
                if hasattr(self, 'dlg'): 
                    if isinstance(self.dlg, ConnectionManagerDialog):     
                        self.dlg.pushButton_logout.setEnabled(True)
                        self.dlg.pushButton_NoLogin.setEnabled(False)
                        self.dlg.pushButton_Connect.setEnabled(False)
                        self.dlg.close()                
                if load != "":
                    print("loading current")
                    url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+load+'/file'                
                    r = self.requestWrapper("GET", url, payload = None, files = None)
                    data = r.json()                    
                    self.instance = CurrentComposition(self.URI, load, self.laymanUsername, self.getAuthHeader(self.authCfg),self.laymanUsername)
                    self.instance.setComposition(data)
                    self.current = load

                self.projectReaded(True)
                threading.Thread(target=lambda: self.fillCompositionDict()).start()
    def download_url(self, url, save_path, chunk_size=128):
        r = requests.get(url, stream=True)
        with open(save_path, 'wb') as fd:
            for chunk in r.iter_content(chunk_size=chunk_size):
                fd.write(chunk)
    def copytree(self, src, dst, symlinks=False, ignore=None):
        try:
            shutil.rmtree(dst)
            os.mkdir(dst)
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Plugin nebyl aktualizován!")
            else:
                QMessageBox.information(None, "Error", "Plugin was not updated!")
            return
        for item in os.listdir(src):

            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            if os.path.isdir(s):
                shutil.copytree(s, d, symlinks, ignore)
            else:
                shutil.copy2(s, d)
    def updatePlugin(self, version):
        if (len(version.split(".")) > 2):
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Aktualizace pluginu", "Tato verze pluginu není v QGIS repozitáři a může obsahovat nové netestované funkcionality. Chcete opravdu instalovat tuto verzi?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Plugin update", "This version of the plugin is not included in the QGIS repository and may contain new untested functionalities. Do you really want to install this version?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.No):
                return
        url = "https://gitlab.com/plan4all/layman-qgis-plugin/-/archive/master/layman-qgis-plugin-master.zip"
        if not self.checkQgisVersion():        
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Aktualizace pluginu", "Plugin vyžaduje verzi QGIS 3.26 a vyšší. Chcete přesto pokračovat?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Plugin update", "Plugin requires QGIS version 3.26 and higher. Do you still want to continue?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.No):
                return
        self.installPlugin(url)
    def installPlugin(self, url):
        save_path = tempfile.gettempdir() + os.sep + "layman.zip"
        self.download_url(url, save_path)

        with ZipFile(save_path, 'r') as zipObj:
           # Extract all the contents of zip file in different directory
           zipObj.extractall(tempfile.gettempdir())
        src = tempfile.gettempdir() + os.sep + "layman-qgis-plugin-master"

        self.copytree(src, self.plugin_dir)
        self.dlg.close()
        self.disableEnvironment()
        QMessageBox.information(None, "Layman", "Layman plugin was updated. Please restart QGIS.")
    def checkVersion(self):        
        r = requests.get("https://gitlab.com/plan4all/layman-qgis-plugin/-/raw/master/metadata.txt?inline=false")

        buf = io.StringIO(r.text)
        config = configparser.ConfigParser()
        config.read_file(buf)
        version = config.get('general', 'version')
        installedVersion = self.getVersion()

        if installedVersion == version:
            return [True, version]
        else:
            return [False, version]
    def appendIniItem(self, key, item):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep + 'layman_user.INI'
        config = configparser.RawConfigParser()
        config.read(file)
        config.set('DEFAULT',key,item)
        cfgfile = open(file,'w')
        config.write(cfgfile, space_around_delimiters=False)  # use flag in case case you need to avoid white space.
        cfgfile.close()
    def getConfigItem(self, key):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep + 'layman_user.INI'
        config = configparser.RawConfigParser()
        config.read(file)
        try:
            return config.get('DEFAULT', key)
        except configparser.NoOptionError:
            return None
    def saveIni(self):

        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep + 'layman_user.INI'
        dir = os.getenv("HOME") + os.sep + ".layman"
        if not (os.path.isdir(dir)):
            try:
                os.mkdir(dir)
            except OSError:
                print ("vytváření adresáře selhalo")       
        self.appendIniItem('login',self.Agrimail)
        self.appendIniItem('id',self.client_id)
        self.appendIniItem('server',self.liferayServer)
        self.appendIniItem('layman',self.URI)   
    def loadIni(self):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep +'layman_user.INI'
        config = configparser.ConfigParser()
        config.read(file)
        return config
    def checkQgisVersion(self):
        version = Qgis.QGIS_VERSION_INT
        major = version // 10000
        minor = (version // 100) % 100      
        if major > 3 or (major == 3 and minor >= 26):
            return True
        else:
            return False
    def _onSuccessTs(self):
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Časová wms úspěšně exportována."), Qgis.Success, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Time series WMS successfully exported."), Qgis.Success, duration=3)        
        if self.locale == "cs":
            self.dlg.label_progress.setText("Úspěšně exportováno: 1 / 1")
        else:
            self.dlg.label_progress.setText("Sucessfully exported: 1 / 1")            
        self.dlg.progressBar.hide()        
    def layerChanged(self):
        if (iface.activeLayer() != None and isinstance(iface.activeLayer(), QgsVectorLayer)):
            self.menu_saveLocalFile.setEnabled(True)
        else:
            self.menu_saveLocalFile.setEnabled(False)

    def requestWrapper(self, type, url, payload = None, files = None):    
        try:
            response = requests.request(type, url = url, headers=self.getAuthHeader(self.authCfg), data=payload, files=files)        
        except Exception as ex:   
            info = str(ex)            
            self.showErr.emit(["Připojení není k dispozici","Connection is not available"],info, str(info), Qgis.Warning, "")                
            return
        if response.status_code != 200:               
            self.showErr.emit(["Požadavek nebyl úspěšný", "Request was not successfull"], "code: " + str(response.status_code), str(response.content), Qgis.Warning, url)        
               
        return response
    def _onEmitMessageBox(self, message):    
        if self.locale == "cs":
            QMessageBox.information(None, "Layman", message[0])
        else:
            QMessageBox.information(None, "Layman", message[1])
    def showSuccess(self, msg):   
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", msg[0]), Qgis.Success, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", msg[1]), Qgis.Success, duration=3)       
    def showQgisBar(self, msg, type):   
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", msg[0]), type, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", msg[1]), type, duration=3)      
    def isLayerPostgres(self, layer):
        provider = layer.dataProvider()
        print(provider.name())
        if provider.name() == "postgres":
            return True
        else:
            return False    
    def find_substring(self, searchable_str, start_str, stop_str):
        start_index = searchable_str.find(start_str)  
        if start_index == -1:  #
            return None
        start_index += len(start_str)  
        end_index = searchable_str.find(stop_str, start_index)  
        if end_index == -1: 
            return None
        return searchable_str[start_index:end_index] 
    def preparePostgresUri(self, layer, username, password):
        uri = layer.dataProvider().dataSourceUri()
        dbname = self.find_substring(uri, "dbname='", "'")
        port = self.find_substring(uri, "port=", " ")
        schema = self.find_substring(uri, 'table="', '".')
        table = self.find_substring(uri, '"."', '"')
        geom = self.find_substring(uri, '(', ')')
        host = self.find_substring(uri, "host=", " ") 
        if ("localhost" in host or "127.0.0.1" in host):
            host = host.replace("localhost","host.docker.internal")
            host = host.replace("127.0.0.1","host.docker.internal")
            return ("postgresql://"+username+":"+password+"@"+host+":5432/"+dbname+"?schema="+schema+"&table="+table+"&geo_column="+geom)
        else:    
            return ("postgresql://"+username+":"+password+"@"+host+":"+port+"/"+dbname+"?schema="+schema+"&table="+table+"&geo_column="+geom)
    def postPostreLayer(self, layer, username, password):
        uri = self.preparePostgresUri(layer, username, password)
        print(uri)
        layer_name = layer.name()
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0") and qgis.core.Qgis.QGIS_VERSION_INT <= 32603:
            stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "qml")
            layer.saveNamedStyle(stylePath)
        else:
            stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "sld")
            layer.saveSldStyle(stylePath)
        payload = {                
                'external_table_uri': uri,
                'title': layer_name,                
                'style': open(stylePath, 'rb'),
                'name': self.removeUnacceptableChars(layer_name)
                }
        print(payload)
        files = {'style': open(stylePath, 'rb')}
      
        response = self.requestWrapper("POST", self.URI+'/rest/'+self.laymanUsername+'/layers', payload, files)
        status = response.status_code
        if status == 409:
            print("layer already exists")
            self.showQgisBar(["Vrsta "+layer_name+ " již existuje!","Layer "+layer_name+ " already exists!"], Qgis.Warning)  
        if status == 200:
            self.showQgisBar(["Vrsta "+layer_name+ " úspěšně uložena.","Layer "+layer_name+ " was successfully saved."], Qgis.Success)  
            self.dlg.label_progress.setText("Úspěšně exportováno: 1 / 1")                    
        print(status)
        self.dlgPostgres.close()
        layer.afterCommitChanges.connect(self.patchPostreLayer)
   
        
    def patchPostreLayer(self):  
        def patchPostreLayerThread():
            layer = iface.activeLayer()
            layer_name = layer.name()
            if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0") and qgis.core.Qgis.QGIS_VERSION_INT <= 32603:
                stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "qml")
                layer.saveNamedStyle(stylePath)
            else:
                stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "sld")
                layer.saveSldStyle(stylePath)
            payload = {
                    'title': layer_name,                
                    'style': open(stylePath, 'rb'),
                    'name': self.removeUnacceptableChars(layer_name)
                    }
            print(payload)
            files = {'style': open(stylePath, 'rb')}
            response = self.requestWrapper("PATCH", self.URI+'/rest/'+self.laymanUsername+'/layers/'+ self.removeUnacceptableChars(layer_name), payload, files)     
        threading.Thread(target=lambda: patchPostreLayerThread()).start()    
 
              
    def loadPostgisLayer(self, it):
        layerName = self.removeUnacceptableChars(it.text(0))
        
        workspace = it.text(1)
        url = self.URI+'/rest/'+workspace+'/layers/'+str(layerName).lower() 
        r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        data = r.json()
        print(data)
        table = data["db"]["table"]
        schema = data["db"]["schema"]
        geo_column = data["db"]["geo_column"]           
        address = self.find_substring(data["db"]["external_uri"], "@", "/" )
        host = address.split(":")[0]
        port = address.split(":")[1]
        user = self.find_substring(data["db"]["external_uri"], r"://", "@")
        srid = str(4326)
        dbname = data["db"]["external_uri"].split("/")[-1]
        table = '"'+ schema +'"."'+ table + '" (' + geo_column + ') '  
        
        if ("host.docker.internal" in host):
            host = host.replace("host.docker.internal","localhost")            
              
        uri = "dbname='"+dbname+"' host="+host+" port="+port+" user='"+user+"' table="+ table +" key='id' srid="+srid
        style = self.getStyle(layerName, None, workspace)
        print(style)
        layer = QgsVectorLayer(uri, it.text(0), 'postgres')  
        
        if not layer.isValid():
            self.showQgisBar(["Vrstva nebyla úspěšně načtena.","Layer was not successfully loaded."], Qgis.Warning)
            print("Layer failed to load!")  
        ## load style 
        if (style[0] == 200):
            if (style[1] == "sld"):
                tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                layer.loadSldStyle(tempf)
                   
            if (style[1] == "qml"):
                tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
                layer.loadNamedStyle(tempf)
        QgsProject.instance().addMapLayer(layer)     
        layer.afterCommitChanges.connect(self.patchPostreLayer)
    def on_postgis_found(self, found):    
        if self.dlg.objectName() == "AddLayerDialog":
            if found:
                self.dlg.pushButton_postgis.show()       
            else:
                self.dlg.pushButton_postgis.hide()    
    def showExportedCompositionInfo(self, info):
        if self.dlg.objectName() == "CurrentCompositionDialog":
            if info != "F":
                self.dlg.label_log.show()
                self.dlg.label_log.setText(info)
            else:
                self.dlg.label_log.hide()            
    def refreshWfsLayers(self):        
        project = QgsProject.instance()      
        layers = project.mapLayers().values()      
        for layer in layers:      
            if layer.type() == QgsMapLayerType.VectorLayer and layer.dataProvider().name() == 'WFS':              
                layer.dataProvider().reloadData()                                    
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True
            if self.dockwidget == None:               
                self.dockwidget = AtlasDockWidget()
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)
            self.dockwidget.pushButton.clicked.connect(self.sendLayer)
            self.dockwidget.pushButton_2.clicked.connect(self.loadLocalFile)
            self.dockwidget.pushButton_3.clicked.connect(self.saveLocalFile)
            self.dockwidget.pushButton_getLayers.clicked.connect(self.run_getLayer)
            self.dlgGetLayers.pushButtonxx.clicked.connect(lambda: print(self.dlgGetLayers.items.currentItem().text()))
            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.TopDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
