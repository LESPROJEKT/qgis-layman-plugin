 # -*- coding: utf-8 -*-
"""
/***************************************************************************
 Layman
                                 A QGIS plugin
 Layman
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-02-15
        git sha              : $Format:%H$
        copyright            : (C) 2019 by jan vrobel
        email                : vrobel.jan@seznam.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import json
import tempfile
import os
import threading
import io
import random
from PyQt5.QtCore import QSettings, QTranslator, qVersion, QCoreApplication, Qt, QFileSystemWatcher, QRegExp,QDir,QUrl, QByteArray , QTimer, QSize
from PyQt5.QtGui import QIcon, QPixmap, QRegExpValidator, QDoubleValidator, QBrush, QColor
from PyQt5.QtWidgets import QAction, QTreeWidget,QTreeWidgetItemIterator, QTreeWidgetItem, QMessageBox, QLabel, QProgressDialog, QDialog, QProgressBar,QListWidgetItem, QAbstractItemView,QComboBox
from PyQt5.QtNetwork import QNetworkRequest, QNetworkAccessManager
# Initialize Qt resources from file resources.py
from .resources import *
import re
from multiprocessing import Process
from pathlib import Path 
import processing
# Import the code for the DockWidget
from builtins import str
from builtins import range
from builtins import object
import json
import pandas as pd
import zipfile
from zipfile import ZipFile
import tempfile
import configparser
import shutil
import uuid
import csv
import copy
import ctypes, sys
import webbrowser
from .Layman_dockwidget import LaymanDockWidget
import os.path
import tempfile
import qgis.core
from qgis.core import *
import platform
import os
import qgis.utils
import qgis.gui
from qgis.gui import QgsMapCanvas
from qgis.core import QgsApplication
from qgis.utils import iface
import xml.etree.ElementTree as ET
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QMessageBox, QWidget, QInputDialog, QLineEdit, QFileDialog
import requests
import tempfile
import time
from urllib.request import urlopen
import subprocess
import threading
import hashlib
import html
import re
import base64
from distutils.version import LooseVersion, StrictVersion
import urllib.parse
from .ogr2ogr import main
## forms
from .dlg_GetLayers import GetLayersDialog
from .dlg_importMap import ImportMapDialog
from .dlg_deleteMap import DeleteMapDialog
from .dlg_importLayer import ImportLayerDialog
from .dlg_addLayer import AddLayerDialog
from .dlg_addMap import AddMapDialog
from .dlg_createComposite import CreateCompositeDialog
from .dlg_deleteLayerFromMap import DeleteLayerFromMapDialog
from .dlg_editMap import EditMapDialog
from .dlg_ConnectionManager import ConnectionManagerDialog
from .dlg_userInfo import UserInfoDialog
from .dlg_setPermission import SetPermissionDialog
from .dlg_currentComposition import CurrentCompositionDialog
from .dlg_layerDecision import LayerDecisionDialog
from .currentComposition import CurrentComposition



class Layman:
    """QGIS Plugin Implementation."""
    
    


    
       
    def __init__(self, iface):
        """Constructor.
        
        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
       
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__) 
        
        ## init global variables
        self.client_id = None
        self.filename = None
        self.layerName = None
        self.client_secret = None
        self.username = 'browser'
        self.EPSG = 'EPSG:3857'
        self.composite = None
        self.thread1 = None
        self.compositeList = []
        self.compositeListOld = []
        self.CHUNK_SIZE = 1048576 ## s touto hodnotou pracuje layman klient (cca 1MB soubor)
        #self.CHUNK_SIZE = 2098152 
        self.URI = None
        self.access_token = None
        self.expires_in = None
        self.refresh_token = None
        self.laymanUsername = ""
        self.authHeader = None
        self.code_verifier = None
        self.code_challenge = None
        self.wrongLayers = False
        self.Agrimail = ""
        self.loadedInMemory = False
        self.liferayServer = None
        self.laymanServer = None
        self.mapsChanged = set()
        self.authCfg =""
        self.authCfg = "957je05"
        self.importedLayer = None
        self.batchLength = 0
        self.focusedLayer = None
        self.modified = False
        self.stylesToUpdate = set()
        self.done = 0
        self.name = ""
        self.millis = 0
        self.version = "1.0.0"
        self.initFiles()
        self.layerServices = {}
        self.compositionDict = {}
        self.current = None
        self.changedLayer = set()
        self.project = QgsProject.instance()
        self.currentLayer = []
        self.currentLayerDict = {}
        self.laymanVersion = None
        self.run = False
        self.isAuthorized = True
        self.selectedWorkspace = None
        self.firstStart = True
        self.isItemChanged = False
        self.noOverrideLayers = list()
        self.processingRequest = False
        self.crsOld = 'EPSG:4326'
        self.mixedLayers = list()
        self.schemaURl= "https://raw.githubusercontent.com/hslayers/map-compositions/2.0.0/schema.json"
        self.schemaVersion = "2.0.0"
        self.DPI = self.getDPI()
        self.supportedEPSG = ['EPSG:4326', 'EPSG:3857', 'EPSG:5514', 'EPSG:102067', 'EPSG:32634', 'EPSG:32633', 'EPSG:3034', 'EPSG:3035', 'EPSG:305']
      #  self.uri = 'http://layman.lesprojekt.cz/rest/'
        self.iface.layerTreeView().currentLayerChanged.connect(lambda: self.layerChanged())
        
       # self.iface.layerTreeView().currentLayerChanged.connect(lambda: self.getActiveLayer())
        self.processingList = []
        self.writeState(0)
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt" 
        self.watcherState = QFileSystemWatcher()
        self.watcherState.addPath(path)
        #self.watcherState.fileChanged.connect(self.notifySuccess)
        #self.watcherState.fileChanged.connect(self.processingWorker)        
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt" 
        #self.watcher = QFileSystemWatcher()
        #self.watcher.addPath(path)
        #self.watcher.fileChanged.connect(self.authOptained)     
        self.dependencies = True
        self.recalculateDPI()
        if os.path.isfile(path):

            self.authFileTime =os.path.getmtime(path)
        #print(self.authFileTime)
        #print(os.path.getmtime(path))
        else:
            self.authFileTime = 0
     #   global dlgGetLayers 
        self.dlgGetLayers= GetLayersDialog()
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'Layman_{}.qm'.format(locale))
        self.locale = locale
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Layman')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'Layman')
        self.toolbar.setObjectName(u'Layman')
        QgsApplication.messageLog().messageReceived.connect(self.write_log_message)
        
        #print "** INITIALIZING Atlas"

        self.pluginIsActive = False
        self.dockwidget = None
        ## prepare temp dir
        tempDir = tempfile.gettempdir() + os.sep + "atlas" 
        try:
            os.mkdir(tempDir)
            print("Directory " , tempDir ,  " Created ") 
        except FileExistsError:
            print("Directory " , tempDir ,  " already exists")
        
    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('Layman', message)

    def rebuildLiferayCache(self):
        QgsApplication.authManager().rebuildCertTrustCache()
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        #icon_path = ':/plugins/Atlas/icon.png'
        #self.add_action(
        #    icon_path,
        #    text=self.tr(u''),
        #    callback=self.run,
        #    parent=self.iface.mainWindow())
        #self.first_start = True

        ################## user
        self.textbox = QLabel(self.iface.mainWindow())
        # Set width
        self.textbox.setFixedWidth(140)
        # Add textbox to toolbar
        self.txtAction = self.toolbar.addWidget(self.textbox)
        # Set tooltip
        self.txtAction.setToolTip(self.tr(u'Current Row Number'))
        # Set callback
        self.textbox.setText("Layman")

        ################ end usericon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'login.png'
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_1.svg'
        self.menu_Connection = self.add_action(
            icon_path,
            text=self.tr(u'Login'),
            callback=self.run_login,
            enabled_flag=True,
            parent=self.iface.mainWindow())


        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_2.svg'
        self.menu_saveLocalFile = self.add_action(
            icon_path,
            text=self.tr(u'Save as to JSON and SLD'),
            callback=self.saveLocalFile,
            enabled_flag=False,
            parent=self.iface.mainWindow())

        self.first_start = True
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'file.png'
        self.menu_loadJson = self.add_action(
            icon_path,
            text=self.tr(u'Load from JSON'),
            callback=self.loadLocalFile,
            enabled_flag=False,
            parent=self.iface.mainWindow())
        self.first_start = True

        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'layers-up.png'
        self.menu_ImportLayerDialog = self.add_action(
            icon_path,
            text=self.tr(u'Export layer to server'),
            callback=self.run_ImportLayerDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())  
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'layers-down.png'
        self.menu_AddLayerDialog = self.add_action(
            icon_path,
            text=self.tr(u'Load layer from server'),
            callback=self.run_AddLayerDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())        
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_3.svg'
        self.menu_AddMapDialog = self.add_action(
            icon_path,
            text=self.tr(u'Load map from server'),
            callback=self.run_AddMapDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow())   
        
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'map.png'
        self.menu_CurrentCompositionDialog = self.add_action(
            icon_path,
            text=self.tr(u'Current composition'),
            callback=self.run_CurrentCompositionDialog,
            enabled_flag=False,
            parent=self.iface.mainWindow()) 
        icon_path = self.plugin_dir + os.sep + 'icons' + os.sep + 'l_4.svg'
        self.menu_UserInfoDialog = self.add_action(
            icon_path,
            text=self.tr(u'User info'),
            callback=self.run_UserInfoDialog,
            enabled_flag=True,
            parent=self.iface.mainWindow())
    #--------------------------------------------------------------------------
    def run_CurrentCompositionDialog(self):
        self.recalculateDPI()
        self.modified = False
        self.dlg = CurrentCompositionDialog() 
        self.dlg.show()
        self.dlg.pushButton_close.setEnabled(False)
        self.dlg.pushButton_close.hide()
        self.dlg.pushButton_editMeta.setEnabled(False)
        self.dlg.pushButton_save.setEnabled(False)
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.label_readonly.hide()
        self.dlg.radioButton_wms.hide()
        self.dlg.radioButton_wfs.hide()
        self.dlg.label_raster.hide() 
        #self.dlg.radioButton_wms.setChecked(True)
        #self.dlg.radioButton_wfs.setChecked(False)
        #self.dlg.radioButton_wfs.setEnabled(False)
        #self.dlg.radioButton_wms.setEnabled(False)    
        self.dlg.treeWidget_layers.header().resizeSection(0,320);    
        self.dlg.pushButton_setPermissions.setStyleSheet("#pushButton_setPermissions {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #00A2E8;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setPermissions:hover{background: #3bc4ff;}#pushButton_setPermissions:disabled{background: #64818b ;}")
        self.dlg.pushButton_new.setStyleSheet("#pushButton_new {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #00A2E8;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_new:hover{background: #3bc4ff;}#pushButton_new:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.pushButton_close2.setStyleSheet("#pushButton_close2 {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close2:hover{background: #66ab27 ;}#pushButton_close2:disabled{background: #64818b ;}")
        self.dlg.pushButton_editMeta.setStyleSheet("#pushButton_editMeta {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_editMeta:hover{background: #66ab27 ;}#pushButton_editMeta:disabled{background: #64818b ;}")
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #FF8080;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #FF2020 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.listWidget_service.setStyleSheet("#listWidget_service {height:20px;}")
        self.dlg.pushButton_editMeta.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'edit.png'))
        self.dlg.pushButton_save.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'save2.png'))
        print(self.current)
        ## pokud je jiný projekt je kompozice vynulovana
        if self.current != None:
            self.instance.refreshComposition()
            composition = self.instance.getComposition()
           
            if composition['title'] != QgsProject.instance().title():
                self.current = None
       
        ##
        if self.current != None:
            self.instance.refreshComposition()
            composition = self.instance.getComposition()
            
            self.dlg.pushButton_editMeta.setEnabled(True) 
            self.dlg.pushButton_new.setEnabled(True)
            self.dlg.pushButton_setPermissions.setEnabled(True)
            self.dlg.pushButton_close.setEnabled(True)
            self.dlg.pushButton_editMeta.setEnabled(True)
            self.dlg.pushButton_save.setEnabled(True)
            self.dlg.pushButton_delete.setEnabled(True)
            #self.dlg.radioButton_wms.setEnabled(False)
            #self.dlg.radioButton_wfs.setEnabled(False)
            #x = self.getCompositionIndexByName()
            
            #self.dlg.label_loadedComposition.setText(composition['title'])
            #self.dlg.label_loadedComposition.hide()
            #self.dlg.label.hide()
            self.dlg.pushButton_setPermissions.clicked.connect(lambda: self.showMapPermissionsDialog(composition['title'], False))
            layerList = list()
            serviceList = list()
            try:
                if self.locale == "cs":
                    self.dlg.setWindowTitle("Kompozice: "+composition['title'])
                else:
                    self.dlg.setWindowTitle("Composition: "+composition['title'])
            except:
                pass
            #for i in range (0, len(self.compositeList[x]['layers'])):    
            print(composition)  
            try:               
                len(composition['layers'])               
            except:
                self.logout()
                if self.locale == "cs":                
                    QMessageBox.information(None, "Chyba připojení", "Uživatel již není příhlášen!")
                    self.logout()
                else:
                    QMessageBox.information(None, "Connection error", "The user is not logged in!")
                return
            for i in reversed(range (0, len(composition['layers']))):            
                #layerList.append(self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['title']))
                layerList.append(self.removeUnacceptableChars(composition['layers'][i]['title']))
                serviceList.append(composition['layers'][i]['className'])
       # layers = self.iface.mapCanvas().layers()
            layers = QgsProject.instance().mapLayers().values()
            layersInCanvas = []
            self.layerIds = list()
            layersArr = list()
            layers = self.getLayersOrder()
            for layer in layers:
                layersArr.append(layer)
          
           # for layer in layersArr[::-1]:  ## q
           # i = 0
            for layer in layersArr:  ## q
            
                
                self.layerIds.append([self.removeUnacceptableChars(layer.name()), layer.id()])
                layerType = layer.type()
                #if layerType == QgsMapLayer.VectorLayer:
                #item = QListWidgetItem()         
                #item.setSizeHint(QSize(0, 19))
                #item.setText(layer.name())   
                item = QTreeWidgetItem()    
                item.setText(0, layer.name()) 
                #itemService = QListWidgetItem()
                layersInCanvas.append(self.removeUnacceptableChars(layer.name()))                
                print(self.removeUnacceptableChars(layer.name()), layerList)
                print(serviceList)
                if self.removeUnacceptableChars(layer.name()) in layerList:   
                    i = layerList.index(self.removeUnacceptableChars(layer.name()))
                    
                    if serviceList[i] == 'OpenLayers.Layer.Vector':
                        #itemService.setText("Layman WFS")
                        #itemService.setText(str(layer.providerType()).upper())
                        item.setText(1, "WFS")  
                    if serviceList[i] == 'HSLayers.Layer.WMS':
                        #itemService.setText("Layman WMS")
                        #itemService.setText(str(layer.providerType()).upper())
                        #item.setText(1, str(layer.providerType()).upper()) 
                        item.setText(1, "WMS") 
                    if serviceList[i] == 'XYZ':
                        #itemService.setText("Layman WMS")
                        #itemService.setText("XYZ")
                        item.setText(1, "XYZ") 
                    item.setCheckState(0,2)
                    if self.locale == "cs":
                        item.setToolTip(0,"Tato vrstva je zobrazena a je součástí načtené kompozice.")
                    else:
                        item.setToolTip(0,"This layer is displayed and is part of the loaded composition.")
                    if layerType == QgsMapLayer.VectorLayer:
                        layer.editingStopped.connect(self.layerEditStopped)
                   # i = i + 1                         
                else:
                    item.setCheckState(0,0)
                    #if self.locale == "cs":
                    #    itemService.setText("Vrstva v QGIS")
                    #else:
                    #    itemService.setText("QGIS layer")
                    if self.locale == "cs":
                        item.setToolTip(0,"Tato vrstva není součástí kompozice.")
                    else:
                        item.setToolTip(0,"This layer is not part of the composition.")
                    print(layer.dataProvider().uri().uri())
                    type = self.getSource(layer)
                    
                    #itemService.setText(str(layer.providerType()).upper())
                    #itemService.setText(type)
                    #item.setText(1, type) 
                    if isinstance(layer, QgsRasterLayer):
                        item.setText(1, "WMS") 
                    if isinstance(layer, QgsVectorLayer):
                        #item.setText(1, "WFS") 
                        item.setText(1, "WMS") 
                    #self.setGuiForItem(itemService)
                    self.setGuiForItem(item)
                    if layerType == QgsMapLayer.VectorLayer:
                        try:
                            layer.editingStopped.disconnect()
                        except:
                            print("connect to stopEditing not exists")          
           
                #self.dlg.listWidget_layers.addItem(item)

                ##test
                
                
                #item.setCheckState(0,2)
                self.dlg.treeWidget_layers.addTopLevelItem(item)
                #self.dlg.treeWidget_layers.setItemWidget(item, 0, cell)
            

                #item = QtWidgets.QTreeWidgetItem(self.dlg.treeWidget_layers)
                #cell = self.dlg.treeWidget_layers
                #cell.addItems(['a','b','c'])
                #self.dlg.treeWidget_layers.tree.setItemWidget(item, 1, cell)
               # 

                ##test
                #itemService.setSizeHint(QSize(0, 19))
                #self.dlg.listWidget_service.addItem(itemService)
            iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
     
            while iterator.value():
                item = iterator.value()
                print(item)
                cell = QComboBox()
                cell.currentTextChanged.connect(self.comboBoxChanged)
                cellServices = QComboBox() 
                for layer in layersArr:
                    if self.removeUnacceptableChars(layer.name()) == self.removeUnacceptableChars(item.text(0)):
                        if isinstance(layer, QgsRasterLayer) and "geoserver" in layer.dataProvider().dataSourceUri():
                            cellServices.addItems(['WMS','WFS'])
                        if isinstance(layer, QgsRasterLayer) and "geoserver" not  in layer.dataProvider().dataSourceUri():
                            cellServices.addItems(['WMS'])
                        if isinstance(layer, QgsVectorLayer):
                            cellServices.addItems(['WMS','WFS'])
                
                if (self.instance.isLayerInComposition(self.removeUnacceptableChars(item.text(0)))):
                    if self.locale == "cs":
                        cell.addItems(['Beze změny','Přepsat data'])
                    else:
                        cell.addItems(['No change','Overwrite geometry'])                        
                else:
                    if self.checkExistingLayer(item.text(0)):
                        if self.locale == "cs":
                            cell.addItems(['Beze změny','Přidat a přepsat','Přidat ze serveru' ])   
                        else:
                            cell.addItems(['No change','Add and overwrite','Add from server' ])                                                          
                    else:
                        if self.locale == "cs":
                            cell.addItems(['Beze změny','Přidat'])
                        else:
                            cell.addItems(['No change','Add'])                           
                  
                self.dlg.treeWidget_layers.setItemWidget(item,2, cell)
                self.dlg.treeWidget_layers.setItemWidget(item,1, cellServices)
                
                #cell.currentIndexChanged.connect(self.actionChanged)
                iterator +=1               
                self.dlg.treeWidget_layers.itemWidget(item,1).setCurrentText(item.text(1))
            print(layerList,layersInCanvas)
            notActive = set(layerList) - set(layersInCanvas)
            print("notActive")
            print(notActive)
            #print(self.unloadedLayers)
            for layer in notActive:
                #item = QListWidgetItem()      
                item = QTreeWidgetItem()      
                #if  layer not in self.unloadedLayers:
                if self.locale == "cs":
                    item.setText(0,layer + " (Smazána z projektu)")
                    item.setFlags(item.flags() & ~Qt.ItemIsUserCheckable)
                    item.setData(0, QtCore.Qt.CheckStateRole, None)
                else:
                    item.setText(0, layer + " (Removed from canvas)")
                    item.setFlags(item.flags() & ~Qt.ItemIsUserCheckable)
                    item.setData(0, QtCore.Qt.CheckStateRole, None)
                #else:
                #    if self.locale == "cs":
                #        item.setText(layer + " (Nedostatečná práva)")
                #    else:
                #        item.setText(layer + " (insufficient rights)")
                brush = QBrush()
                brush.setColor(QColor(255,17,0))
                item.setForeground(0,brush)
                item.setCheckState(0,0)
                if self.locale == "cs":
                    item.setToolTip(0,"Tato vrstva se nevyskytuje v mapovém okně QGIS, ale je obsažena v kompozici.")
                else:
                    item.setToolTip(0,"This layer does not appear in the QGIS map window, but is included in the composition.")
                #self.dlg.listWidget_layers.addItem(item)
                self.dlg.treeWidget_layers.addTopLevelItem(item)
                self.layersWasModified()
            #print(self.compositeList[x])
            #print(composition)
            if self.laymanUsername != self.instance.getWorkspace():
                self.dlg.pushButton_setPermissions.setEnabled(False)
                self.dlg.pushButton_delete.setEnabled(False)
            if 'access_rights' in composition:#self.compositeList[x]:
                #if self.laymanUsername not in self.compositeList[x]['access_rights']['write']:
                print(self.laymanUsername, composition['access_rights']['write'])
                if self.laymanUsername not in composition['access_rights']['write']:
                    self.dlg.listWidget_layers.setEnabled(False)
                    self.dlg.treeWidget_layers.setEnabled(False)
                    self.dlg.listWidget_service.setEnabled(False)
                    self.dlg.pushButton_editMeta.setEnabled(False)
                    self.dlg.pushButton_setPermissions.setEnabled(False)
                    self.dlg.pushButton_close.setEnabled(False)
                    self.dlg.pushButton_save.setEnabled(False)
                    self.dlg.pushButton_delete.setEnabled(False)
                    self.dlg.pushButton_setPermissions.setEnabled(False)
                                    
                    self.dlg.label_readonly.show()
                    

                else:
                    self.dlg.label_readonly.hide()           
            elif self.laymanUsername == self.instance.getWorkspace():
                pass
            else:
                self.dlg.pushButton_editMeta.setEnabled(False)
                self.dlg.listWidget_layers.setEnabled(False)
                self.dlg.listWidget_service.setEnabled(False)
                self.dlg.pushButton_setPermissions.setEnabled(False)
                self.dlg.pushButton_delete.setEnabled(False)
                self.dlg.pushButton_close.setEnabled(False)
                self.dlg.pushButton_save.setEnabled(False)
                self.dlg.label_readonly.show()
        if not self.isAuthorized:
            #self.dlg.radioButton_wms.setEnabled(False)
            #self.dlg.radioButton_wfs.setEnabled(False)
            self.dlg.pushButton_new.setEnabled(False)
            self.dlg.pushButton_setPermissions.setEnabled(False)
            self.dlg.listWidget_layers.setEnabled(False)
            self.dlg.pushButton_editMeta.setEnabled(False)
            self.dlg.treeWidget_layers.setEnabled(False)
            self.dlg.listWidget_service.setEnabled(False)
            self.dlg.pushButton_close.setEnabled(False)
            self.dlg.pushButton_save.setEnabled(False)
            self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.pushButton_editMeta.clicked.connect(lambda: self.showEditMapDialog(None))
        self.dlg.pushButton_close.clicked.connect(lambda: self.saveMapLayers())
        #self.dlg.pushButton_debug.hide()
        #self.dlg.pushButton_debug.clicked.connect(lambda: self.compositionToClipboard())
        
        self.dlg.pushButton_close2.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_new.clicked.connect(lambda: self.showAddMapDialog(True))
        self.dlg.pushButton_save.clicked.connect(lambda: self.updateComposition())
        self.dlg.checkBox_all.stateChanged.connect(self.checkAllLayers)
        self.dlg.pushButton_delete.clicked.connect(lambda: self.deleteCurrentMap())
        self.dlg.progressBar_loader.hide()
        #self.dlg.listWidget_layers.itemChanged.connect(lambda: self.layersWasModified())
        self.dlg.treeWidget_layers.itemChanged.connect(lambda: self.layersWasModified())
        #self.dlg.listWidget_layers.itemChanged.connect(self.itemClick)
        #self.dlg.treeWidget_layers.itemChanged.connect(self.itemClick)
        self.dlg.treeWidget_layers.itemChanged.connect(self.checkCheckbox)
        #self.dlg.listWidget_layers.itemClicked.connect(self.showService)
        #self.dlg.treeWidget_layers.itemClicked.connect(self.showService)
        #self.dlg.listWidget_layers.itemChanged.connect(self.addService)
        #self.dlg.radioButton_wms.toggled.connect(lambda: self.wms_wfs2(self.dlg.listWidget_layers.currentItem().text(), self.dlg.listWidget_layers.currentRow()))      
    def comboBoxChanged(self, text):
        print(text)
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        try:
            while iterator.value():
                item = iterator.value()    
                if item.checkState(0) == 0 and (self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Add from server" or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Přidat ze serveru" or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Add and overwrite" or  self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == 'Přidat' or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == "Přidat a přepsat" or self.dlg.treeWidget_layers.itemWidget(item,2).currentText() == 'Add'  ) :            
                    item.setCheckState(0,2)
                
                iterator +=1
        except:
            print("neni v canvasu")
    def run_LayerDecisionDialog(self, layersToDecision):
        self.recalculateDPI()
        self.dlg = LayerDecisionDialog() 
        self.dlg.show()
        for layer in layersToDecision:
            item = QListWidgetItem()
            item.setText(layer)
            item.setCheckState(0)
            self.dlg.listWidget_layers.addItem(item)
        self.dlg.pushButton_save.clicked.connect(lambda: self.layersToUpload())
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
    def layersToUpload(self):
        for i in range(0, self.dlg.listWidget_layers.count()):
            item = self.dlg.listWidget_layers.item(i)
            if item.checkState() == 0:
                self.noOverrideLayers.append(item.text())
        print("noOverrideLayers")
        print(self.noOverrideLayers)
        self.dlg = self.old_dlg
        self.updateComposition(False)
    def recalculateDPI(self):
        self.DPI = self.getDPI()
        if self.DPI < 0.85:
            self.fontSize = "12px"
        else:
            self.fontSize = "10px"
    # def actionChanged(self, index):
    #     print("praslice")
    #     iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
    #     while iterator.value():
    #         item = iterator.value()            
    #         #self.currentSet.append([item.text(0),self.dlg.treeWidget_layers.itemWidget(item,1).currentText(),self.dlg.treeWidget_layers.itemWidget(item,2).currentText()])
    def checkCheckbox(self, item, column):
        print(item)        
        combobox = self.dlg.treeWidget_layers.itemWidget(item,2)
        if combobox is not None:
            print(combobox.currentIndex())
            if item.checkState(column) == 2:                   
                combobox.setCurrentIndex(1)
            if item.checkState(column) == 0:            
                combobox.setCurrentIndex(0) 
                    
    def addService(self, item):
        if item.checkState() == 2:
            print("new layer")
            #if self.dlg.radioButton_wms.isChecked():
            #self.layerServices[self.removeUnacceptableChars(item.text())] = 'HSLayers.Layer.WMS'
            #self.dlg.radioButton_wms.setChecked(True)
            #self.dlg.radioButton_wfs.setChecked(False)
            #print(self.layerServices[self.removeUnacceptableChars(item.text())])
            #if self.dlg.radioButton_wfs.isChecked():
            #    self.layerServices[self.removeUnacceptableChars(item.text())] = 'OpenLayers.Layer.Vector'
            #    self.dlg.radioButton_wms.setChecked(False)
            #    self.dlg.radioButton_wfs.setChecked(True)
        #if item.checkState() == 0:               
        #    try:
        #        del self.layerServices[self.removeUnacceptableChars(item.text())]
        #    except:
        #        pass
    def setGuiForItem(self, item):  
        if item.text(1) == "GEOJSON":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená z lokálního souboru geojson.")
            else:
                item.setToolTip(1,"Layer loaded from a local geojson file.")
  
        if item.text(1) == "SHP":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená z lokálního souboru SHP.")
            else:
                item.setToolTip(1,"Layer loaded from a local SHP file.")
     
        if item.text(1) == "MEMORY":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva uložená v paměti QGIS. Po vypnutí QGIS bude smazána.")
            else:
                item.setToolTip(1,"Layer stored in QGIS memory. It will be deleted after QGIS is turned off.") 
                
        if item.text(1) == "WMS":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená přes službu WMS poskytující data v rasterovém formátu. Je možné tuto službu zaměnit za vektorovou službu WFS pomocí tlačítka.")
            else:
                item.setToolTip(1,"A layer loaded over a WMS service that provides data in a raster format. It is possible to change this service to a WFS vector service using the button.")
        if item.text(1) == "WFS":
            if self.locale == "cs":
                item.setToolTip(1,"Vrstva načtená přes službu WFS poskytující data ve vektorovém formátu. Je možné tuto službu zaměnit za rasterovou službu WMS pomocí tlačítka. Změny v této vrstvě jsou ukládány na server.")
            else:
                item.setToolTip(1,"A layer loaded over a WFS service that provides data in a vector format. It is possible to change this service to a WMS raster service using the button. Changes in this layer are saved to the server.")
        if item.text(1) == "OGR":
            if self.locale == "cs":
                item.setToolTip(1,"Vektorová vrstva načtená z lokálního souboru.")
            else:
                item.setToolTip(1,"Vector layer loaded from a local file.")

    def getSource(self, layer):
        uri = layer.dataProvider().uri().uri()       
        if ".geojson" in uri:
            return "GEOJSON"
        elif ".shp" in uri:
            return "SHP"
        elif "wms" in uri:
            return "WMS"
        elif "wfs" in uri:
            return "WFS"
        elif str(layer.providerType()) == "memory":
            return "MEMORY"
        elif str(layer.providerType()) == "gdal":
            
            return "RASTER"
        else:  
            return "OGR"
    def getDPI(self):
        return iface.mainWindow().physicalDpiX()/iface.mainWindow().logicalDpiX()        
    #def showService(self, item, col):
    #    self.dlg.radioButton_wms.setEnabled(True)
    #    self.dlg.radioButton_wfs.setEnabled(True)
       
    #    print("show service")
    #    layer = QgsProject.instance().mapLayersByName(item.text(0))[0]
    #    #if isinstance(layer, QgsRasterLayer):
    #    #    self.dlg.radioButton_wfs.setEnabled(False)
    #    #    self.dlg.radioButton_wms.setChecked(True)
    #    #    return
    #    print(self.removeUnacceptableChars(item.text(0)),self.layerServices)
    #    print(self.removeUnacceptableChars(item.text(0)) in self.layerServices)
    #    if self.removeUnacceptableChars(item.text(0)) in self.layerServices:  
            
    #        if self.layerServices[self.removeUnacceptableChars(item.text(0))] == 'HSLayers.Layer.WMS':
             
    #            self.dlg.radioButton_wms.setChecked(True)
    #            self.dlg.radioButton_wfs.setChecked(False)
    #        elif self.layerServices[self.removeUnacceptableChars(item.text(0))] == 'OpenLayers.Layer.Vector':
                
    #            self.dlg.radioButton_wfs.setChecked(True)
    #            self.dlg.radioButton_wms.setChecked(False)
    #        #elif item.checkState() == 2:
    #        #    print("new layer")
    #        #    self.layerServices[self.removeUnacceptableChars(item.text())] = 'HSLayers.Layer.WMS'
    #        #    self.dlg.radioButton_wfs.setEnabled(True)
    #        #    self.dlg.radioButton_wms.setEnabled(False)
    #        else: 
    #            self.dlg.radioButton_wfs.setEnabled(False)
    #            self.dlg.radioButton_wms.setEnabled(False)
    #    else:
    #        self.layerServices[self.removeUnacceptableChars(item.text(0))] = 'HSLayers.Layer.WMS'
            
            

    def itemClick(self, item, col):        
        if item.checkState(0) == 2 and self.checkIfLayerIsInMoreGroups(QgsProject.instance().mapLayersByName(item.text(0))[0]):
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva " + item.text(0) +" je vnořena do dvou skupin. Uložena bude pouze nadřazená.")
            else:
                QMessageBox.information(None, "Layman", "Layer " + item.text(0) +" is nested in two groups. Only parent group will be saved.")
            # if self.locale == "cs":
            #     iface.messageBar().pushWidget(iface.messageBar().createMessage("Vrstva " + item.text(0) +" je vnořena do dvou skupin. Uložena může být pouze jedna."), Qgis.Warning, duration=5)               
            # else:
            #     iface.messageBar().pushWidget(iface.messageBar().createMessage("Layer " + item.text(0) +" is nested in two groups. Only one can be saved."), Qgis.Warning, duration=5)               
            #if self.locale == "cs":
            #    self.dlg.label_info.setText("Vrstva " + item.text() +" je vnořena do dvou skupin. Uložena může být pouze jedna.")
            #else:
            #    self.dlg.label_info.setText("Layer " + item.text() +" is nested in two groups. Only one can be saved.")
        else:
            self.dlg.label_info.setText("")
    def layersWasModified(self):
        
        self.modified = True
    def checkIfLayerIsInMoreGroups(self, layer):
        root = QgsProject.instance().layerTreeRoot()
        tree_layer = root.findLayer(layer.id())
        if tree_layer:
            layer_parent = tree_layer.parent()

            if layer_parent: 
                print("Layer parent: {}".format(layer_parent.name() or 'root'))
                group_parent = layer_parent.parent() # If you want to go up another level
                test = layer_parent.name() or 'root'
                if test == 'root':
                    return False
                if group_parent: 
                    print("Group parent: {}".format(group_parent.name() or 'root'))
                    test = group_parent.name() or 'root'
                    if test == 'root':
                        return False
                    else:
                        return True
    def getGroupOfLayer(self, layer):
        root = QgsProject.instance().layerTreeRoot()
        tree_layer = root.findLayer(layer.id())
        if tree_layer:
            layer_parent = tree_layer.parent()

            if layer_parent: 
                print("Layer parent: {}".format(layer_parent.name() or 'root'))
                group_parent = layer_parent.parent() 
                return layer_parent.name() or 'root'
    def differentThanBefore(self):
        for index in range(0, self.dlg.listWidget_layers.count()):
            item = self.dlg.listWidget_layers.item(index)
            print(item.foreground().color().getRgb())
            if (item.foreground().color().green() == 18 and item.checkState() == 2):
                print("ids")
                print(self.layerIds[index])
                if self.instance.isLayerId(self.layerIds[index][1]):
                    print("ggggggggggggg")
                    pass ## layer included in layman - do nothing
                else: ## layer is new with same name - patch
                    layerList = [lyr for lyr in QgsProject.instance().mapLayers().values() if lyr.name() == item.text()]
                    for layer in layerList:
                        if layer.id() == self.layerIds[index][1]:
                            data = { 'name' :  self.removeUnacceptableChars(layer.name()), 'title' : str(layer.name())} 
                            self.patchThread2(layer.name(), data, layer.id())                            
                            self.instance.changeLayerId(layer)
                            ## refresh formulare - staré wfs
                            
                    print("dddddddddddd")
            if (item.foreground().color().green() == 18 and item.checkState() == 0):
                item = self.dlg.listWidget_layers.item(index)
                print(self.layerIds[index][1], self.layerIds[index][0])
                print(self.instance.isLayerId(self.layerIds[index][1]))
                print("debugggg")
                if self.instance.isLayerId(self.layerIds[index][1]):
                    print("layer iddddddddddddddddd")
                    #item.setHidden(True)
                    del item
                    self.dlg.listWidget_layers.repaint()
                    

    def progressColor(self, name, status):
        for index in range(0, self.dlg.listWidget_layers.count()): ## show only duplicity
            item = self.dlg.listWidget_layers.item(index)            
            if item.text() == name:    
                if status:
                    item.setForeground(QColor(0,128,0))
                else:
                    item.setForeground(QColor(255,0,0))

    def crsChanged(self):
        print("crs changed")  
        #QApplication.instance().processEvents()   
        crs = QgsProject.instance().crs()
        if  self.crsOld != crs.authid() and self.current != None:
            self.crsOld = crs.authid()
            print(crs.authid())
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Souřadnicový systém byl změnen na: "+ str(crs.authid())+". Chcete tento souřadnicový systém zapsat do kompozice?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Coordinate system was changed to: "+ str(crs.authid())+". Do you want write it to composition?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):    
                composition = self.instance.getComposition()         
                xmin = float(composition['extent'][0])
                xmax = float(composition['extent'][2])
                ymin = float(composition['extent'][1])
                ymax = float(composition['extent'][3])
                xcenter = float(composition['center'][0])
                ycenter = float(composition['center'][1])
                if crs.authid() == 'EPSG:5514':
                    composition['projection'] = str(crs.authid()).lower()                
                    #max = self.krovakToWgs(xmax, ymax)
                    #min = self.krovakToWgs(xmin, ymin)
                    #center = self.krovakToWgs(xcenter, ycenter)
                    #composition['extent'][0] = str(min[0])
                    #composition['extent'][2] = str(max[0])
                    #composition['extent'][1] = str(min[1])
                    #composition['extent'][3] = str(max[1])
                    #composition['center'][0] = center[0]
                    #composition['center'][1] = center[1]
                if crs.authid() == 'EPSG:4326':                
                    composition['projection'] = str(crs.authid()).lower()   
                    #max = self.wgsToKrovak(xmax, ymax)
                    #min = self.wgsToKrovak(xmin, ymin)
                    #center = self.wgsToKrovak(xcenter, ycenter)
                    #composition['extent'][0] = str(min[0])
                    #composition['extent'][2] = str(max[0])
                    #composition['extent'][1] = str(min[1])
                    #composition['extent'][3] = str(max[1])
                    #composition['center'][0] = center[0]
                    #composition['center'][1] = center[1]
                self.patchMap2()   
            #layers = QgsProject.instance().mapLayers().values()    
         
            #for layer in layers:
            #    layer.setCrs(crs)                
            #self.change_map_canvas(crs)
           # QTimer.singleShot(10, self.set_project_crs)    ,
           # provést refresh pro všechny vrstvy         
           
    def set_project_crs(self):
        # Set CRS to EPSG:4326
        QApplication.instance().processEvents()
        print("pessss")
        QgsProject.instance().setCrs(QgsCoordinateReferenceSystem(self.crsOld))
    def change_map_canvas(self, crs):
        #iface.newProject(False)
        
        crs = QgsCoordinateReferenceSystem(crs)


        #l = get_google_layer()
        #QgsProject.instance().addMapLayer(l)
        QApplication.instance().processEvents()

        QgsProject.instance().setCrs(crs)
    def duplicateLayers(self):
        layerList = set()
        duplicity = list()
        ret = False

        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()         
            if item.text(0) in layerList and item.checkState(0) == 2:
                print("duplicity" + item.text(0))
                duplicity.append(item.text(0))
            if item.checkState(0) == 2:
                layerList.add(item.text(0))
                print("append" + item.text(0))
            #self.currentSet.append([item.text(0),item.text(1),self.dlg.treeWidget_layers.itemWidget(item,2).currentText()])
            iterator +=1
        while iterator.value():
            item = iterator.value()   
            
            if item.text(0) in duplicity:
                print("meniim:" + item.text(0))
                item.setForeground(0, QColor(255,18,0))
                ret = True
            else:
                print("nemeniim:" + item.text(0))
                item.setForeground(0, QColor(0,0,0))
            iterator +=1    
        print("ret:" + str(ret))            
        return ret
        #for index in range(0, self.dlg.listWidget_layers.count()): ## find duplicity
        #    item = self.dlg.listWidget_layers.item(index)
        #    if item.text() in layerList and item.checkState() == 2:
        #        print("duplicity" + item.text())
        #        duplicity.append(item.text())
        #    if item.checkState() == 2:
        #        layerList.add(item.text())
        #        print("append" + item.text())
           
        #for index in range(0, self.dlg.listWidget_layers.count()): ## show only duplicity
        #    item = self.dlg.listWidget_layers.item(index)
        #    print(duplicity)
        #    print("d: " + item.text())
        #    if item.text() in duplicity:
        #        print("meniim:" + item.text())
        #        item.setForeground(QColor(255,18,0))
        #        ret = True
        #    else:
        #        print("nemeniim:" + item.text())
        #        item.setForeground(QColor(0,0,0))
        #print("ret:" + str(ret))            
        #return ret
    def addExistingLayerToComposition(self, title, composition, type):      
        name = self.removeUnacceptableChars(title)
        #response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(name), headers = self.getAuthHeader(self.authCfg))
        #res = self.fromByteToJson(response.content)
        #print(res)
        #wmsUrl = res['wms']['url']
        #wfsUrl = res['wfs']['url']
        
        self.existLayer = False

        #self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(name),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","FROMCRS":"EPSG:3857","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
        if (type == "wms"):
            wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'_wms/ows'
            composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"opacity":1,"url": wmsUrl ,"params":{"LAYERS": str(name),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
        if (type == "wfs"):
            wfsUrl = self.URI+'/geoserver/'+self.laymanUsername+'/wfs'
            composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"OpenLayers.Layer.Vector","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"name": str(name),"opacity":1 ,"protocol":{"format": "hs.format.WFS","url": wfsUrl,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"visibility": True,"dimensions":{}})
        
    def checkIfLayersExists(self):        
        layerListServer = list()
        foundedOnServer = False
        layersToDecision = list()
        uri = self.URI + "/rest/"+self.laymanUsername+"/layers"     
        r= requests.get(uri,headers = self.getAuthHeader(self.authCfg))
        data = r.json()
        #print(data)
        for i in range(0, len(data)):
            layerListServer.append(data[i]['name']) 
        print(layerListServer)
        for index in range(0, self.dlg.listWidget_layers.count()): ## find duplicity
            item = self.dlg.listWidget_layers.item(index)           
            print("debugg")
            print(item.text())
            print(self.instance.isLayerInComposition(self.removeUnacceptableChars(item.text())))
            print(self.instance.getLayerNamesList())
            #return True
            if item.checkState() == 2 and self.removeUnacceptableChars(item.text()) in layerListServer and not self.instance.isLayerInComposition(self.removeUnacceptableChars(item.text())):
                item.setForeground(QColor(0,191,255))
                foundedOnServer = True
                layersToDecision.append(item.text())
        if foundedOnServer:
            self.old_dlg = self.dlg
            self.run_LayerDecisionDialog(layersToDecision)  
            return True
        else:
            return False     
                
            
    def saveMapLayers(self):
        layerList = list()
        layerCheckedList = list()
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value() 
            if item.checkState(0) == 2:
                layerCheckedList.append(item.text(0))
            iterator +=1
        #for index in range(0, self.dlg.listWidget_layers.count()):
        #    item = self.dlg.listWidget_layers.item(index)
        #    if item.checkState() == 2:
        #        layerCheckedList.append(item.text())
        composition = self.instance.getComposition()
        #for i in range (0, len(self.compositeList[x]['layers'])):            
        for i in range (0, len(composition['layers'])):            
            #layerList.append(self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['title']))
            layerList.append(self.removeUnacceptableChars(composition['layers'][i]['title']))
        composition = self.instance.getComposition()
        self.processingRequest = True
        layers = list()       
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()         
            if item.checkState(0) == 2 and  self.removeUnacceptableChars(item.text(0)) not in layerList: 
            #if item.checkState(0) == 2: 
                if not self.checkLayerInCurrentCompositon(item.text(0)): # kdyz se nenachazi v kompozici nahravame
                #if True: # kdyz se nenachazi v kompozici nahravame
                    layer = QgsProject.instance().mapLayersByName(item.text(0))[0]                  
                    if (isinstance(layer, QgsVectorLayer)):
                        #if layer.featureCount() > 0:
                        if True:
                            layerType = layer.type()                    
                            if layerType == QgsMapLayer.VectorLayer:
                                layer.editingStopped.connect(self.layerEditStopped) 
                            layers.append(layer)
                        else:
                            if self.locale == "cs":                
                                QMessageBox.information(None, "Layman import layer", "Nelze nahrát vrstvu: "+layer.name()+", protože neobsahuje žádný prvek!")
                            else:
                                QMessageBox.information(None, "Layman import layer", "Unable to load layer: "+layer.name()+", because it has no feature!")
                    else:
                        layers.append(layer)
                    #self.addLayerToComposite2(x, layer)
                    
            elif item.checkState(0) == 2 and  self.removeUnacceptableChars(item.text(0))  in layerList: 
                for it in self.currentSet:
                    print(it[2], it[0], item.text(0))
                    if (it[2] =='Overwrite geometry'  or it[2] == "Přepsat data") and it[0] == item.text(0):
                        layer = QgsProject.instance().mapLayersByName(item.text(0))[0]                              
                        if layer.type() == QgsMapLayer.VectorLayer:                
                            self.postRequest(layer.name(), True)
            elif item.checkState(0) == 0 and item.text(0) not in layerCheckedList:  ## může být zaškrnut i jinde, pak nemažem
                print(len(composition['layers']))
                pom = 0
                for i in range (0, len(composition['layers'])): 
                    i = i - pom
                    print("deleting")
                    print(item.text(0))
                    print(i)
                    #print(self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['title']),self.removeUnacceptableChars(item.text()))
                    
                    if self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(item.text(0).split(" (")[0]):                    
                        del composition['layers'][i]
                        pom = pom + 1

            iterator +=1
     
                   
        if len(layers) > 0:
            print("test upload layers")
            print(self.currentSet)
            newLayers = list()
            for item in self.currentSet:
                print(item)
                layersFromServer = list()
                print(layers)
                if item[2] == "Add from server" or item[2] == "Přidat ze serveru":
                    for layer in layers:
                        print(layer.name())                
                        #if layer.name() in self.noOverrideLayers:
                        if layer.name() == item[0]:
                            #layersFromServer.append(layer) ## nebude se nahrávat geojson, ale jen se vytvori zaznam do kompozice
                            self.addExistingLayerToComposition(layer.name(),composition,item[1].lower()) 
                            layers.remove(layer)
                       
                #self.addLayerToComposite2(x, layers)
                #threading.Thread(target=lambda: self.addLayerToComposite2(composition, layers)).start()   
                print(item[2])
                if item[2] == "Add and overwrite" or item[2] =='Add' or item[2] == "Přidat a přepsat" or item[2] =='Přidat':
                    for layer in layers:
                        if layer.name() == item[0]:
                            newLayers.append(layer)
                    #print(layers)     
                    #self.toUpload = len(layers)
                    #if len(layers) == 0:
                    #    return
                    #else:
                    #    self.addLayerToComposite2(composition, layers)
                #if item[2] =='Overwrite geometry':
                #    for layer in layers:
                #        if layer.name() == item[0]:
                #            if layer.type() == QgsMapLayer.VectorLayer:
                #                self.postRequest(layers[i].name(), True)

            if len(newLayers) > 0:
                self.addLayerToComposite2(composition, layers)
        
        #self.dlg.close()
    def getFinalService(self, layerName):
        for item in self.currentSet:
            if item[0] == layerName:
                return item[1]
    def run_UserInfoDialog(self):
        print(self.liferayServer)
        print(self.laymanUsername)
        self.recalculateDPI()
        self.dlg = UserInfoDialog() 
        self.dlg.show()        
        self.dlg.pushButton_update.setStyleSheet("#pushButton_update {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_update:hover{background: #66ab27 ;}#pushButton_update:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        print(self.liferayServer)
        print(self.liferayServer != None and self.laymanUsername != "")
        if self.liferayServer != None and self.laymanUsername != "":
            userEndpoint = self.URI + "/rest/current-user"
            r = requests.get(url = userEndpoint,  headers = self.getAuthHeader(self.authCfg))
            res = r.text
            res = self.fromByteToJson(r.content)
            versionCheck = self.checkVersion()            
            self.dlg.pushButton_update.clicked.connect(lambda: self.updatePlugin(versionCheck[1]))
            print(res['claims'])
            if self.isAuthorized:
                self.dlg.label_layman.setText(res['claims']['preferred_username'])
                self.dlg.label_agrihub.setText(res['claims']['email'])
            else:
                self.dlg.label_layman.setText("Anonymous")
            #self.dlg.label_server.setText(self.liferayServer)
            self.dlg.label_server.setText(self.URI)
            
            self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
            self.dlg.label_version.setText(self.getVersion())
            self.dlg.label_versionLayman.setText(self.laymanVersion)
            self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
            
            self.dlg.label_avversion.setText(versionCheck[1])
            if versionCheck[0] == True:
                self.dlg.label_avversion.hide()
                self.dlg.label_5.hide()
                self.dlg.pushButton_update.setEnabled(False)
        else:
            self.dlg.label_version.setText(self.getVersion())
            versionCheck = self.checkVersion()
            self.dlg.label_avversion.setText(versionCheck[1])
            if versionCheck[0] == True:
                self.dlg.label_avversion.hide()
                self.dlg.label_5.hide()
                self.dlg.pushButton_update.setEnabled(False)            
            self.dlg.pushButton_update.clicked.connect(lambda: self.updatePlugin(versionCheck[1]))
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
    def run_SetMapPermission(self, mapName, fromAddMap = False):
        self.recalculateDPI()
        self.dlg = SetPermissionDialog() 
        self.dlg.show()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_addRead.setStyleSheet("#pushButton_addRead {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addRead:hover{background: #66ab27 ;}#pushButton_addRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeRead.setStyleSheet("#pushButton_removeRead {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeRead:hover{background: #66ab27 ;}#pushButton_removeRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_addWrite.setStyleSheet("#pushButton_addWrite {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addWrite:hover{background: #66ab27 ;}#pushButton_addWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeWrite.setStyleSheet("#pushButton_removeWrite {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeWrite:hover{background: #66ab27 ;}#pushButton_removeWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.progressBar_loader.hide() 
        self.dlg.listWidget_read.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.listWidget_write.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.pushButton_removeRead.setEnabled(False)
        self.dlg.pushButton_removeWrite.setEnabled(False)
        uri = self.URI + "/rest/users"
        usersDict = dict()
        if self.locale == "cs":
            usersDict['EVERYONE'] = 'VŠICHNI'
        else:
            usersDict['EVERYONE'] = 'EVERYONE'
        usersDictReversed = dict()
        if self.locale == "cs":
            usersDictReversed['EVERYONE'] = 'VŠICHNI'
        else:
            usersDictReversed['EVERYONE'] = 'EVERYONE'
        r= requests.get(uri)
        res = self.fromByteToJson(r.content)
        userCount = len(res)
        ##nabit combobox
        if self.locale == "cs":
            self.dlg.comboBox_users.addItem('VŠICHNI')
        else:            
            self.dlg.comboBox_users.addItem('EVERYONE')
        for i in range (0, userCount):
            #print(res[i]['name'])
            #print(res[i]['username'])
            usersDict[res[i]['name']] = res[i]['username'] 
            usersDictReversed[res[i]['username']] = res[i]['name'] 
            self.dlg.comboBox_users.addItem(res[i]['name']  + ' , ' + res[i]['username'])
        ##nabit listView
        mapName = self.removeUnacceptableChars(mapName)
        uri = self.URI + "/rest/"+self.laymanUsername+"/maps/"+mapName
        
        r= requests.get(uri,headers = self.getAuthHeader(self.authCfg))
        res = self.fromByteToJson(r.content)
      
        lenRead = len(res['access_rights']['read'])
        lenWrite = len(res['access_rights']['write'])
        for i in range (0, lenRead):
            #if (usersDictReversed[res['access_rights']['read'][i]] != usersDictReversed[self.laymanUsername]):
            self.dlg.listWidget_read.addItem(usersDictReversed[res['access_rights']['read'][i]])
        for i in range (0, lenWrite):
           # if (usersDictReversed[res['access_rights']['write'][i]] != usersDictReversed[self.laymanUsername]):
            self.dlg.listWidget_write.addItem(usersDictReversed[res['access_rights']['write'][i]])
        #self.dlg.pushButton_save.clicked.connect(lambda: self.updatePermissions([mapName], usersDict, "maps"))
        self.dlg.pushButton_save.clicked.connect(lambda:  self.dlg.progressBar_loader.show())
        #self.dlg.pushButton_save.clicked.connect(lambda: threading.Thread(target=lambda: self.updatePermissions([mapName], usersDict, "maps", True)).start())
        self.dlg.pushButton_save.clicked.connect(lambda:self.askForLayerPermissionChanges([mapName], usersDict, "maps"))
        

        self.dlg.pushButton_addRead.clicked.connect(lambda: self.checkAddedItemDuplicity("read"))
        self.dlg.pushButton_addWrite.clicked.connect(lambda: self.setWritePermissionList())

        self.dlg.pushButton_removeRead.clicked.connect(lambda: self.removeWritePermissionList())
        self.dlg.pushButton_removeWrite.clicked.connect(lambda: self.dlg.listWidget_write.removeItemWidget(self.dlg.listWidget_write.takeItem(self.dlg.listWidget_write.currentRow())))
        if fromAddMap:
            self.dlg.rejected.connect(lambda: self.afterClosePermissionMapDialog())  
        else:
            self.dlg.rejected.connect(lambda: self.afterCloseEditMapDialog())  
        
    def run_SetPermission(self, layerName):
        self.recalculateDPI()
        self.dlg = SetPermissionDialog() 
        self.dlg.show()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_addRead.setStyleSheet("#pushButton_addRead {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addRead:hover{background: #66ab27 ;}#pushButton_addRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeRead.setStyleSheet("#pushButton_removeRead {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeRead:hover{background: #66ab27 ;}#pushButton_removeRead:disabled{background: #64818b ;}")
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_addWrite.setStyleSheet("#pushButton_addWrite {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addWrite:hover{background: #66ab27 ;}#pushButton_addWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_removeWrite.setStyleSheet("#pushButton_removeWrite {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_removeWrite:hover{background: #66ab27 ;}#pushButton_removeWrite:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")       
        self.dlg.progressBar_loader.hide() 
        self.dlg.listWidget_read.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.listWidget_write.itemSelectionChanged.connect(lambda: self.checkPermissionButtons())
        self.dlg.pushButton_removeRead.setEnabled(False)
        self.dlg.pushButton_removeWrite.setEnabled(False)
        uri = self.URI + "/rest/users"
        usersDict = dict()
        if self.locale == "cs":
            usersDict['EVERYONE'] = 'VŠICHNI'
        else:
            usersDict['EVERYONE'] = 'EVERYONE'
        usersDictReversed = dict()
        if self.locale == "cs":
            usersDictReversed['EVERYONE'] = 'VŠICHNI'
        else:
            usersDictReversed['EVERYONE'] = 'EVERYONE'
        r= requests.get(uri)
        res = self.fromByteToJson(r.content)
        print(r.content)
        userCount = len(res)
        ##nabit combobox
        if self.locale == "cs":
            self.dlg.comboBox_users.addItem('VŠICHNI')
        else:            
            self.dlg.comboBox_users.addItem('EVERYONE')
        for i in range (0, userCount):
            #print(res[i]['name'])
            #print(res[i]['username'])
            usersDict[res[i]['name']] = res[i]['username'] 
            usersDictReversed[res[i]['username']] = res[i]['name'] 
            if (res[i]['name'] != self.laymanUsername):
                self.dlg.comboBox_users.addItem(res[i]['name'] + ' , ' + res[i]['username'] )
        ##nabit listView
        print(len(layerName))
        if (len(layerName) == 1):            
            layerName[0] = self.removeUnacceptableChars(layerName[0])
            uri = self.URI + "/rest/"+self.laymanUsername+"/layers/"+layerName[0]
        
            r= requests.get(uri,headers = self.getAuthHeader(self.authCfg))
            res = self.fromByteToJson(r.content)
      
            lenRead = len(res['access_rights']['read'])
            lenWrite = len(res['access_rights']['write'])
            for i in range (0, lenRead):
                print(usersDictReversed)
                #if (usersDictReversed[res['access_rights']['read'][i]] != usersDictReversed[self.laymanUsername]):
                self.dlg.listWidget_read.addItem(usersDictReversed[res['access_rights']['read'][i]])
            for i in range (0, lenWrite):
                ##if (usersDictReversed[res['access_rights']['write'][i]] != usersDictReversed[self.laymanUsername]):
                self.dlg.listWidget_write.addItem(usersDictReversed[res['access_rights']['write'][i]])
        else:
            self.dlg.listWidget_read.addItem(self.name)
            self.dlg.listWidget_write.addItem(self.name)
            self.dlg.listWidget_read.addItem(usersDict['EVERYONE'])
        self.dlg.pushButton_save.clicked.connect(lambda:  self.dlg.progressBar_loader.show())
        #self.dlg.pushButton_save.clicked.connect(lambda: threading.Thread(target=lambda: self.updatePermissions(layerName, usersDict, "layers")).start())
        self.dlg.pushButton_save.clicked.connect(lambda: self.askForMapPermissionChanges(layerName, usersDict, "layers"))
        self.dlg.pushButton_addRead.clicked.connect(lambda:  self.checkAddedItemDuplicity("read"))
        self.dlg.pushButton_addWrite.clicked.connect(lambda: self.setWritePermissionList())
        
        self.dlg.pushButton_removeRead.clicked.connect(lambda: self.removeWritePermissionList())
        self.dlg.pushButton_removeWrite.clicked.connect(lambda: self.dlg.listWidget_write.removeItemWidget(self.dlg.listWidget_write.takeItem(self.dlg.listWidget_write.currentRow())))
        
        #|self.dlg.rejected.connect(lambda: self.afterCloseEditMapDialog()) 
        self.dlg.rejected.connect(lambda: self.afterClosePermissionMapDialog()) 
    def run_EditCurrentMap(self):
        self.recalculateDPI()
        composition = self.instance.getComposition()
        self.dlg = EditMapDialog()      
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton_range.setStyleSheet("#pushButton_range {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_range:hover{background: #66ab27 ;}#pushButton_range:disabled{background: #64818b ;}")
        self.dlg.pushButton_range_2.setStyleSheet("#pushButton_range_2 {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_range_2:hover{background: #66ab27 ;}#pushButton_range_2:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}") 
        self.dlg.lineEdit_name.hide()
        self.dlg.label_2.hide()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.lineEdit_name.setText(composition['name'])
        self.dlg.lineEdit_abstract.setText(composition['abstract'])
        self.dlg.lineEdit_title.setText(composition['title'])
        self.dlg.lineEdit_units.setText(composition['units'])
        self.dlg.lineEdit_scale.setText(str(composition['scale']))
        self.dlg.lineEdit_user.setText(composition['user']['name'])
        self.dlg.lineEdit_xmin.setText(str(composition['extent'][0]))
        self.dlg.lineEdit_xmax.setText(str(composition['extent'][2]))
        self.dlg.lineEdit_ymin.setText(str(composition['extent'][1]))
        self.dlg.lineEdit_ymax.setText(str(composition['extent'][3]))
        self.dlg.lineEdit_epsg.setEnabled(False)
        if 'projection' in composition:
            self.dlg.lineEdit_epsg.setText(composition['projection'].replace("epsg:",""))     
        self.dlg.lineEdit_xmin.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_xmax.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_ymin.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_ymax.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.rejected.connect(lambda: self.afterCloseCurrentMapDialog()) 
        self.dlg.pushButton_save.clicked.connect(lambda: self.modifyMapNew())
        self.dlg.pushButton_range_2.clicked.connect(lambda: self.setRangeFromCanvas())
        self.dlg.pushButton_range.clicked.connect(lambda: self.setExtentFromLayers())
        if self.locale == "cs":
            self.dlg.pushButton_range.setToolTip("Získá informaci o rozsahu z wms capatibilies.")
            self.dlg.pushButton_range_2.setToolTip("Získá informaci o rozsahu z okna QGI.")
        else:
            self.dlg.pushButton_range.setToolTip("Gets spatial range information from wms capatibilies.")
            self.dlg.pushButton_range_2.setToolTip("Gets spatial range information from QGIS canvas.")
        
        #self.dlg.rejected.connect(lambda: self.afterCloseCompositeDialog())

        if not self.isAuthorized:
            self.dlg.pushButton_save.setEnabled(False)
            self.dlg.pushButton_range.setEnabled(False)
            self.dlg.pushButton_range_2.setEnabled(False)
        self.dlg.show()
        result = self.dlg.exec_()

    def run_EditMap(self, x):
        self.recalculateDPI()
        self.dlg = EditMapDialog()      
        self.dlg.pushButton_save.setStyleSheet("#pushButton_save {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_save:hover{background: #66ab27 ;}#pushButton_save:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton_range.setStyleSheet("#pushButton_range {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_range:hover{background: #66ab27 ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}") 
        self.dlg.lineEdit_name.hide()
        self.dlg.label_2.hide()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.lineEdit_name.setText(self.compositeList[x]['name'])
        self.dlg.lineEdit_abstract.setText(self.compositeList[x]['abstract'])
        self.dlg.lineEdit_title.setText(self.compositeList[x]['title'])
        self.dlg.lineEdit_units.setText(self.compositeList[x]['units'])
        self.dlg.lineEdit_scale.setText(str(self.compositeList[x]['scale']))
        self.dlg.lineEdit_user.setText(self.compositeList[x]['user']['name'])
        self.dlg.lineEdit_xmin.setText(self.compositeList[x]['extent'][0])
        self.dlg.lineEdit_xmax.setText(self.compositeList[x]['extent'][2])
        self.dlg.lineEdit_ymin.setText(self.compositeList[x]['extent'][1])
        self.dlg.lineEdit_ymax.setText(self.compositeList[x]['extent'][3])
        self.dlg.lineEdit_xmin.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_xmax.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_ymin.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_ymax.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.rejected.connect(lambda: self.afterCloseEditMapDialog()) 
        self.dlg.pushButton_save.clicked.connect(lambda: self.modifyMap(x))
       # self.dlg.pushButton_range.clicked.connect(lambda: self.setRangeFromCanvas())
        self.dlg.pushButton_range.clicked.connect(lambda: self.setExtentFromLayers(x))
        #self.dlg.rejected.connect(lambda: self.afterCloseCompositeDialog())
        self.dlg.show()
        result = self.dlg.exec_()

    def run_DeleteLayerFromMap(self):
        self.recalculateDPI()
        self.dlg = DeleteLayerFromMapDialog()
        self.dlg.pushButton.clicked.connect(lambda: self.deteteLayerFromComposite(self.dlg.listWidget.currentRow(),self.compositeList[self.dlg.listWidget.currentRow()]['layers'][self.dlg.listWidget_listLayers2.currentRow()]['params']['LAYERS']))
        
       
        layers = QgsProject.instance().mapLayers().values()
        
        for i in range (0, len(self.compositeList)):
            self.dlg.listWidget.addItem(self.compositeList[i]['name'])
       # self.dlg.pushButton.setEnabled(False)
        self.dlg.listWidget.itemClicked.connect(self.listCompositeLayers)
        self.dlg.listWidget_listLayers2.itemClicked.connect(self.showThumbnail)   
        

       # self.dlg.listWidget_listMaps.itemClicked.connect(self.enableButton)    
        self.dlg.show()
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        result = self.dlg.exec_()
    def getActiveLayer(self):
        layer = iface.activeLayer()
        self.layerOldName = layer.name()
        QMessageBox.information(None, "Layman", self.layerOldName )
        self.focusedLayer = layer
    def initFiles(self):
        tempFileFolder = tempfile.gettempdir() + os.sep + "atlas"
        if not os.path.exists(tempFileFolder):
            os.makedirs(tempFileFolder)
        if os.path.exists(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt") == False:
            open(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt", "w").close
        if os.path.exists(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt") == False:
            open(tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt", "w").close
    def run_CreateCompositeDialog(self, fromImport = False, fromCurrent = False):
        self.recalculateDPI()
        self.dlg = CreateCompositeDialog()
        print(fromImport, fromCurrent)
        self.dlg.label_info.hide()
        self.dlg.label_2.hide()
        self.dlg.lineEdit.hide()
                      
        layers = QgsProject.instance().mapLayers().values()

        #self.dlg.rejected.connect(lambda: self.afterCloseEditMapDialog()) 
        self.dlg.treeWidget.itemClicked.connect(self.setExtent)
        for layer in layers:
           # self.dlg.listWidget_listLayers.addItem(layer.name())
            if (layer.type() == QgsMapLayer.VectorLayer):
                item = QTreeWidgetItem([layer.name()]) 
            
                    
                self.dlg.treeWidget.addTopLevelItem(item)
        ext = iface.mapCanvas().extent()
        self.dlg.lineEdit.setValidator(QRegExpValidator(QRegExp("[a-z]{1}[a-z0-9]{1,30}")))      
        self.dlg.lineEdit_3.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_4.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_5.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_6.setValidator(QRegExpValidator(QRegExp(r"^-?\d*[.,]?\d*$")))
        self.dlg.lineEdit_2.editingFinished.connect(self.checkNameCreateMap)
        self.dlg.lineEdit_2.textEdited.connect(self.checkForChars)

        projectPath = QgsProject.instance().fileName()
        if projectPath != "":
            projectName = os.path.basename(projectPath).split(".")[0]
            if projectName[0] in ["0","1","2","3","4","5","6","7","8","9"]:
                if self.locale == "cs":
                    QMessageBox.information(None, "Message", "Není povoleno číslo v prvník znaku titulku! Není možné předvyplnit název.")
                else:
                    QMessageBox.information(None, "Message", "Number in first character of title is not allowed! Title can not be prefilled.")            
            else:
                self.dlg.lineEdit_2.setText(projectName)
       
        
        
        self.dlg.lineEdit_3.setText(str(ext.xMinimum()))
        self.dlg.lineEdit_4.setText(str(ext.xMaximum()))
        self.dlg.lineEdit_5.setText(str(ext.yMinimum()))
        self.dlg.lineEdit_6.setText(str(ext.yMaximum()))
        self.dlg.pushButton_defaultExtent.clicked.connect(lambda: self.setDefaultExtent(ext))              
        self.dlg.pushButton_defaultExtent.setStyleSheet("#pushButton_defaultExtent {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_defaultExtent:hover{background: #66ab27 ;}#pushButton_defaultExtent:disabled{background: #64818b ;}")
        self.dlg.pushButton_CreateComposition.setStyleSheet("#pushButton_CreateComposition {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_CreateComposition:hover{background: #66ab27 ;}#pushButton_CreateComposition:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")

        
        
        #if (fromImport):
            #self.dlg.rejected.connect(lambda: self.afterCloseCompositeDialog())
        
        print("from current" + str(fromCurrent))
        if fromCurrent:  
            print("from current" + str(fromCurrent))
            self.dlg.rejected.connect(lambda: self.afterCloseNewMapDialog())
            self.dlg.pushButton_CreateComposition.clicked.connect(lambda: self.createComposite(self.dlg.lineEdit.text(),self.dlg.lineEdit_2.text(), True))
            self.dlg.pushButton_close.clicked.connect(lambda: self.afterCloseNewMapDialog())
        else:
            self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
            self.dlg.pushButton_CreateComposition.clicked.connect(lambda: self.createComposite(self.dlg.lineEdit.text(),self.dlg.lineEdit_2.text()))
        result = self.dlg.exec_()
        self.dlg.show()



    def run_ImportMapDialog(self):   
        self.recalculateDPI()
        try:
            self.timerLayer.timeout.disconnect()
        except:
            pass
        self.dlg = ImportMapDialog()
        self.dlg.label_import.hide()
        #self.dlg.radioButton_wms.setChecked(True)
        #self.dlg.radioButton_wfs.setChecked(False)
        self.dlg.label_5.hide()
        if self.locale == "cs":
            self.dlg.label_thumbnail.setText('          Náhled vrstvy')
        else:
            self.dlg.label_thumbnail.setText('          Layer preview')
        #self.dlg.listWidget_listLayers2.hide()
        self.dlg.pushButton_deleteMap.setEnabled(False)
        self.dlg.pushButton_editMeta.setEnabled(False)
        self.dlg.pushButton_addRaster.setEnabled(False)
        self.dlg.pushButton_up.setEnabled(False)
        self.dlg.pushButton_setMapPermissions.setEnabled(False)
        self.dlg.pushButton_down.setEnabled(False)
        self.dlg.pushButton_deleteLayers.setEnabled(False)
       # self.dlg.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.VectorLayer)
        self.dlg.pushButton.clicked.connect(lambda: self.addLayerToComposite(self.dlg.listWidget.currentRow()))   
        self.dlg.pushButton_deleteMap.clicked.connect(lambda: self.deleteMap(self.dlg.listWidget.currentItem().text(),self.dlg.listWidget.currentRow()))
       # self.dlg.pushButton_deleteMap.clicked.connect(lambda: self.deleteMapFromCanvas(self.dlg.listWidget.currentRow())) 
        self.dlg.pushButton_up.clicked.connect(lambda: self.reorderLayers(self.dlg.treeWidget_listLayers.indexOfTopLevelItem(self.dlg.treeWidget_listLayers.currentItem()), 1, self.dlg.listWidget.currentRow()))
        #self.dlg.pushButton_down.clicked.connect(lambda: self.reorderLayers(self.dlg.listWidget_listLayers.currentRow(), -1, self.dlg.listWidget.currentRow()))
        self.dlg.pushButton_down.clicked.connect(lambda: self.reorderLayers(self.dlg.treeWidget_listLayers.indexOfTopLevelItem(self.dlg.treeWidget_listLayers.currentItem()), -1, self.dlg.listWidget.currentRow()))
        
        self.dlg.pushButton_saveOrder.clicked.connect(lambda: self.saveReorder(self.dlg.listWidget.currentRow()))
        self.dlg.pushButton_setMapPermissions.clicked.connect(lambda: self.showMapPermissionsDialog(self.dlg.listWidget.currentItem().text()))
        
        #if not self.loadedInMemory:
        self.threadComposites = threading.Thread(target=self.loadCompositesThread)
        self.threadComposites.start()
        #else:
        #    self.loadCompositesThread()
        self.checkServiceAvailability()
        self.dlg.mMapLayerComboBox.currentIndexChanged.connect(lambda: self.checkServiceAvailability())
        self.dlg.pushButton_addMap.clicked.connect(lambda: self.showAddMapDialog())
        
        self.dlg.progressBar.hide()   
        self.dlg.pushButton_saveOrder.hide()
        self.dlg.label_6.hide()
        self.dlg.comboBox_wms.hide()
        self.dlg.pushButton_addWMS.hide()
        self.dlg.pushButton.setEnabled(False)
        self.dlg.pushButton.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'plus.png'))
        self.dlg.pushButton_addMap.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'plus.png'))
        self.dlg.pushButton_addRaster.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'plus.png'))
        self.dlg.pushButton_deleteLayers.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'minus.png'))
        self.dlg.pushButton_deleteMap.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'minus.png'))
        self.dlg.pushButton_editMeta.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'edit.png'))
        self.dlg.pushButton_setMapPermissions.setIcon(QIcon(self.plugin_dir + os.sep + 'icons' + os.sep + 'edit.png'))
        self.dlg.listWidget.itemClicked.connect(self.refreshLayerListReversed)
        self.dlg.listWidget.itemClicked.connect(lambda: self.dlg.pushButton_deleteMap.setEnabled(True))
        self.dlg.listWidget.itemClicked.connect(lambda: self.dlg.pushButton_editMeta.setEnabled(True))
        self.dlg.listWidget.itemClicked.connect(lambda: self.dlg.pushButton_addRaster.setEnabled(True))
        self.dlg.listWidget.itemClicked.connect(lambda: self.dlg.pushButton_up.setEnabled(True))
        self.dlg.listWidget.itemClicked.connect(lambda: self.dlg.pushButton_down.setEnabled(True))
        self.dlg.listWidget.itemClicked.connect(lambda: self.dlg.pushButton_setMapPermissions.setEnabled(True))
        #self.dlg.listWidget_listLayers.itemClicked.connect(lambda: self.dlg.pushButton_down.setEnabled(True))
        #self.dlg.listWidget_listLayers.itemClicked.connect(lambda: self.dlg.pushButton_up.setEnabled(True))
        #self.dlg.listWidget_listLayers.itemClicked.connect(lambda: self.dlg.pushButton_deleteLayers.setEnabled(True))
        self.dlg.treeWidget_listLayers.itemClicked.connect(lambda: self.dlg.pushButton_down.setEnabled(True))
        self.dlg.treeWidget_listLayers.itemClicked.connect(lambda: self.dlg.pushButton_up.setEnabled(True))
        self.dlg.treeWidget_listLayers.itemClicked.connect(lambda: self.dlg.pushButton_deleteLayers.setEnabled(True))
        self.dlg.listWidget.itemClicked.connect(lambda: self.setListLayer())

        self.dlg.rejected.connect(lambda: self.saveReorder())
        
       # self.dlg.setEnabled(False)
        #
        self.dlg.pushButton_addRaster.setEnabled(False)
        self.dlg.pushButton_addWMS.setEnabled(False)
        self.add = self.dlg.pushButton_addMap.isEnabled()
        self.deleteM = self.dlg.pushButton_deleteMap.isEnabled()
        self.editM = self.dlg.pushButton_editMeta.isEnabled()
        self.up = self.dlg.pushButton_up.isEnabled()
        self.down = self.dlg.pushButton_down.isEnabled()
        self.deleteL = self.dlg.pushButton_deleteLayers.isEnabled()
        self.post = self.dlg.pushButton.isEnabled()
        self.addR = self.dlg.pushButton_addRaster.isEnabled()
        self.importMapEnvironmnet(False)
       
        self.dlg.pushButton_editMeta.clicked.connect(lambda: self.showEditMapDialog(self.dlg.listWidget.currentRow()))
     ###########nacitam vrstvy z laymana do comboboxu
        self.loadExternalWMS()
        self.dlg.pushButton_addWMS.clicked.connect(lambda: self.addExternalWMSToComposite(self.dlg.comboBox_wms.currentText()))
        self.dlg.pushButton_addRaster.clicked.connect(lambda: self.addExistingLayerToComposite(self.dlg.comboBox_raster.currentText(), "raster"))
        #### nahrát mapy ze serveru do comboboxu
        self.dlg.comboBox_raster.currentIndexChanged.connect(lambda: self.dlg.pushButton_addRaster.setEnabled(True))
        
        self.dlg.pushButton_loadMap.clicked.connect(lambda: self.readMapJson(self.dlg.comboBox_loadMap.currentText(), 'WMS'))
        self.dlg.pushButton_loadMapWFS.clicked.connect(lambda: self.readMapJson(self.dlg.comboBox_loadMap.currentText(), 'WFS'))
        self.dlg.pushButton_loadMapWFS.hide()
        self.dlg.pushButton_loadMap.hide()
        self.dlg.comboBox_loadMap.hide()
     #############
        self.dlg.pushButton.setEnabled(False)
        self.dlg.pushButton_deleteLayers.setEnabled(False)
        self.dlg.treeWidget_listLayers.itemClicked.connect(self.showSmallThumbnail)
        self.dlg.treeWidget_listLayers.itemDoubleClicked.connect(self.wms_wfs)
      #  self.dlg.listWidget_listLayers.itemClicked.connect(self.showThumbnail)
        self.dlg.listWidget.itemClicked.connect(self.enableButton)          
        #self.dlg.pushButton_deleteLayers.clicked.connect(lambda: self.deteteLayerFromComposite(self.dlg.listWidget.currentRow(),self.dlg.listWidget_listLayers.currentRow(), self.dlg.listWidget_listLayers.currentItem().text()))    
        self.dlg.pushButton_deleteLayers.clicked.connect(lambda: self.deteteLayerFromComposite(self.dlg.listWidget.currentRow(),self.dlg.treeWidget_listLayers.indexOfTopLevelItem(self.dlg.treeWidget_listLayers.currentItem()), self.dlg.treeWidget_listLayers.selectedItems()[0].text(0)))    
       # self.form()
        self.dlg.show()
        self.dlg.progressBar_loader.show() 
        self.dlg.label_loading.show() 
        #self.dlg.pushButton_close.clicked.connect(lambda: self.saveReorder(self.dlg.listWidget.currentRow()))
        #self.dlg.pushButton_close.clicked.connect(lambda: self.saveReorder())
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_saveOrder.setEnabled(False)
        self.dlg.pushButton_down.setStyleSheet("#pushButton_down {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_down:hover{background: #66ab27 ;}#pushButton_down:disabled{background: #64818b ;}")
        self.dlg.pushButton_up.setStyleSheet("#pushButton_up {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_up:hover{background: #66ab27 ;}#pushButton_up:disabled{background: #64818b ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.pushButton_deleteLayers.setStyleSheet("#pushButton_deleteLayers {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_deleteLayers:hover{background: #66ab27 ;}#pushButton_deleteLayers:disabled{background: #64818b ;}")
        self.dlg.pushButton_deleteMap.setStyleSheet("#pushButton_deleteMap {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_deleteMap:hover{background: #66ab27 ;}#pushButton_deleteMap:disabled{background: #64818b ;}")
        self.dlg.pushButton_addRaster.setStyleSheet("#pushButton_addRaster {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addRaster:hover{background: #66ab27 ;}#pushButton_addRaster:disabled{background: #64818b ;}")
        self.dlg.pushButton_addMap.setStyleSheet("#pushButton_addMap {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addMap:hover{background: #66ab27 ;}#pushButton_addMap:disabled{background: #64818b ;}")
        self.dlg.pushButton_editMeta.setStyleSheet("#pushButton_editMeta {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_editMeta:hover{background: #66ab27 ;}#pushButton_editMeta:disabled{background: #64818b ;}")
        self.dlg.pushButton_loadMapWFS.setStyleSheet("#pushButton_loadMapWFS {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_loadMapWFS:hover{background: #66ab27 ;}#pushButton_loadMapWFS:disabled{background: #64818b ;}")
        self.dlg.pushButton_addWMS.setStyleSheet("#pushButton_addWMS {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_addWMS:hover{background: #66ab27 ;}#pushButton_addWMS:disabled{background: #64818b ;}")
        self.dlg.pushButton_loadMap.setStyleSheet("#pushButton_loadMap {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_loadMap:hover{background: #66ab27 ;}#pushButton_loadMap:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_saveOrder.setStyleSheet("#pushButton_saveOrder {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_saveOrder:hover{background: #66ab27 ;}#pushButton_saveOrder:disabled{background: #64818b ;}")
        self.dlg.pushButton_saveOrder.setStyleSheet("#pushButton_saveOrder {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_saveOrder:hover{background: #66ab27 ;}#pushButton_saveOrder:disabled{background: #64818b ;}")
        self.dlg.pushButton_setMapPermissions.setStyleSheet("#pushButton_setMapPermissions {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setMapPermissions:hover{background: #66ab27 ;}#pushButton_setMapPermissions:disabled{background: #64818b ;}")
        
        

        result = self.dlg.exec_()
    def importMapEnvironmnet(self,enabled):
        time.sleep(1)
        if enabled:
            
            self.dlg.pushButton_deleteMap.setEnabled(self.deleteM)
            self.dlg.pushButton_editMeta.setEnabled(self.editM)
            self.dlg.pushButton_setMapPermissions.setEnabled(self.editP)
            self.dlg.pushButton_up.setEnabled(self.up)
            self.dlg.pushButton_down.setEnabled(self.down)
            self.dlg.pushButton_deleteLayers.setEnabled(self.deleteL)
          #  self.dlg.pushButton.setEnabled(self.post)
            self.dlg.pushButton.setEnabled(True)
           # self.dlg.pushButton.setEnabled(True)
            try:
                self.dlg.pushButton_addMap.setEnabled(self.add)
                self.dlg.pushButton_addRaster.setEnabled(self.addR)
            except:
                pass
        else:
            self.add = self.dlg.pushButton_addMap.isEnabled()
            self.dlg.pushButton_addMap.setEnabled(False)
            self.deleteM = self.dlg.pushButton_deleteMap.isEnabled()
            self.dlg.pushButton_deleteMap.setEnabled(False)
            self.editM = self.dlg.pushButton_editMeta.isEnabled()
            self.editP = self.dlg.pushButton_setMapPermissions.isEnabled()
            self.dlg.pushButton_editMeta.setEnabled(False)
            self.dlg.pushButton_setMapPermissions.setEnabled(False)
            self.up = self.dlg.pushButton_up.isEnabled()
            self.dlg.pushButton_up.setEnabled(False)
            self.down = self.dlg.pushButton_down.isEnabled()
            self.dlg.pushButton_down.setEnabled(False)
            self.deleteL = self.dlg.pushButton_deleteLayers.isEnabled()
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.post = self.dlg.pushButton.isEnabled()
            self.dlg.pushButton.setEnabled(False)
            self.addR = self.dlg.pushButton_addRaster.isEnabled()
            self.dlg.pushButton_addRaster.setEnabled(False)

    def loadExternalWMS(self):
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            layerType = layer.type()    
            if layerType == QgsMapLayer.RasterLayer:
                if(str(layer)[-5:-2] == "wms"):
                   # if not (self.isXYZ(layer.name())):
                    self.dlg.comboBox_wms.addItem(layer.name())
                    #self.dlg.pushButton_addWMS.setEnabled(True)
                    self.WMSenable = True
                    
                else:
                    self.WMSenable = False

    def isNewCompositeAdded(self):
        reload = False
        url = self.URI+'/rest/'+self.laymanUsername+'/maps'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        res = self.fromByteToJson(r.content)
       
           
        lay = set()
        for i in range (0, len(self.compositeList)):
            lay.add(self.compositeList[i]['name'])
        for i in res: 
            if not i['name'] in lay:
                #print("founded")
                reload = True
   
        return reload
        
    def loadCompositesThread(self):
        #self.dlg.listWidget.setSelectionMode(QAbstractItemView.NoSelection)
        if not self.loadedInMemory:
            self.loadAllCompositesT() 
        else:            
            if (self.isNewCompositeAdded()):
                print("reload")
                self.loadAllCompositesT()                
                       
        layers = QgsProject.instance().mapLayers().values() 
        entries = list()
        for i in range (0, len(self.compositeList)):
           # if 'workspace' in self.compositeList['time']:
           # if self.compositeList[i]['workspace'] == self.laymanUsername:
            entries.append(self.compositeList[i]['title'])
        self.dlg.listWidget.addItems(entries)
        url = self.URI+'/rest/'+self.laymanUsername+'/layers'
        #print(url)
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        #print(r.content)
        try:
            data = r.json()
        except:
            QgsMessageLog.logMessage("errConnection")
        for row in range(0, len(data)):          
            #self.dlg.comboBox_raster.addItem(data[row]['name'])
            self.dlg.comboBox_raster.addItem(data[row]['title'])
            self.dlg.comboBox_raster.setCurrentIndex(0)
        url = self.URI+'/rest/'+self.laymanUsername+'/maps'
        try:
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        except:
            QgsMessageLog.logMessage("errConnection")
        data = r.json()
        
        for row in range(0, len(data)):            
            self.dlg.comboBox_loadMap.addItem(data[row]['name'])
        ##self.dlg.refresh()
        #self.dlg.listWidget.update()
        #self.refreshLayerList()
        #time.sleep(2)
        QgsMessageLog.logMessage("successLoadComp")
       # try:
       #     self.dlg.label_loading.hide() 
       #     self.dlg.progressBar_loader.hide() 
       #     #self.dlg.listWidget.setSelectionMode(QAbstractItemView.SingleSelection)
       #     self.importMapEnvironmnet(True)
       # except:
       #     pass
       ## self.dlg.setEnabled(True)
    def run_DeleteMapDialog(self):
        self.recalculateDPI()
        self.dlg = DeleteMapDialog()
        self.refreshListWidgetMaps()
        self.dlg.pushButton.setEnabled(False)
        self.dlg.treeWidget.itemClicked.connect(self.enableButton) 
        self.dlg.pushButton.clicked.connect(lambda: self.deleteMapFromServer(self.dlg.treeWidget.selectedItems()[0].text(0)))
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.show()
        result = self.dlg.exec_()
    def run_ImportLayerDialog(self):
        self.recalculateDPI()
        self.dlg = ImportLayerDialog()
        
      #  self.dlg.pushButton.clicked.connect(lambda: self.postRequest(self.dlg.treeWidget.currentItem().text(0)))

        self.dlg.pushButton.clicked.connect(lambda: self.callPostRequest(self.dlg.treeWidget.selectedItems()))
        if self.locale == "cs":
            self.dlg.label_progress.setText("Úspěšně exportováno: 0 / 0")
        else:
            self.dlg.label_progress.setText("Sucessfully exported: 0 / 0")
        self.dlg.progressBar.hide() 
        self.dlg.label_import.hide()
        self.dlg.pushButton.setEnabled(False)
       # self.dlg.treeWidget.itemClicked.connect(self.enableButton)  
        self.dlg.treeWidget.itemPressed.connect(self.enableButtonImport)
        #self.dlg.treeWidget.itemClicked.connect(self.onItemClicked)
        self.dlg.treeWidget.itemSelectionChanged.connect(lambda: self.disableExport())
        self.dlg.treeWidget.setCurrentItem(self.dlg.treeWidget.topLevelItem(0),0)
        layers = QgsProject.instance().mapLayers().values()
        mix = list()
        for layer in layers:           
            if (layer.type() == QgsMapLayer.VectorLayer):
                layerType = 'vector layer'
            else:
                layerType = 'raster layer'            
            item = QTreeWidgetItem([layer.name(), layerType]) 
           # print(layer.name())
            #print(self.mixedLayers)
            #print(mix)
            if (layerType == 'vector layer'):
                if (layer.name() in self.mixedLayers and layer.name() in mix):
                    pass
                elif (layer.name() in self.mixedLayers and layer.name() not in mix):
                    self.dlg.treeWidget.addTopLevelItem(item)
                    mix.append(layer.name())
                else:
                    self.dlg.treeWidget.addTopLevelItem(item)
            if (layerType == 'raster layer'):
                self.dlg.treeWidget.addTopLevelItem(item)
        self.dlg.setWindowModality(Qt.ApplicationModal)

        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.selectSelectedLayer()
        self.dlg.show()
        #self.dlg.rejected.connect(lambda: self.setBatchLengthZero()) 
        
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        result = self.dlg.exec_()
    def setBatchLengthZero(self):
        self.batchLength = 0
    def run_login(self):
        self.recalculateDPI()
        
        
        self.dlg = ConnectionManagerDialog()
      
        self.dlg.show()
        #self.dlg.pushButton_Dependencies.hide()
        if not self.dependencies:
            self.dlg.pushButton_Connect.hide()
           # self.dlg.pushButton_Dependencies.show()
            self.dlg.comboBox_server.setEnabled(False)
            self.dlg.lineEdit_userName.setEnabled(False) 
        self.dlg.pushButton_Connect.setEnabled(False) 
       # self.dlg.pushButton_Dependencies.clicked.connect(lambda: self.install())
        path = self.plugin_dir + os.sep + "server_list.txt"
        servers = self.csvToArray(path)
        self.dlg.label_APIKey_2.setToolTip("Username is important only with first login")
        #print(servers)
        
        for i in range (0,len(servers)):
          #  print(servers[i][0])
            
            if i == len(servers) - 1: ## vyjimka pro alias na test server bude ostraneno
                self.dlg.comboBox_server.addItem("test HUB")
            else:
                self.dlg.comboBox_server.addItem(servers[i][0].replace("www.", "").replace("https://", ""))
        if self.laymanUsername == "":
            self.setServers(servers, 0) ## nastavujeme prvni server 
        self.dlg.comboBox_server.currentIndexChanged.connect(lambda: self.setServers(servers, self.dlg.comboBox_server.currentIndex()))
        if (os.path.isfile(os.getenv("HOME") + os.sep + ".layman" + os.sep +'layman_user.INI')):
            config = self.loadIni()
            if len(config['DEFAULT']['login']) > 0:
                self.Agrimail = config['DEFAULT']['login']
                self.dlg.pushButton_Connect.setEnabled(True) 
            #self.dlg.lineEdit_userName.setText(config['DEFAULT']['login'] + "@lesprojekt.cz")  
            self.dlg.lineEdit_userName.setText(config['DEFAULT']['login'])  
            
            for i in range (0, self.dlg.comboBox_server.count()):                
                #print(self.dlg.comboBox_server.itemText(i))
                print(self.authCfg)
                if self.authCfg == "a67e5fd":
                    self.dlg.comboBox_server.setCurrentIndex(len(servers) - 1)
                else:
                    if(self.dlg.comboBox_server.itemText(i) == config['DEFAULT']['server'].replace("www.", "").replace("https://", "")):
                        self.dlg.comboBox_server.setCurrentIndex(i)
            #self.dlg.lineEdit_AgriID.setText(config['DEFAULT']['id']) 
            #self.dlg.lineEdit_server.setText(config['DEFAULT']['server']) 
           # self.dlg.lineEdit_serverLayman.setText(config['DEFAULT']['layman']) 
            #except:
             #   print("udaj v ini nenalezen")
        else:
            try:
                os.makedirs(os.getenv("HOME") + os.sep + ".layman")
            except:
                print("layman directory already exists")
            #self.dlg.lineEdit_userName.setText("@lesprojekt.cz")
            self.dlg.pushButton_Connect.setEnabled(True) 
       

        
        self.dlg.lineEdit_userName.textChanged.connect(self.checkUsername)
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_Connect.clicked.connect(lambda: self.openAuthLiferayUrl2())
        self.dlg.pushButton_Continue.clicked.connect(lambda: self.getToken())
        
        self.dlg.pushButton_NoLogin.clicked.connect(lambda: self.withoutLogin(servers, self.dlg.comboBox_server.currentIndex()))
        self.dlg.pushButton_Continue.setEnabled(False)    
        registerSuffix = "/home?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&saveLastPath=false&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Fcreate_account"
        self.dlg.comboBox_server.currentTextChanged.connect(self.setReg)
        self.dlg.label_sign.setOpenExternalLinks(True)
        if self.locale == "cs":
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Registrovat</a>')
        else:
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Register</a>')
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}")
        self.dlg.pushButton_Connect.setStyleSheet("#pushButton_Connect {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_Connect:hover{background: #66ab27 ;}#pushButton_Connect:disabled{background: #64818b ;}")
        self.dlg.pushButton_Continue.setStyleSheet("#pushButton_Continue {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_Continue:hover{background: #66ab27 ;} #pushButton_Continue:disabled{background: #64818b ;}")
        #self.dlg.pushButton_Dependencies.setStyleSheet("#pushButton_Dependencies {color: #fff !important;text-transform: uppercase;  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_Dependencies:hover{background: #66ab27 ;} #pushButton_Dependencies:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_NoLogin.setStyleSheet("#pushButton_NoLogin {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_NoLogin:hover{background: #66ab27 ;}#pushButton_NoLogin:disabled{background: #64818b ;}")
        self.dlg.pushButton_logout.setStyleSheet("#pushButton_logout {color: #fff !important;font-size:"+self.fontSize+";text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_logout:hover{background: #66ab27 ;}#pushButton_logout:disabled{background: #64818b ;}")
        self.dlg.pushButton_logout.clicked.connect(lambda: self.logout())        
        print(self.laymanUsername == "")
        if self.laymanUsername != "":
            self.dlg.pushButton_logout.setEnabled(True)
            self.dlg.pushButton_NoLogin.setEnabled(False)
            self.dlg.pushButton_Connect.setEnabled(False)
            self.dlg.comboBox_server.setEnabled(False)
            self.dlg.lineEdit_userName.setEnabled(False)    
            if self.locale == "cs":
                self.dlg.setWindowTitle("Layman - Přihlášený uživatel: " + self.laymanUsername)
            else:
                self.dlg.setWindowTitle("Layman - Logged user: " + self.laymanUsername)
            
        else:
            self.dlg.pushButton_logout.setEnabled(False)
            self.dlg.pushButton_NoLogin.setEnabled(True)
            self.dlg.pushButton_Connect.setEnabled(True)
            self.dlg.comboBox_server.setEnabled(True)
            self.dlg.lineEdit_userName.setEnabled(True)     
            
        result = self.dlg.exec_()
        self.dlg.rejected.connect(lambda: self.loginReject())
    def run_AddMapDialog(self):
        self.recalculateDPI()
        self.dlg = AddMapDialog()      
        
        
        self.dlg.pushButton.setEnabled(False)
        self.dlg.pushButton_mapWFS.setEnabled(False)
        self.dlg.pushButton_mapWFS.setEnabled(True)
        self.dlg.pushButton.hide()
        self.dlg.pushButton_mapWFS.hide()
        self.dlg.label_info.hide()     
        self.dlg.treeWidget.itemClicked.connect(self.showThumbnailMap)
        self.dlg.treeWidget.itemClicked.connect(self.enableButton)
        self.dlg.treeWidget.itemClicked.connect(self.enableLoadMapButtons)
        self.dlg.treeWidget.itemClicked.connect(self.setPermissionsButton)
        self.dlg.treeWidget.setColumnWidth(0, 300)
        self.dlg.treeWidget.setColumnWidth(2, 80)
        self.dlg.label_noUser.hide()
        

        self.dlg.pushButton.clicked.connect(lambda: self.readMapJson(self.dlg.treeWidget.selectedItems()[0].text(0), 'WMS'))
        self.dlg.pushButton_mapWFS.clicked.connect(lambda: self.readMapJson(self.dlg.treeWidget.selectedItems()[0].text(0), 'WFS'))
        self.dlg.pushButton_map.clicked.connect(lambda: QgsMessageLog.logMessage("showLoader"))
        self.dlg.pushButton_map.clicked.connect(lambda: self.readMapJson(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)), 'WFS', self.dlg.treeWidget.selectedItems()[0].text(1)))
        self.dlg.pushButton_setPermissions.clicked.connect(lambda: self.showMapPermissionsDialog(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)), True))
        if not self.isAuthorized:
            self.dlg.checkBox_own.setEnabled(False)
        else:
            self.dlg.checkBox_own.setEnabled(True)
        self.dlg.pushButton_delete.clicked.connect(lambda: self.deleteMap(self.getNameByTitle(self.dlg.treeWidget.selectedItems()[0].text(0)),self.getCompositionIndexByName(self.dlg.treeWidget.selectedItems()[0].text(0))))
        self.dlg.filter.valueChanged.connect(self.filterResults)
        self.dlg.filter.valueChanged.connect(self.disableButtonsAddMap)
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        self.dlg.pushButton_map.setStyleSheet("#pushButton_map {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_map:hover{background: #66ab27 ;}#pushButton_map:disabled{background: #64818b ;}")
        self.dlg.pushButton_mapWFS.setStyleSheet("#pushButton_mapWFS {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_mapWFS:hover{background: #66ab27 ;}#pushButton_mapWFS:disabled{background: #64818b ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_setPermissions.setStyleSheet("#pushButton_setPermissions {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setPermissions:hover{background: #66ab27 ;}#pushButton_setPermissions:disabled{background: #64818b ;}")
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #66ab27 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.checkBox_own.stateChanged.connect(self.loadMapsThread)
        self.dlg.checkBox_own.stateChanged.connect(self.disableButtonsAddMap)
        self.dlg.checkBox_own.stateChanged.connect(self.rememberValueMap)
        self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.pushButton_map.setEnabled(False)
        self.dlg.show()
        self.dlg.progressBar_loader.show() 
        self.dlg.label_loading.show() 
        if not self.isAuthorized:
            self.dlg.label_noUser.show()
        try:
            checked = self.getConfigItem("mapcheckbox")          
            print(checked)
        except:
            checked = False
        if checked == "0":
            self.dlg.checkBox_own.setCheckState(0)
            checked = False
        if checked == "1":
            self.dlg.checkBox_own.setCheckState(2)
            checked = True
        threading.Thread(target=lambda: self.loadMapsThread(checked)).start()       
       
        result = self.dlg.exec_()
    def setExtentFromLayers(self):
        
        composition = self.instance.getComposition()
        xmin = None
        xmax = None
        ymin = None
        ymax = None
        initRun = True
        url = self.URI+'/client/geoserver/'+self.laymanUsername+'/ows?service=wms&version=1.1.1&request=GetCapabilities'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        #print(r.content)
        names = list()
        renge = list()
        tree = ET.ElementTree(ET.fromstring(r.content))
        root = tree.getroot()
        for name in  root.findall("./Capability/Layer/Layer/Name"):
            #print(name.tag,name.attrib, name.text)
            names.append(name.text)    
        for name in  root.findall("./Capability/Layer/Layer/LatLonBoundingBox"):
            #print(name.tag,name.attrib, name.text)    
            renge.append(name.attrib)
        for i in range(len(composition['layers'])): 
            className = composition['layers'][i]['className']     
            if className == 'HSLayers.Layer.WMS' or 'OpenLayers.Layer.Vector':
                name = self.removeUnacceptableChars(composition['layers'][i]['title'])
            #    url = self.compositeList['layers'][x]['url']
            #if className == 'OpenLayers.Layer.Vector': 
            #    url = self.compositeList['layers'][x]['params']['LAYERS']
                
            #url = "https://hub.lesprojekt.cz/geoserver/jan_vrobel_wms/ows?service=wms&version=1.1.1&request=GetCapabilities"
            
                
                #print(r.content)
                #print(len(names))    
                #print(len(renge)) 
                #print(renge[0]['maxy'])
                #print(renge[0]['maxx'])
                #print(renge[0]['miny'])
                #print(renge[0]['minx'])
                print(len(names))
                print(names)
                print(name)
                for i in range (0, len(names)):                    
                    if names[i] == name:
                        print("matched")
                        if initRun:
                            ymax = renge[i]['maxy']
                            xmax = renge[i]['maxx']
                            ymin = renge[i]['miny']
                            xmin = renge[i]['minx']  
                            initRun = False
                        if renge[i]['maxy'] > ymax:
                            print("maxy" + ymax ,renge[i]['maxy'] )
                            ymax = renge[i]['maxy']
                        if renge[i]['maxx'] > xmax:
                            print("maxx" + xmax, renge[i]['maxx'] )
                            xmax = renge[i]['maxx']
                        if renge[i]['miny'] < ymin:
                            print("miny"+ ymin, renge[i]['miny'])
                            ymin = renge[i]['miny']
                        if renge[i]['minx'] < xmin:
                            print("minx"+ xmin, renge[i]['minx'] )
                            xmin = renge[i]['minx']   
        if (xmin == None or xmax == None or ymin == None or ymax==None):
            if self.locale == "cs":                
                QMessageBox.information(None, "Layman", "Záznam prostorového rozsahu vrstev vybrané kompozice nebyl nalezen!")
            else:
                QMessageBox.information(None, "Layman", "A record of the layers spatial extent for the selected composition was not found!")
        else:
            self.dlg.lineEdit_xmin.setText(str(xmin))
            self.dlg.lineEdit_xmax.setText(str(xmax))
            self.dlg.lineEdit_ymin.setText(str(ymin))
            self.dlg.lineEdit_ymax.setText(str(ymax))
                
    def setRangeFromCanvas(self):
        ext = self.iface.mapCanvas().extent()
        self.dlg.lineEdit_xmin.setText(str(ext.xMinimum()))
        self.dlg.lineEdit_xmax.setText(str(ext.xMaximum()))
        self.dlg.lineEdit_ymin.setText(str(ext.yMinimum()))
        self.dlg.lineEdit_ymax.setText(str(ext.yMaximum()))
    def withoutLogin(self, servers, i):
        self.menu_CurrentCompositionDialog.setEnabled(False)
        self.isAuthorized = False
        self.URI = servers[i][1]
        self.menu_AddLayerDialog.setEnabled(True) 
        #self.menu_Connection.setEnabled(False)
        self.laymanUsername = "Anonymous"        
        self.dlg.pushButton_logout.setEnabled(True)
        self.dlg.pushButton_NoLogin.setEnabled(False)
        self.dlg.pushButton_Connect.setEnabled(False)
        self.menu_UserInfoDialog.setEnabled(True)
        self.menu_AddMapDialog.setEnabled(True)    
        threading.Thread(target=lambda: self.fillCompositionDict()).start()
        self.dlg.close()
    def rememberValueLayer(self, value):
        ## 2 true, 0 false
        if value == 2:
            self.appendIniItem("layerCheckbox", "1")
        if value == 0:
            self.appendIniItem("layerCheckbox", "0")
    def rememberValueMap(self, value):
        ## 2 true, 0 false
        if value == 2:
            self.appendIniItem("mapCheckbox", "1")
        if value == 0:
            self.appendIniItem("mapCheckbox", "0")
    def checkAllLayers(self, checked):
        if checked:
            iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()  
                item.setCheckState(0,2)
                print(item.text(0))
                self.layerServices[self.removeUnacceptableChars(item.text(0))] = "HSLayers.Layer.WMS"
                iterator +=1
            #for index in range(0, self.dlg.listWidget_layers.count()):
            #    item = self.dlg.listWidget_layers.item(index)
            #    item.setCheckState(2)
            #    item.setCheckState(2)
            #    print(item.text())
            #    self.layerServices[self.removeUnacceptableChars(item.text())] = "HSLayers.Layer.WMS"

        if not checked:
            iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
            while iterator.value():
                item = iterator.value()  
                item.setCheckState(0,0)
                print(item.text(0))
                self.layerServices = {}
                iterator +=1
            #for index in range(0, self.dlg.listWidget_layers.count()):
            #    item = self.dlg.listWidget_layers.item(index)
            #    item.setCheckState(0)
            #    self.layerServices = {}
        #print(self.layerServices)
    def fillCompositionDict(self):
        url = self.URI+'/rest/maps'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        dataAll = r.json()
        for row in range(0, len(dataAll)):
            self.compositionDict[dataAll[row]['name']] = dataAll[row]['title']
        #print(self.compositionDict)
    def getNameByTitle(self, val):
        print(self.compositionDict)
        for key, value in self.compositionDict.items():
             if val == value:
                 print(key)
                 return key         
    def loadMapsThread(self, onlyOwn):      
        print("pez")
        self.dlg.treeWidget.clear()       
        url = self.URI+'/rest/'+self.laymanUsername+'/maps?order_by=title'      
      
        r = requests.get(url = url,  headers = self.getAuthHeader(self.authCfg))
        data = r.json()
       #print(data)
        if onlyOwn and self.isAuthorized:
            for row in range(0, len(data)):  
                if "native_crs" in data[row]:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own", data[row]['native_crs']])
                else:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own"])
                self.dlg.treeWidget.addTopLevelItem(item)
            QgsMessageLog.logMessage("loadMaps")
        elif not self.isAuthorized:
            url = self.URI+'/rest/maps?order_by=title'                    
            r = requests.get(url = url,  headers = self.getAuthHeader(self.authCfg))
            dataAll = r.json()
            permissions = ""
            for row in range(0, len(dataAll)): 
                if "native_crs" in dataAll[row]:
                    item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],"read", dataAll[row]['native_crs']])
                else:
                    item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],"read"])
                self.dlg.treeWidget.addTopLevelItem(item)
        else:
            url = self.URI+'/rest/maps?order_by=title'           
            r = requests.get(url = url,  headers = self.getAuthHeader(self.authCfg))
            dataAll = r.json()         
            permissions = ""
            for row in range(0, len(dataAll)):
                if self.laymanUsername in dataAll[row]['access_rights']['read'] or "EVERYONE" in dataAll[row]['access_rights']['read']:
                    permissions = "read"
                if self.laymanUsername in dataAll[row]['access_rights']['write'] or "EVERYONE" in dataAll[row]['access_rights']['write']:
                    permissions = "write"
                if dataAll[row] in data:
                    permissions = "own"
                if permissions != "":
                    if "native_crs" in dataAll[row]:
                        item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions, dataAll[row]['native_crs']])
                    else:
                        item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions])
                    print(dataAll[row]['title'])
                    self.dlg.treeWidget.addTopLevelItem(item)
        QgsMessageLog.logMessage("loadMaps")
        
    def run_AddLayerDialog(self):
        self.recalculateDPI()
        
        self.dlg = AddLayerDialog()
        self.dlg.pushButton_layerRedirect.hide()
        self.dlg.pushButton_layerRedirect.setEnabled(False)
        self.dlg.pushButton_urlWfs.setEnabled(False)
        self.dlg.pushButton_urlWms.setEnabled(False)
        self.dlg.pushButton.setEnabled(False)
        self.dlg.pushButton_wfs.setEnabled(False)
        self.dlg.pushButton_delete.setEnabled(False)
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.label_noUser.hide()
        try:
            checked = self.getConfigItem("layercheckbox")
            print("tst")
            print(checked)
        except:
            checked = False
        if checked == "0":
            self.dlg.checkBox_own.setCheckState(0)
            checked = False
        if checked == "1":
            self.dlg.checkBox_own.setCheckState(2)
            checked = True
        #self.dlg.pushButton_delete.clicked.connect(lambda: self.layerDelete(self.dlg.treeWidget.selectedItems()[0].text(0)))    
        self.dlg.pushButton_delete.clicked.connect(lambda: self.callDeleteLayer(self.dlg.treeWidget.selectedItems()))    
        self.dlg.pushButton_layerRedirect.clicked.connect(lambda: self.layerInfoRedirect(self.dlg.treeWidget.selectedItems()[0].text(0)))
        self.dlg.pushButton.clicked.connect(lambda: self.readLayerJson(self.dlg.treeWidget.selectedItems(), "WMS"))
        self.dlg.pushButton_wfs.clicked.connect(lambda: self.readLayerJson(self.dlg.treeWidget.selectedItems(), "WFS"))
        self.dlg.pushButton_urlWms.clicked.connect(lambda: self.copyLayerUrl(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.selectedItems()[0].text(1),"wms"))
        self.dlg.pushButton_urlWfs.clicked.connect(lambda: self.copyLayerUrl(self.dlg.treeWidget.selectedItems()[0].text(0),self.dlg.treeWidget.selectedItems()[0].text(1),"wfs"))
        if not self.isAuthorized:
            self.dlg.label_noUser.show()
            self.dlg.checkBox_own.setEnabled(False)
        self.dlg.treeWidget.itemClicked.connect(self.enableDeleteButton) 
        self.dlg.treeWidget.itemSelectionChanged.connect(self.checkSelectedCount)
        self.dlg.treeWidget.itemClicked.connect(self.setPermissionsButton)
        self.dlg.treeWidget.itemClicked.connect(self.showThumbnail)
        self.dlg.filter.valueChanged.connect(self.filterResults)
        self.dlg.treeWidget.setColumnWidth(0, 300)
        self.dlg.treeWidget.setColumnWidth(2, 80)
        self.dlg.pushButton_close.clicked.connect(lambda: self.dlg.close())
        #self.dlg.setWindowModality(Qt.ApplicationModal)
        self.dlg.checkBox_own.stateChanged.connect(self.rememberValueLayer)
        self.dlg.pushButton_setPermissions.clicked.connect(lambda: self.showPermissionsDialog(self.dlg.treeWidget.selectedItems()))
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #66ab27 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.pushButton_close.setStyleSheet("#pushButton_close {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_close:hover{background: #66ab27 ;}#pushButton_close:disabled{background: #64818b ;}")
        self.dlg.pushButton_delete.setStyleSheet("#pushButton_delete {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_delete:hover{background: #66ab27 ;}#pushButton_delete:disabled{background: #64818b ;}")
        self.dlg.pushButton.setStyleSheet("#pushButton {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton:hover{background: #66ab27 ;}#pushButton:disabled{background: #64818b ;}")
        self.dlg.pushButton_wfs.setStyleSheet("#pushButton_wfs {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_wfs:hover{background: #66ab27 ;}#pushButton_wfs:disabled{background: #64818b ;}")
        self.dlg.setStyleSheet("#DialogBase {background: #f0f0f0 ;}")
        self.dlg.pushButton_setPermissions.setStyleSheet("#pushButton_setPermissions {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+";  text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_setPermissions:hover{background: #66ab27 ;}#pushButton_setPermissions:disabled{background: #64818b ;}")
        self.dlg.pushButton_urlWms.setStyleSheet("#pushButton_urlWms {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+"; text-decoration: none;   background: #999999;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_urlWms:hover{background: #707070 ;}#pushButton_urlWms:disabled{background: #999999 ;}")
        self.dlg.pushButton_urlWfs.setStyleSheet("#pushButton_urlWfs {color: #fff !important;text-transform: uppercase;font-size:"+self.fontSize+"; text-decoration: none;   background: #999999;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} #pushButton_urlWfs:hover{background: #707070 ;}#pushButton_urlWfs:disabled{background: #999999 ;}")
        self.threadLayers = threading.Thread(target=lambda: self.loadLayersThread(checked))
        self.threadLayers.start()
        self.dlg.checkBox_own.stateChanged.connect(self.loadLayersThread)
        #self.iface.layerTreeView().currentLayerChanged.connect(lambda: self.selectSelectedLayer())
        if self.isAuthorized:
            self.dlg.checkBox_own.setEnabled(True)    
        else:
            self.dlg.checkBox_own.setEnabled(False)   
        self.dlg.progressBar_loader.show() 
        self.dlg.label_loading.show() 
        self.dlg.show()
        result = self.dlg.exec_()

    def loadLayersThread(self, onlyOwn=False):
        ##if not self.loadedInMemory:
        ##    self.loadAllComposites()
        #url = self.URI+'/rest/'+self.laymanUsername+'/layers'
        #r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))    
        #data = r.json()
        
        #for row in range(0, len(data)): 
           
            
        #    try:

        #        item = QTreeWidgetItem([data[row]['title']])    
                
        #        title = data[row]['title']
        #        if title == None or title == "" or title == "null":
        #            item = QTreeWidgetItem([data[row]['name']])       
        #        self.dlg.treeWidget.addTopLevelItem(item)               
                
        #    except:
               
        #        item = QTreeWidgetItem([self.getLayerTitle(data[row]['name'])])
        #        self.dlg.treeWidget.addTopLevelItem(item)
        #QgsMessageLog.logMessage("layersLoaded")
        self.dlg.treeWidget.clear()
        if self.laymanUsername and self.isAuthorized:
            url = self.URI+'/rest/'+self.laymanUsername+'/layers'
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            data = r.json()
            if onlyOwn:
                for row in range(0, len(data)):     
                    #print(data[row]['native_crs'])
                    if "native_crs" in data[row]:
                        item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own",data[row]['native_crs']])
                    else:
                        item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],"own"])
                    self.dlg.treeWidget.addTopLevelItem(item)
                QgsMessageLog.logMessage("layersLoaded")
            else:
                url = self.URI+'/rest/layers'
                r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                dataAll = r.json()
                permissions = ""
                for row in range(0, len(dataAll)):
                    if self.laymanUsername in dataAll[row]['access_rights']['read'] or "EVERYONE" in dataAll[row]['access_rights']['read']:
                        permissions = "read"
                    if self.laymanUsername in dataAll[row]['access_rights']['write'] or "EVERYONE" in dataAll[row]['access_rights']['write']:
                        permissions = "write"
                    if dataAll[row] in data:
                        permissions = "own"
                    if permissions != "":
                        if "native_crs" in dataAll[row]:
                            item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions,dataAll[row]['native_crs']])
                        else:
                            item = QTreeWidgetItem([dataAll[row]['title'],dataAll[row]['workspace'],permissions])
                        self.dlg.treeWidget.addTopLevelItem(item)
                QgsMessageLog.logMessage("layersLoaded")
        else:
           # self.URI = "https://hub.lesprojekt.cz"
            url = self.URI+'/rest/layers'
            r = requests.get(url = url)
            data = r.json()
            for row in range(0, len(data)):
                if "EVERYONE" in data[row]['access_rights']['read']:
                    permissions = "read"
                if "EVERYONE" in data[row]['access_rights']['write']:
                    permissions = "write"
                if "native_crs" in dataAll[row]:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],permissions,data[row]['native_crs']])
                else:
                    item = QTreeWidgetItem([data[row]['title'],data[row]['workspace'],permissions])
                self.dlg.treeWidget.addTopLevelItem(item)
            QgsMessageLog.logMessage("layersLoaded")
    def addExternalWMSToComposite(self, name):
        #layer = QgsProject.instance().mapLayersByName(name)[0]
        #params = layer.dataProvider().dataSourceUri().split("&")
        #layers = list()
        #for p in params:
        #    #print(p)
        #    param = p.split("=")                
        #    if(str(param[0]) == "crs"):
        #        crs = (param[1])
        #    if(str(param[0]) == "format"):
        #        format = (param[1])   
        #        print(format)
        #    if(str(param[0]) == "url"):
        #        url = (param[1])   
        #        print(url) 
        #    if(str(param[0]) == "layers"):
        #        layers.append(param[1])   
        #     #   print(layers)    
       
        #self.addExistingLayerToComposite(name, "wms")
        nameInList = name
        name = self.removeUnacceptableChars(name).lower()
        threading.Thread(target=lambda: self.addExistingWMSLayerToCompositeThread2(name, nameInList)).start()
    def listToString(self, s):     
       
        str1 = "," 
        return (str1.join(s)) 
    def checkAddedItemDuplicity(self, type):
        itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
        itemsTextListWrite =  [str(self.dlg.listWidget_write.item(i).text()) for i in range(self.dlg.listWidget_write.count())]
        print(itemsTextListWrite)
        print(self.dlg.comboBox_users.currentText().split(' , ')[0])
        if type == "read":
            if ((self.dlg.comboBox_users.currentText().split(' , ')[0] not in itemsTextListRead)):
            
                self.dlg.listWidget_read.addItem(self.dlg.comboBox_users.currentText().split(' , ')[0])
                return True
            else:
                print("xx")
                if self.locale == "cs":                
                    QMessageBox.information(None, "Layman", "Tento uživatel se již v seznamu vyskytuje!")
                else:
                    QMessageBox.information(None, "Layman", "This user already exists in the list!")
                return False
        else:
            if ((self.dlg.comboBox_users.currentText().split(' , ')[0] not in itemsTextListWrite) and type == "write"):
              #  self.dlg.listWidget_write.addItem(self.dlg.comboBox_users.currentText().split(' , ')[0])
                return True
            else:
                print("yy")
                if self.locale == "cs":                
                    QMessageBox.information(None, "Layman", "Tento uživatel se již v seznamu vyskytuje!")
                else:
                    QMessageBox.information(None, "Layman", "This user already exists in the list!")
                return False
    def askForMapPermissionChanges(self,layerName, userDict, type):
        self.failed = list()
        self.statusHelper = True
        included = False
        for name in layerName:
            if (self.checkLayersInComopsitions(name)):
                included = True
        if (included):
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Nastavení práv", "Vybrané vrstvy jsou obsaženy v existujících mapových kompozicích. Chcete nastavit stejná práva i pro tyto dotčené kompozice?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Update permissions", "Selected layers are included in existing map compositions. Do you want set same permissions for these affected map compositions?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):
                threading.Thread(target=lambda: self.updatePermissions(layerName, userDict, type, True)).start()
            else:
                threading.Thread(target=lambda: self.updatePermissions(layerName, userDict, type, False)).start()
        else:
            threading.Thread(target=lambda: self.updatePermissions(layerName, userDict, type)).start()
    def askForLayerPermissionChanges(self,layerName, userDict, type):
        self.failed = list()
        self.statusHelper = True
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Nastavení práv", "Chcete tato práva nastavit i na jednotlivé vrstvy, které mapová kompozice obsahuje?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Update permissions", "Do you want set these permissions to layers included in map composition?")
        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            #threading.Thread(target=lambda: self.updatePermissions(layerName,userDict,type, True)).start()
            threading.Thread(target=lambda: self.updatePermissions(layerName,userDict,type, False)).start()
            threading.Thread(target=lambda: self.updateAllLayersPermission(userDict)).start()
        else:
            threading.Thread(target=lambda: self.updatePermissions(layerName,userDict,type, False)).start()
    def updateAllLayersPermission(self, userDict):
        composition = self.instance.getComposition()
        itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
        itemsTextListWrite =  [str(self.dlg.listWidget_write.item(i).text()) for i in range(self.dlg.listWidget_write.count())]
        userNamesRead = list()
        for pom in itemsTextListRead:
           # print(pom)
            if pom == "VŠICHNI":      
                
                userNamesRead.append("EVERYONE")
            #print(pom)
            else:
                userNamesRead.append(userDict[pom])
        userNamesWrite = list()
        #userNamesWrite.append(self.laymanUsername)
        for pom in itemsTextListWrite:
            if pom == "VŠICHNI":
                userNamesWrite.append("EVERYONE")
            else:
                userNamesWrite.append(userDict[pom])
        data = {'access_rights.read': self.listToString(userNamesRead),   'access_rights.write': self.listToString(userNamesWrite)}
        for layer in composition['layers']:
            print(layer)
            if (layer['className'] == 'OpenLayers.Layer.Vector'):
                name = layer['protocol']['LAYERS']
            if (layer['className'] == 'HSLayers.Layer.WMS'):
                name = layer['params']['LAYERS']
            response = requests.patch(self.URI+'/rest/'+self.laymanUsername+'/layers/'+name, data = data,  headers = self.getAuthHeader(self.authCfg))
            print(response.content)
    def updatePermissions(self,layerName, userDict, type, check=False):
        
        itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
        itemsTextListWrite =  [str(self.dlg.listWidget_write.item(i).text()) for i in range(self.dlg.listWidget_write.count())]
        userNamesRead = list()
        #userNamesRead.append(self.laymanUsername)
        for pom in itemsTextListRead:
           # print(pom)
            if pom == "VŠICHNI":      
                
                userNamesRead.append("EVERYONE")
            #print(pom)
            else:
                userNamesRead.append(userDict[pom])
        userNamesWrite = list()
        #userNamesWrite.append(self.laymanUsername)
        for pom in itemsTextListWrite:
            if pom == "VŠICHNI":
                userNamesWrite.append("EVERYONE")
            else:
                userNamesWrite.append(userDict[pom])
        data = {'access_rights.read': self.listToString(userNamesRead),   'access_rights.write': self.listToString(userNamesWrite)}
        #data = {'access_rights':  read}
        print(data)
       # print(data)
        
        for layer in layerName:
            layer = self.removeUnacceptableChars(layer)
            #print(layer)
            #print(self.URI+'/rest/'+self.laymanUsername+'/'+type+'/'+layer)
            print(self.URI+'/rest/'+self.laymanUsername+'/'+type+'/'+layer)
            response = requests.patch(self.URI+'/rest/'+self.laymanUsername+'/'+type+'/'+layer, data = data,  headers = self.getAuthHeader(self.authCfg))
            print(response.content)
            print(response.status_code)
            if (response.status_code != 200):
                self.failed.append(layer)
                self.statusHelper = False
        ## rekurzivni zmeny
        if (type == "maps" and check):
            
            if self.statusHelper:
                layerList = list()
                for i in range (0,len(self.compositeList)):
                    if self.compositeList[i]['name'] == self.removeUnacceptableChars(layerName[0]):  
                        for j in range (0,len(self.compositeList[i]['layers'])):
                            if self.compositeList[i]['layers'][j]['className'] == "HSLayers.Layer.WMS":
                                layerList.append(self.compositeList[i]['layers'][j]['params']['LAYERS'])
                            if self.compositeList[i]['layers'][j]['className'] == "OpenLayers.Layer.Vector":
                                #layerList.append(self.compositeList[i]['layers'][j]['name'])
                                #layerList.append(self.compositeList[i]['layers'][j]['protocol']['LAYERS'])
                                layerList.append(self.removeUnacceptableChars(self.compositeList[i]['layers'][j]['title']))
                self.updatePermissions(layerList,userDict, "layers")
                return
            else:
                
                QgsMessageLog.logMessage("permissionsDoneF")

        elif (type == "layers" and check):
            for name in layerName:
                compositionList = self.getCompositionsByLayer(name)
                for comp in compositionList:
                    self.updatePermissions([comp],userDict, "maps", False)
                    return
        # konec
        #if (status):
        #    if self.locale == "cs":                
        #        QMessageBox.information(None, "Uloženo", "Práva byla úspěšně uložena.")
        #    else:
        #        QMessageBox.information(None, "Saved", "Permissions was saved successfully.")
        #else:
        #    if self.locale == "cs":
        #        QMessageBox.information(None, "Chyba", "Práva nebyla uložena!")               
        #    else:
        #        QMessageBox.information(None, "Error", "Permissions was not saved!")  
        else:
            if (self.statusHelper):               
                QgsMessageLog.logMessage("permissionsDoneT")
            else:
                QgsMessageLog.logMessage("permissionsDoneF")
    def disableExport(self):
        #print(self.dlg.treeWidget.currentItem())
       # print(self.dlg.treeWidget.selectedItems())
        if self.dlg.treeWidget.selectedItems() == []:
            self.dlg.pushButton.setEnabled(False)
        else:
            self.dlg.pushButton.setEnabled(True)
    def disableButtonsAddMap(self):
        self.dlg.pushButton_setPermissions.setEnabled(False)
        self.dlg.pushButton_delete.setEnabled(False)
    def filterResults(self, value):
        
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if value.lower() not in item.text(0).lower():
                item.setHidden(True)
            else:
                item.setHidden(False)
                #self.dlg.treeWidget.setCurrentItem(item, 1)
            iterator +=1
    def showExistingLayers(self,x):
 
        self.dlg.listWidget_listLayers.clear()    
        for i in range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])):         
               
            self.dlg.listWidget_listLayers.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
    #--------------------------- slots---------------------
   # @QtCore.pyqtSlot(QtWidgets.QTreeWidgetItem, int)
    def onItemClicked(self, it, col):     
        if (it.text(1) == 'raster layer'):
            self.dlg.pushButton.setEnabled(True)
        else:
            self.dlg.pushButton.setEnabled(True)
    def setExtent(self, it, col):
        layer = QgsProject.instance().mapLayersByName(it.text(0))
        ext = layer[0].extent()
        print(ext)
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        if QgsProject.instance().crs().authid() == 'EPSG:5514' and layer[0].crs().authid() == 'EPSG:4326':
            print(xmin ,xmax, ymin, ymax)
            max = self.krovakToWgs(xmax, ymax)
            min = self.krovakToWgs(xmin, ymin)
            xmin = min[0]
            xmax = max[0]
            ymin = min[1]
            ymax = max[1]
        if QgsProject.instance().crs().authid() == 'EPSG:4326' and layer[0].crs().authid() == 'EPSG:5514':  
            max = self.wgsToKrovak(xmax, ymax)
            min = self.wgsToKrovak(xmin, ymin)
            xmin = min[0]
            xmax = max[0]
            ymin = min[1]
            ymax = max[1]          
        self.dlg.lineEdit_3.setText(str(xmin))
        self.dlg.lineEdit_4.setText(str(xmax))
        self.dlg.lineEdit_5.setText(str(ymin))
        self.dlg.lineEdit_6.setText(str(ymax))
        if self.locale == "cs":
            self.dlg.label_4.setText("Rozsah vrstvy: " + it.text(0))
        else:
            self.dlg.label_4.setText("Extent of layer: " + it.text(0))
    def wgsToKrovak(self, x, y):  
        src = QgsCoordinateReferenceSystem(5514)
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        point = tform.transform(QgsPointXY(x, y))      
        return [point.x(), point.y()] 
    def krovakToWgs(self, x, y):  
        src = QgsCoordinateReferenceSystem(4326)
        dest = QgsCoordinateReferenceSystem(5514)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        point = tform.transform(QgsPointXY(x, y))      
        return [point.x(), point.y()]
    def selectSelectedLayer(self):
        try:
            layer = self.iface.activeLayer()
            layerName = layer.name()
        except:
            print("no layer in list")
            return
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()
            if item.text(0) == layerName:
                self.dlg.treeWidget.setCurrentItem(item, 1)
            iterator +=1
 

    def checkPermissionButtons(self):      
        try:
            if self.dlg.listWidget_read.currentItem().text() == self.name:
                self.dlg.pushButton_removeRead.setEnabled(False)
            else:
                self.dlg.pushButton_removeRead.setEnabled(True)
        except:
            self.dlg.pushButton_removeRead.setEnabled(False)
            print("neni vybrana polozka")
        try:
            if self.dlg.listWidget_write.currentItem().text() == self.name:
                self.dlg.pushButton_removeWrite.setEnabled(False)
            else:
                self.dlg.pushButton_removeWrite.setEnabled(True)
        except:
            self.dlg.pushButton_removeWrite.setEnabled(False)
            print("neni vybrana polozka")
        
    def checkSelectedCount(self):
        if (len(self.dlg.treeWidget.selectedItems()) > 1):
            self.dlg.pushButton_setPermissions.setEnabled(True)
            self.dlg.pushButton_wfs.setEnabled(True)
            self.dlg.pushButton_delete.setEnabled(True)
            self.dlg.pushButton.setEnabled(True)
        else:
            self.dlg.pushButton_setPermissions.setEnabled(True)
            self.dlg.pushButton_wfs.setEnabled(True)
            self.dlg.pushButton_delete.setEnabled(True)
            self.dlg.pushButton.setEnabled(True)
        
    def enableDeleteButton(self, item, col):
        self.dlg.pushButton.setEnabled(True)
        self.dlg.pushButton_urlWfs.setEnabled(True)
        self.dlg.pushButton_urlWms.setEnabled(True)
        self.dlg.pushButton_wfs.setEnabled(True)
        self.dlg.pushButton_layerRedirect.setEnabled(True)
        self.dlg.pushButton_delete.setEnabled(True)
        self.dlg.pushButton_setPermissions.setEnabled(True)
        self.checkSelectedCount()

    def enableButton(self, item, col):
        
        
        self.dlg.pushButton.setEnabled(True)
        self.dlg.pushButton_mapWFS.setEnabled(True)
       # self.dlg.pushButton_map.setEnabled(True)
        self.dlg.pushButton_deleteLayers.setEnabled(True)
        self.dlg.pushButton_editMeta.setEnabled(True)
        self.dlg.pushButton_setMapPermissions.setEnabled(True)
        self.dlg.pushButton_addRaster.setEnabled(True)   
        try:
            if (self.WMSenable):
                self.dlg.pushButton_addWMS.setEnabled(True)
        except:
            pass

    def saveReorder(self):
        for x in self.mapsChanged:
           
            #self.importMap(x, 'mov')
            self.patchMap(x)
        print("changes saved to server")
        #self.dlg.pushButton_saveOrder.setEnabled(False)
        #try:
        #    self.timerLayer = QTimer()
        #    self.timerLayer.setInterval(10000)
        #    self.timerLayer.timeout.connect(lambda: self.syncOrder(iface.mapCanvas().layers())) 
        #    self.timerLayer.start()
        #    print("starting timer")
        #except:
        #    print("timer exception")
    def getVersion(self):
        config = configparser.ConfigParser()
        config.read(os.path.join(self.plugin_dir ,'metadata.txt'))
        version = config.get('general', 'version')
        return(version)
    def checkUsername(self, name):
        n = name.split("@")
        if(len(n[0]) > 0):
            self.dlg.pushButton_Connect.setEnabled(True) 
            #self.Agrimail = n[0]
            self.Agrimail = name
        else:
            self.dlg.pushButton_Connect.setEnabled(False) 

    def setListLayer(self):
        #count = self.dlg.listWidget_listLayers.count()
        count = self.dlg.treeWidget_listLayers.topLevelItemCount()
        if count == 0:
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.dlg.pushButton_up.setEnabled(False)
            self.dlg.pushButton_down.setEnabled(False)
        else:
            #self.dlg.listWidget_listLayers.setCurrentRow(0)
            self.dlg.treeWidget_listLayers.setCurrentItem(self.dlg.treeWidget_listLayers.topLevelItem(0),0)
            self.dlg.pushButton_deleteLayers.setEnabled(True)
            self.dlg.pushButton_up.setEnabled(True)
            self.dlg.pushButton_down.setEnabled(True)
    def checkLoadedMap(self, name):
       
        loaded = False
        for i in range (0, len(self.compositeList)):
            if self.compositeList[i]['name'] == name:
                loaded = True
            
        return loaded 
                   
    def csvToArray(self, path):
        results = []
        with open(path) as csvfile:
            reader = csv.reader(csvfile,delimiter=',') # change contents to floats
            for row in reader: # each row is a list
                results.append(row)
        return results
    def copyLayerUrl(self, name, workspace, service):
        url = self.URI+'/rest/'+workspace+'/layers/'+self.removeUnacceptableChars(name) 
        response = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        res = self.fromByteToJson(response.content)
        if res == None:
            return
        print(res)
        try:
            df=pd.DataFrame([res[service]['url']])
            df.to_clipboard(index=False,header=False)    
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL uloženo do schránky."), Qgis.Success, duration=3)               
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL saved to clipboard."), Qgis.Success, duration=3)
        except:
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL nebylo uloženo do schránky."), Qgis.Warning, duration=3)               
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " URL was not saved to clipboard."), Qgis.Warning, duration=3)
            
        
        
        
    def setReg(self, str):
        registerSuffix = "/home?p_p_id=com_liferay_login_web_portlet_LoginPortlet&p_p_lifecycle=0&p_p_state=maximized&p_p_mode=view&saveLastPath=false&_com_liferay_login_web_portlet_LoginPortlet_mvcRenderCommandName=%2Flogin%2Fcreate_account"
        if self.locale == "cs":
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Registrovat</a>')
        else:
            self.dlg.label_sign.setText('<a href="https://'+self.dlg.comboBox_server.currentText().replace('https://','').replace('home','')+registerSuffix+'">Register</a>')
    def loginReject(self):        
        
        if self.dlg.pushButton_Continue.isEnabled():
            self.getToken()
        else:            
            self.dlg.close()
    def logout(self):
        self.disableEnvironment()
        self.textbox.setText("Layman")
        userEndpoint = self.URI+ "/rest/current-user"    
        r = requests.delete(url = userEndpoint, headers = self.getAuthHeader(self.authCfg))
        QgsApplication.authManager().clearCachedConfig(self.authCfg)
        self.dlg.close()
        self.textbox.setText("Layman")
        ## flush variables
        self.loadedInMemory = False
        #QgsApplication.authManager().clearCachedConfig("")
        try:
            self.dlg.pushButton_NoLogin.setEnabled(True)
            self.dlg.pushButton_Connect.setEnabled(True)
        except:
            pass
        try:
            QgsProject.instance().crsChanged.disconnect()            
        except:
            print("crs changed not connected")            
        self.menu_UserInfoDialog.setEnabled(True)
        self.laymanUsername = ""
        self.isAuthorized = False
        self.current = None
        self.liferayServer = None
        #self.menu_Connection.setEnabled(True)
        self.compositeList = []
        self.compositeListOld = []       
       # self.thread1.join() ## ukončujeme vlákno, které se stará o refresh tokenů OAUTH
    def disableEnvironment(self):
        self.menu_saveLocalFile.setEnabled(False)
        self.menu_loadJson.setEnabled(False)
        self.menu_ImportLayerDialog.setEnabled(False)
        self.menu_AddLayerDialog.setEnabled(False) 
        self.menu_AddMapDialog.setEnabled(False)       
        self.menu_ImportLayerDialog.setEnabled(False)
        #self.menu_ImportMapDialog.setEnabled(False)    
        self.menu_UserInfoDialog.setEnabled(False)
        self.menu_CurrentCompositionDialog.setEnabled(False)
    def setServers(self, servers, i):        
        self.URI = servers[i][1]
        self.liferayServer = servers[i][0]
        self.client_id = servers[i][2]
        try:
            self.client_secret = servers[i][3]
            self.authCfg = servers[i][4]
        except:
            pass # old version compatibility
      
    def enableLoadMapButtons(self, item):
        self.dlg.pushButton_mapWFS.setEnabled(True)
        self.dlg.pushButton_map.setEnabled(True)
    def setPermissionsButton(self, item):    
        if item.text(2) != "own":
            self.dlg.pushButton_setPermissions.setEnabled(False)
            self.dlg.pushButton_delete.setEnabled(False)
        else:
            self.dlg.pushButton_setPermissions.setEnabled(True)
            self.dlg.pushButton_delete.setEnabled(True)
    def enableButtonImport(self, item, column):
        if (len(self.dlg.treeWidget.selectedItems()) > 0):
            self.dlg.pushButton.setEnabled(True)
        else:
            self.dlg.pushButton.setEnabled(False)


    def enableButton(self, item):
        try:
            if (self.WMSenable):
                self.dlg.pushButton_addWMS.setEnabled(True)
        except:
            pass
        try: ## addMap nemá combobox
            if (self.dlg.mMapLayerComboBox.count() > 0):
                #self.dlg.pushButton.setEnabled(True) 
                #self.dlg.pushButton_mapWFS.setEnabled(True)
                self.dlg.pushButton_map.setEnabled(True)
            else:
                self.dlg.pushButton.setEnabled(False)
        except:
            self.dlg.pushButton.setEnabled(True) ## addMap nemá combobox nastavujeme funkční tlačítko

        #try:
        #    self.dlg.pushButton_deleteLayers.setEnabled(True) # pro formulář importMap
        #except:
        #    pass
    def listCompositeLayers(self, it):    
         self.dlg.listWidget_listLayers2.clear()    
         for i in range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])):    
            
            self.dlg.listWidget_listLayers2.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
    def deleteLayerThrowCompositions(self, name, title):
        
        name = self.removeUnacceptableChars(name).lower()
        for x in range (0,len(self.compositeList)):
            
            for i in range (0,len(self.compositeList[x]['layers'])): 
                 try: 
                     if (name == self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['title'])):
                        inComposite = True
                        print("inComposite")
                 
                    
                        threading.Thread(target=lambda: self.deteteLayerFromCompositeThread(x, i, name, title)).start()
                 except:
                     print("nesprávný formát kompozice: " + name)
    def checkLayersInComopsitions(self, name):
        name = self.removeUnacceptableChars(name)
        #print("remove" + name)
        inComposite = False
        for x in range (0,len(self.compositeList)):           
            for i in range (0,len(self.compositeList[x]['layers'])): 
                try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                    if (name == self.compositeList[x]['layers'][i]['params']['LAYERS']):
                        inComposite = True                      
                except:
                    pass
                try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                    if (name == self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['name'])):
                        inComposite = True                      
                except:
                    pass
        return inComposite
    def checkLayerInCurrentCompositon(self, name):
        composition = self.instance.getComposition()
        inComposite = False

        for i in range (0,len(composition['layers'])): 
            try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                if (name == composition['layers'][i]['params']['LAYERS']):
                    inComposite = True                      
            except:
                pass
            try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                if (name == composition['layers'][i]['protocol']['LAYERS']):
                    inComposite = True                      
            except:
                pass
        return inComposite
    def getCompositionsByLayer(self, name):
        compositionList = list()
        for x in range (0,len(self.compositeList)):
            for i in range (0,len(self.compositeList[x]['layers'])):
                #try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                #    if (name == self.compositeList[x]['layers'][i]['params']['LAYERS']):
                #        compositionList.append(self.compositeList[x]['name'])                      
                #except:
                #    print("chyba pri parovani jmena")
                #try: ## osetreni pokud neni vrstva v korektnim tvaru na laymanu - apliakce nespadne
                #    #if (name == self.compositeList[x]['layers'][i]['protocol']['LAYERS']):
                #    if (name == self.compositeList[x]['layers'][i]['name']):
                #        compositionList.append(self.compositeList[x]['name'])                     
                #except:
                #    print("chyba pri parovani jmena")
                if (self.removeUnacceptableChars(name) == self.removeUnacceptableChars(self.compositeList[x]['layers'][i]['title'])):
                    compositionList.append(self.compositeList[x]['name'])     
        return compositionList

    def refreshCompositeList(self, new=False):
        try:
            self.dlg.listWidget.clear()
        except:
            return 
        
        
        for i in range (0, len(self.compositeList)):
           # self.dlg.listWidget.addItem(self.compositeList[i]['name'])
           self.dlg.listWidget.addItem(self.compositeList[i]['title'])
        if new:
            self.dlg.listWidget.setCurrentRow(self.dlg.listWidget.count() -1)
            self.dlg.pushButton_deleteMap.setEnabled(True)
            self.dlg.pushButton_editMeta.setEnabled(True)
            self.dlg.pushButton_setMapPermissions.setEnabled(True)
            self.dlg.pushButton_down.setEnabled(False)
            self.dlg.pushButton_up.setEnabled(False)
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.dlg.listWidget_listLayers.clear()
            self.dlg.treeWidget_listLayers.clear()
         

    def refreshLayerList(self):
        #self.dlg.listWidget_listLayers.clear()
        self.dlg.treeWidget_listLayers.clear()       
        for i in (range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers']))):
            #self.dlg.listWidget_listLayers.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
            item = QTreeWidgetItem([self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'],self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['className'] ])
            self.dlg.treeWidget_listLayers.addTopLevelItem(item)
            #print(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])

    def refreshLayerListNonReversed(self):
        #self.dlg.listWidget_listLayers.clear()
        self.dlg.treeWidget_listLayers.clear()   
        for i in range (0,len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])):
            item = QTreeWidgetItem([self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['title'],self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['className'] ])
            self.dlg.treeWidget_listLayers.addTopLevelItem(item)
            #self.dlg.listWidget_listLayers.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
    #        print(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
    def refreshLayerListReversed(self):
        #self.dlg.listWidget_listLayers.clear()
        self.dlg.treeWidget_listLayers.clear() 
        for i in range (len(self.compositeList[self.dlg.listWidget.currentRow()]['layers'])-1,-1,-1):
            #self.dlg.listWidget_listLayers.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
            item = QTreeWidgetItem([self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['title'],self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['className'] ])
            self.dlg.treeWidget_listLayers.addTopLevelItem(item)
            #self.dlg.listWidget_listLayers.addItem(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['title'])
            #print(self.compositeList[self.dlg.listWidget.currentRow()]['layers'][i]['params']['LAYERS'])
        try:         
            self.dlg.treeWidget_listLayers.setCurrentItem(self.dlg.treeWidget_listLayers.topLevelItem(0),0)
            #self.dlg.listWidget_listLayers.setCurrentRow(0)
        except:
            self.dlg.pushButton_deleteLayers.setEnabled(False)
            self.dlg.pushButton_up.setEnabled(False)
            self.dlg.pushButton_down.setEnabled(False)
    def transformLayer(self, layer):
        path = tempFile = tempfile.gettempdir() + os.sep + layer.name()
        parameter = {'INPUT': layer, 'TARGET_CRS': 'EPSG:4326', 'OUTPUT': path}
        processing.run('qgis:reprojectlayer', parameter)
        return path
    def refreshListWidgetMaps(self):
        self.dlg.treeWidget.clear()
        url = self.URI+'/rest/'+self.laymanUsername+'/maps'
      
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        
        data = r.json()  
       
        for row in range(0, len(data)):                
            item = QTreeWidgetItem([data[row]['name']])           
            self.dlg.treeWidget.addTopLevelItem(item)

    def showAddMapDialog(self, fromCurrent=False):
        self.old_dlg = self.dlg
        self.run_CreateCompositeDialog(True, fromCurrent)      
        
       
    ### connect
    def afterCloseCompositeDialog(self):        
        self.dlg = self.old_dlg
        self.refreshCompositeList()
    def afterCloseCurrentMapDialog(self):
        self.dlg = self.old_dlg
       
    def afterCloseEditMapDialog(self):
        self.dlg = self.old_dlg
        self.refreshCompositeList()
    def afterCloseNewMapDialog(self):
        self.dlg.close()
        self.dlg = self.old_dlg
        self.dlg.close()
        self.run_CurrentCompositionDialog()
    def afterClosePermissionMapDialog(self):   
        self.dlg = self.old_dlg
        
    def showMapPermissionsDialog(self, x, fromAddMap = False): 
        if fromAddMap:
            self.dlg.pushButton_map.setEnabled(True)
            self.dlg.progressBar_loader.hide()
        self.old_dlg = self.dlg        
        self.run_SetMapPermission(x, fromAddMap)
    def showPermissionsDialog(self, x):        
        self.old_dlg = self.dlg
        names = list() 
        for i in range (0, len(self.dlg.treeWidget.selectedItems())):
            names.append(self.dlg.treeWidget.selectedItems()[i].text(0))  
        self.run_SetPermission(names)
    def showEditMapDialog(self, x):        
        self.old_dlg = self.dlg
        if x:
            self.run_EditMap(x)
        else:
            self.run_EditCurrentMap()
            ############### pravdepodobne půjde smazat
    def refreshItems(self):
  
         self.dlg.listWidget_listLayers.clear()    
         for i in range (0,len(self.compositeList)):            
           # self.dlg.listWidget_listLayers.addItem(self.compositeList[i]['name'])
           self.dlg.listWidget_listLayers.addItem(self.compositeList[i]['title'])

    def saveEditedToComposite(self,x):        
        self.compositeList[x]['abstract'] =  self.dlg.lineEdit_abstract.text()  
        self.compositeList[x]['title'] =  self.dlg.lineEdit_title.text() 
    def callDeleteLayer(self, layers):
        #print("len" + str(len(layers)))
        items = list()
        for i in range (0, len(self.dlg.treeWidget.selectedItems())):
            items.append(self.dlg.treeWidget.selectedItems()[i].text(0))
        print(items)
        for j in range (0, len(items)):
            self.layerDelete(items[j])
    def layerDelete(self, name):
        title = name
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Chcete opravdu smazat vrstvu "+str(name)+"?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Do you want delete layer "+str(name)+"?")
        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            if (self.checkLayersInComopsitions(name) == True):
                if self.locale == "cs":
                    msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "Tato vrstva je obsažena v některých mapových kompozicích. Pokud budete pokračovat, bude smazána také z těchto kompozic.")
                else:
                    msgbox = QMessageBox(QMessageBox.Question, "Delete layer", "This layers is included in other compositions. It will be deleted from every composition.")
                msgbox.addButton(QMessageBox.Yes)
                msgbox.addButton(QMessageBox.No)
                msgbox.setDefaultButton(QMessageBox.No)
                reply = msgbox.exec()                
                if (reply == QMessageBox.Yes):                   
                    name = self.removeUnacceptableChars(name).lower()   
                    threading.Thread(target=lambda: self.layerDeleteThread(name)).start()
                    self.dlg.progressBar_loader.show() 
                    #try:
                    self.deleteLayerThrowCompositions(name, title)
                    #except:
                    #    pass                
            else:    
                name = self.removeUnacceptableChars(name).lower()   
                threading.Thread(target=lambda: self.layerDeleteThread(name)).start()
                self.dlg.progressBar_loader.show() 
            
          
    def layerDeleteThread(self, name):       
        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name    
        response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))
     
        #self.deleteItemFromTreeWidget(name)
        try:
            checked = self.getConfigItem("layercheckbox")            
        except:
            checked = False
        if checked == "0":         
            checked = False
        if checked == "1":            
            checked = True
        self.loadLayersThread(checked)
      
        if response.status_code == 200:
            QgsMessageLog.logMessage("delLay")
        else:
            QgsMessageLog.logMessage("delLayErr")
    def deleteItemFromTreeWidget(self,name):
        #print(name)
        iterator= QTreeWidgetItemIterator(self.dlg.treeWidget);
        items = []
        while iterator.value():
            item = iterator.value()
            iterator+=1           
            if (self.removeUnacceptableChars(item.text(0)) == self.removeUnacceptableChars(name)):
                print("vyhodit")
            else:
                items.append(item.text(0))
        self.dlg.treeWidget.clear()
        for i in items:
            item = QTreeWidgetItem([i])
            self.dlg.treeWidget.addTopLevelItem(item)
       
    #def syncOrder(self, layers):
    #    print("sync order")
        
    #   # print("syncOrder################")         
    #    x = self.getCompositionIndexByName()
    #    if not (self.checkCompositionChanges(x, layers)):
        
    #        backup = copy.deepcopy(self.compositeList[x])        
    #        #print(self.compositeList[x])
    #        #print(backup)
    #        self.compositeList[x]['layers'] = []
    #        #layers = prj.mapLayers().values()       
    #        usedLayers = list()
    #        for layer in layers:           
    #            #print(str(len(backup['layers'])))            
    #            for i in range (0,len(backup['layers'])):  
    #                name = self.removeUnacceptableChars(backup['layers'][i]['title'])
    #               # print(name, self.removeUnacceptableChars(layer.name()))
    #                if name == self.removeUnacceptableChars(layer.name()) and name not in usedLayers:
    #                    print(name)
    #                    self.compositeList[x]['layers'].append(backup['layers'][i])
    #                    usedLayers.append(layer.name())
    #       # print(self.compositeList[x])
    #        #print(backup['layers'] != self.compositeList[x]['layers'])
    #        #print(len(backup['layers']), len(self.compositeList[x]['layers']) )

    #        if backup['layers'] != self.compositeList[x]['layers'] and len(backup['layers']) == len(self.compositeList[x]['layers'] ):
    #            print("saving order")
    #            self.patchMap(x)
    #            #self.importMap(x, 'mov')
    #            #threading.Thread(target=lambda: self.importMap(x, 'mov')).start()
    #        if len(self.compositeList[x]['layers']) == 0:
    #            self.compositeList[x]['layers'] = backup['layers']

    #        #print("syncOrder################") 
    #def syncOrder(self, layers):       
    #    print("sync order")
    #    print(layers)
    def syncOrder2(self, layers):
        serverOrder = self.instance.getLayerNamesList()
        composition = self.instance.getComposition()
        backup = copy.deepcopy(composition) 
        composition['layers'] = []
        print(serverOrder)
        for layer in layers:  
            if self.removeUnacceptableChars(layer.name()) in serverOrder:
                print(layer.name())
                for lay in backup['layers']:
                    if self.removeUnacceptableChars(layer.name()) == self.removeUnacceptableChars(lay['title']):
                        composition['layers'].append(lay)
        if len(serverOrder) != len(composition['layers']):
            composition = copy.deepcopy(backup)
            print("změna pořadí selhala vracím zpět.")
        print("order changed to:")
        print(composition['layers'])
       

    def syncOrder(self, layers): # vyhledove odstranit
        #return ## treba doaldit
        print("sync order")
        print(layers)
        
       # print("syncOrder################")         
       # x = self.getCompositionIndexByName()
        if not (self.checkCompositionChanges(layers)):
            composition = self.instance.getComposition()
            backup = copy.deepcopy(composition)        
            #print(self.compositeList[x])
            #print(backup)
            composition['layers'] = []
            #layers = prj.mapLayers().values()       
            usedLayers = list()
            for layer in layers:           
                #print(str(len(backup['layers'])))            
                for i in range (0,len(backup['layers'])):  
                    name = self.removeUnacceptableChars(backup['layers'][i]['title'])
                   # print(name, self.removeUnacceptableChars(layer.name()))
                    if name == self.removeUnacceptableChars(layer.name()) and name not in usedLayers:
                        print(name)
                        composition['layers'].append(backup['layers'][i])
                        usedLayers.append(layer.name())
           # print(self.compositeList[x])
            #print(backup['layers'] != self.compositeList[x]['layers'])
            #print(len(backup['layers']), len(self.compositeList[x]['layers']) )

            if backup['layers'] != composition['layers'] and len(backup['layers']) == len(composition['layers']):
                print("saving order")
                print("####")
                print("order before")
                for i in range (0,len(backup['layers'])):
                    print(backup['layers'][i]['title'])
                print("order after")
                for i in range (0,len(backup['layers'])):
                    print(composition['layers'][i]['title'])
                print("####")
                #self.patchMap2()
                #self.importMap(x, 'mov')
                #threading.Thread(target=lambda: self.importMap(x, 'mov')).start()
            elif len(composition['layers']) == 0 or len(composition['layers']) != len(backup['layers']):
                print("syncOrder rollback")
                composition['layers'] = backup['layers']
           

            #print("syncOrder################") 
    def updateComposition(self, checkD = True):
        self.currentSet = list()
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        try:
            while iterator.value():
                item = iterator.value()                
                self.currentSet.append([item.text(0),self.dlg.treeWidget_layers.itemWidget(item,1).currentText(),self.dlg.treeWidget_layers.itemWidget(item,2).currentText()])
                iterator +=1
        except:
            print("neni v canvasu")
        print(self.currentSet)
        self.ThreadsUploadsA = set()
        for thread in threading.enumerate(): 
            self.ThreadsUploadsA.add(thread.name)
        #if checkD: 
        #    decision = self.checkIfLayersExists()
        #    if decision:
        #        return
        #self.differentThanBefore() zvýraznit
        if self.duplicateLayers():
            if self.locale == "cs":
                QMessageBox.information(None, "Warning", "Duplicita v názvech vrstev!")
            else:
                QMessageBox.information(None, "Warning", "Duplicity in layer names!")
            return
        
        ## hlidani nove pridanych vrstev pro symbologii
        #self.syncOrder2(self.getLayersOrder())
        composition = self.instance.getComposition()
        layerList = []
        for i in range (0, len(composition['layers'])):                        
            layerList.append(self.removeUnacceptableChars(composition['layers'][i]['title']))      
            print(composition['layers'][i]['title'])
        layers = list()    
        
        iterator = QTreeWidgetItemIterator(self.dlg.treeWidget_layers, QTreeWidgetItemIterator.All)
        while iterator.value():
            item = iterator.value()    
            self.itemClick(item,0) ## check for subgroups        
            if item.checkState(0) == 2 and  self.removeUnacceptableChars(item.text(0)) not in layerList: 
                print(item.text(0))
                lay = QgsProject.instance().mapLayersByName(item.text(0))[0]
                lay.styleChanged.connect(self.layerStyleToUpdate)  
            iterator +=1

        #for index in range(0, self.dlg.listWidget_layers.count()):
        #    item = self.dlg.listWidget_layers.item(index)
        #    if item.checkState() == 2 and  self.removeUnacceptableChars(item.text()) not in layerList: 
        #        print(item.text())
        #        lay = QgsProject.instance().mapLayersByName(item.text())[0]
        #        lay.styleChanged.connect(self.layerStyleToUpdate)     
        threading.Thread(target=lambda: self.updateCompositionThread()).start()
        
        


        self.dlg.progressBar_loader.show()
        self.dlg.pushButton_save.setEnabled(False)
    def updateVisibilityInComposition(self):        
        composition = self.instance.getComposition()
        root = QgsProject.instance().layerTreeRoot()
        sublayers = root.children()
        #print(sublayers)
        for lay in composition['layers']:
            for sublayer in sublayers:    
                #print(sublayer)
                if isinstance(sublayer, QgsLayerTreeLayer):
                    #print(sublayer.isVisible())                   
                    if self.removeUnacceptableChars(sublayer.name()) == self.removeUnacceptableChars(lay['title']):
                       # print(sublayer.name() + " QgsLayerTreeLayer modify")
                        self.modifyPathOfLayer(sublayer.name(),"")
                        self.modifyVisibilityOfLayer(sublayer.name(),sublayer.isVisible())
                        #print(sublayer.isVisible())
                        #print(sublayer.name())
                   # sublayer.visibilityChanged.connect(changeVisibility)
                if isinstance(sublayer, QgsLayerTreeGroup):                    
                    for layer in sublayer.findLayers():                        
                        if self.removeUnacceptableChars(layer.name()) == self.removeUnacceptableChars(lay['title']):
                           # print(sublayer.name() + " QgsLayerTreeGroup modify")
                            self.modifyPathOfLayer(layer.name(),sublayer.name())
                            self.modifyVisibilityOfLayer(layer.name(),layer.isVisible() )
                            #print(layer.isVisible())
                            #print(layer.name())
        #print(composition)
        
    def updateCompositionThread(self): 
        composition = self.instance.getComposition()  
        
        i= 0
        for item in self.currentSet:
            service = self.instance.getServiceForLayer(item[0])
            if service == "HSLayers.Layer.WMS" and item[1] == "WFS":
                self.wms_wfs3(item[0], i, item[1])
                pass
            if service == "OpenLayers.Layer.Vector" and item[1] == "WMS":
                self.wms_wfs3(item[0], i, item[1])
            i = i +1
        #if self.modified == True:
        if True:
            self.saveMapLayers()
            self.modified = False
        else:
            composition = self.instance.getComposition()
            #print(composition != self.backupComposition)
            if composition != self.backupComposition:
                print("composition will be updated")
                self.backupComposition = copy.deepcopy(composition)   
                
        if len(self.stylesToUpdate) > 0:                     
            layerList = set()
            for layer in self.stylesToUpdate:
                layerList.add(self.removeUnacceptableChars(layer.name()))
            for lay in composition['layers']:
                if self.removeUnacceptableChars(lay['title']) in layerList:
                    try:
                        self.updateLayerStyle(lay['title'], lay['workspace'])
                    except:
                        self.updateLayerStyle(lay['title'], self.laymanUsername) ## pokud je starší typ kompozice
                    try:
                        self.stylesToUpdate.remove(QgsProject.instance().mapLayersByName(lay['title'])[0])
                    except:
                        print("neni v poli")
        print(composition)
        print(len(composition['layers']))
        self.updateVisibilityInComposition()
        self.syncOrder2(self.getLayersOrder())
        self.patchMap2()
            #for layer in self.stylesToUpdate:
            #    if self.removeUnacceptableChars(layer.name()) in layerList:
            #        self.updateLayerStyle
        QgsMessageLog.logMessage("updateMapDone") 
        QgsMessageLog.logMessage("layersUploaded") 
    def updateLayerStyle(self, layer_name, workspace):  
        title = layer_name
        print(title, layer_name)
        layer_name = self.removeUnacceptableChars(layer_name)
        layer = QgsProject.instance().mapLayersByName(title)[0]
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0"):
            tempFile = self.getTempPath(os.path.basename(layer_name))
            stylePath = tempFile + ".qml"
            layer.saveNamedStyle(stylePath)
            #stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "qml")
        else:
            tempFile = self.getTempPath(os.path.basename(layer_name))
            stylePath = tempFile + ".sld"
            layer.saveSldStyle(stylePath)
            #stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "sld")
        files = [('style', open(stylePath, 'rb'))]
        url = self.URI+'/rest/'+workspace+"/layers/" + layer_name
        data = { 'name' :  layer_name, 'title' : str(layer.name())}
        
        url = self.URI+'/rest/'+workspace+"/layers/" + layer_name        
        r = requests.patch(url, files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        print("patch styles##########")
        print(r.content)

    def checkCompositionChanges2(self,x, layers):        
        check = False
        print((layers))
        matched = 0
        j = 0
        try:
            len(self.compositeList[x]['layers']) == None
        except:
            #print("excepted")
            return True
        if self.processingRequest == True: ## processing group hlida at nejdou 2 requesty na úpravu mapy najednou
            print("processing something else")
            return True
        for i in range (0, len(layers)):    
            #print(layers[i])
           # print(i)         
            #print(i, j)
            #print (len(self.compositeList[x]['layers']))
            if (i - j) < len(self.compositeList[x]['layers']):
                name = self.removeUnacceptableChars(self.compositeList[x]['layers'][i - j]['title'])
                print(name,self.removeUnacceptableChars(layers[i].name()))
                if name == self.removeUnacceptableChars(layers[i].name()):
                    #check = True
                    print("matched")
                    matched = matched + 1                            
                    lastMatchIndex = i
                else:
                    print("no matched")
                    j = j + 1 ## pokud se jména nepotkaji j reprezentuje "zpozdeni indexu" kompozice vuci vrstvam v layertree
            else:
                print("no matched")
                j = j + 1
            i = i + 1
        if (matched == len(self.compositeList[x]['layers'])):
            print("true")
            return True
        else:
            print("false")
            return False
          
    def checkCompositionChanges(self, layers):  
        composition = self.instance.getComposition()
        check = False
        #print(composition)
        print((layers))
        matched = 0
        j = 0
        try:
            len(composition['layers']) == None
        except:
            print("excepted")
            return True
        #if self.processingRequest == True: ## processing group hlida at nejdou 2 requesty na úpravu mapy najednou
        #    print("processing something else")
        #    return True
        for i in range (len(layers)-1,-1,-1):
        #for i in range (0, len(layers)):    
            #print(layers[i])
           # print(i)         
            print(i, j)
            print (len(composition['layers']))
            print("test poli")
            print((i - j), len(composition['layers']))
            if (i - j) < len(composition['layers']):
                name = self.removeUnacceptableChars(composition['layers'][i - j]['title'])
                print(name,self.removeUnacceptableChars(layers[i].name()))
                if name == self.removeUnacceptableChars(layers[i].name()):
                    #check = True
                    print("matched")
                    matched = matched + 1                            
                    lastMatchIndex = i
                else:
                    print("no matched")
                    j = j + 1 ## pokud se jména nepotkaji j reprezentuje "zpozdeni indexu" kompozice vuci vrstvam v layertree
            else:
                print("no matched")
                j = j + 1

            i = i + 1
        if (matched == len(composition['layers'])):
            print("true")
            return True
        else:
            print("false")
            return False
    def addLayerRefresh(self):
        self.dlg.treeWidget.clear()
        url = self.URI+'/rest/'+self.laymanUsername+'/layers'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))     
        data = r.json()
        for row in range(0, len(data)):    
      
            item = QTreeWidgetItem([self.getLayerTitle(data[row]['name'])])
            self.dlg.treeWidget.addTopLevelItem(item)
    def checkIfMapExist(self, name):
        url = self.URI + "/rest/"+self.laymanUsername+"/maps/"+str(name)+"/file"
       
        r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        

        if (r.status_code == 404):
            return False
        else:
            return True

    def reorderLayers(self, pos, order, x):
        self.dlg.pushButton_saveOrder.setEnabled(True)
        self.compositeList[x]['layers']
        i = 0
        compositeLength = len(self.compositeList[x]['layers'])
        self.mapsChanged.add(x)
        if (pos + order < 0):
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Vrstva je již na vrcholu kompozice!")
            else:
                QMessageBox.information(None, "Error", "Layer is already on the top level!")
            
        elif( pos + order == compositeLength):
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Vrstva je již na spodu kompozice!")
            else:
                QMessageBox.information(None, "Error", "Layer is already on the bottom level!")

        else:
       

            for lay in self.compositeList[x]['layers']:
              
                z = len(self.compositeList[x]['layers'])-1 - pos
                if i == z:

                    pom = self.compositeList[x]['layers'][z]
                    self.compositeList[x]['layers'][z] = self.compositeList[x]['layers'][z - order]
                    self.compositeList[x]['layers'][z - order] = pom     

                i = i + 1
           
           
            
            self.refreshLayerListReversed()
            self.dlg.treeWidget_listLayers.setCurrentItem(self.dlg.treeWidget_listLayers.topLevelItem(pos + order),pos + order)
            #self.dlg.listWidget_listLayers.setCurrentRow(pos + order)
    #def getItemByIndex(self,):
    #    for idx in range(0, ListWidget.count()):
    #        if idx == index:
    #        item = ListWidget.item(idx)
    #        item
    #def wms_wfs2(self, layerName, index):
    #    threading.Thread(target=lambda: self.wms_wfs2Thread(layerName,index)).start()
    #    if self.locale == "cs":
    #        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Mení se služba vrstvy " + layerName+"."), Qgis.Success, duration=5)               
    #    else:
    #        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Changing service of layer " + layerName+"."), Qgis.Success, duration=5) 
    def wms_wfs3(self, layerName, index, type): 
        print(layerName)
        somethingChanged = False
        composition = self.instance.getComposition()    
        for layer in composition['layers']:
            if self.removeUnacceptableChars(layer['title']) == self.removeUnacceptableChars(layerName):             
                if type == "WFS":
                    print("set layer to wfs")                    
                    #item = self.dlg.treeWidget_layers.topLevelItem(index)
                    #item.setText(1, "WFS")
                    styleUrl = self.URI+'/rest/'+self.laymanUsername+'/layers/'+ self.removeUnacceptableChars(layerName) + "/style"
                    composition['style'] = styleUrl
                    try:
                        name = layer['params']['LAYERS']  
                    except:
                        return
                    url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name  
                    r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                    data = r.json()
                    url = data['wfs']['url']
                    
                    layer['className'] = "OpenLayers.Layer.Vector"
                    layer['protocol'] = {                               
                        "FROMCRS": "EPSG:3857",
                        "INFO_FORMAT": "application/vnd.ogc.gml",
                        "LAYERS": name,
                        "format": "hs.format.WFS",
                        "url": url
                      }

                    del layer['params']
                    del layer['url']
                    self.layerServices[self.removeUnacceptableChars(layer['title'])] = 'OpenLayers.Layer.Vector'
                    print(layer)                  
                    somethingChanged = True

                if type == 'WMS':
                    print("set layer to wms")
                    #item = self.dlg.treeWidget_layers.topLevelItem(index)
                    #item.setText("WMS")
                    composition['style'] = ''
                    try:
                        #name = layer['protocol']['LAYERS']
                        name = layer['name']
                    except: 
                        #if self.layerServices[self.removeUnacceptableChars(layer['title'])] == "HSLayers.Layer.WMS"
                        #layer['protocol']['LAYERS'] = self.removeUnacceptableChars(layerName)
                        return
                        
                        #if self.locale == "cs":
                        #    QMessageBox.information(None, "Layman", "Tato vrstva má zastaralý formát metadat.")
                        #else:
                        #    QMessageBox.information(None, "Layman", "This layer has old format of metadata.")
                        #return                         
                    url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name  
                    r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                    data = r.json()
                    url = data['wms']['url']
                    
                    layer['className'] = "HSLayers.Layer.WMS"
                    layer['url'] = url
                    layer['params'] = {
                        "FORMAT": "image/png",
                        "FROMCRS": "EPSG:3857",                          
                        "LAYERS": self.removeUnacceptableChars(layerName),
                        "VERSION": "1.3.0"
                      }                    
                    del layer['protocol']
                    self.layerServices[self.removeUnacceptableChars(layer['title'])] = "HSLayers.Layer.WMS"
                    print(layer)
      
                    somethingChanged = True
                #threading.Thread(target=lambda: self.patchMap2()).start()
                #if self.locale == "cs":
                #    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Mení se služba vrstvy " + layerName+"."), Qgis.Success, duration=5)               
                #else:
                #    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Changing service of layer " + layerName+"."), Qgis.Success, duration=5)     
                #self.patchMap2()
    #def wms_wfs2(self, layerName, index):   
    #    if self.isItemChanged:
    #        self.isItemChanged = False
    #        return
    #    print(layerName)
    #    somethingChanged = False
    #    composition = self.instance.getComposition()
    #    pom = False
    #    for layer in composition['layers']:
    #        if self.removeUnacceptableChars(layer['title']) == self.removeUnacceptableChars(layerName):
    #            pom = True
    #            if self.dlg.radioButton_wfs.isChecked():
    #                print("set layer to wfs")
    #                item = self.dlg.listWidget_service.item(index)
    #                item.setText("WFS")
    #                try:
    #                    name = layer['params']['LAYERS']  
    #                except:
    #                    return
    #                url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name  
    #                r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
    #                data = r.json()
    #                url = data['wfs']['url']
                    
    #                layer['className'] = "OpenLayers.Layer.Vector"
    #                layer['protocol'] = {                               
    #                    "FROMCRS": "EPSG:3857",
    #                    "INFO_FORMAT": "application/vnd.ogc.gml",
    #                    "LAYERS": name,
    #                    "format": "hs.format.WFS",
    #                    "url": url
    #                  }

    #                del layer['params']
    #                del layer['url']
    #                self.layerServices[self.removeUnacceptableChars(layer['title'])] = 'OpenLayers.Layer.Vector'
    #                print(layer)
    #                somethingChanged = True

    #            if self.dlg.radioButton_wms.isChecked():
    #                print("set layer to wms")
    #                item = self.dlg.listWidget_service.item(index)
    #                item.setText("WMS")
    #                try:
    #                    #name = layer['protocol']['LAYERS']
    #                    name = layer['name']
    #                except: 
    #                    #if self.layerServices[self.removeUnacceptableChars(layer['title'])] == "HSLayers.Layer.WMS"
    #                    #layer['protocol']['LAYERS'] = self.removeUnacceptableChars(layerName)
    #                    return
                        
    #                    #if self.locale == "cs":
    #                    #    QMessageBox.information(None, "Layman", "Tato vrstva má zastaralý formát metadat.")
    #                    #else:
    #                    #    QMessageBox.information(None, "Layman", "This layer has old format of metadata.")
    #                    #return                         
    #                url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name  
    #                r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
    #                data = r.json()
    #                url = data['wms']['url']
                    
    #                layer['className'] = "HSLayers.Layer.WMS"
    #                layer['url'] = url
    #                layer['params'] = {
    #                    "FORMAT": "image/png",
    #                    "FROMCRS": "EPSG:3857",                          
    #                    "LAYERS": self.removeUnacceptableChars(layerName),
    #                    "VERSION": "1.3.0"
    #                  }                    
    #                del layer['protocol']
    #                self.layerServices[self.removeUnacceptableChars(layer['title'])] = "HSLayers.Layer.WMS"
    #                print(layer)
    #                somethingChanged = True
    #            #threading.Thread(target=lambda: self.patchMap2()).start()
    #            if self.locale == "cs":
    #                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Mení se služba vrstvy " + layerName+"."), Qgis.Success, duration=5)               
    #            else:
    #                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Changing service of layer " + layerName+"."), Qgis.Success, duration=5)     
    #            #self.patchMap2()
    #    if not pom:             
    #        if self.dlg.radioButton_wms.isChecked():
    #            item = self.dlg.listWidget_service.item(index)
    #            item.setText("WMS")
    #            print("set not saved layer to wms")
    #            self.layerServices[self.removeUnacceptableChars(layerName)] = "HSLayers.Layer.WMS"
    #            print(self.layerServices[self.removeUnacceptableChars(layerName)])
    #        if self.dlg.radioButton_wfs.isChecked():
    #            item = self.dlg.listWidget_service.item(index)
    #            item.setText("WFS")
    #            print("set not saved layer to wfs")
    #            self.layerServices[self.removeUnacceptableChars(layerName)] = 'OpenLayers.Layer.Vector'
    #            print(self.layerServices[self.removeUnacceptableChars(layerName)])
    #    if len(composition['layers']) == 0:
    #        if self.dlg.radioButton_wms.isChecked():
    #            item = self.dlg.listWidget_service.item(index)
    #            item.setText("WMS")
    #            print("set not saved layer to wms")
    #            self.layerServices[self.removeUnacceptableChars(layerName)] = "HSLayers.Layer.WMS"
    #            print(self.layerServices[self.removeUnacceptableChars(layerName)])
    #        if self.dlg.radioButton_wfs.isChecked():
    #            item = self.dlg.listWidget_service.item(index)
    #            item.setText("WFS")
    #            print("set not saved layer to wfs")
    #            self.layerServices[self.removeUnacceptableChars(layerName)] = 'OpenLayers.Layer.Vector'
    #            print(self.layerServices[self.removeUnacceptableChars(layerName)])
    #    if somethingChanged:
    #        somethingChanged = False
        
           
               
        
    def wms_wfs(self, item, column):
        print(item.text(0))   
        if item.text(1) == "HSLayers.Layer.WMS" or item.text(1) == "OpenLayers.Layer.Vector":
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Služba pro vrstvu "+item.text(0)+" bude změněna.")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Service for layer "+item.text(0)+" will be changed")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.Yes):
                for layer in self.compositeList[self.dlg.listWidget.currentRow()]['layers']:
                    if layer['title'] == item.text(0):
                        if item.text(1) == "HSLayers.Layer.WMS":
                            name = layer['params']['LAYERS']
                            #url = layer['url']                           
                            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name  
                            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                            data = r.json()
                            url = data['wfs']['url']
                            
                            layer['className'] = "OpenLayers.Layer.Vector"
                            layer['protocol'] = {                               
                                "FROMCRS": "EPSG:3857",
                                "INFO_FORMAT": "application/vnd.ogc.gml",
                                "LAYERS": name,
                                "format": "hs.format.WFS",
                                "url": url
                              }
                            del layer['params']
                            del layer['url']

                        if item.text(1) == "OpenLayers.Layer.Vector":
                            try:
                                name = layer['protocol']['LAYERS']
                            except:
                                if self.locale == "cs":
                                    QMessageBox.information(None, "Layman", "Tato vrstva má zastaralý formát metadat.")
                                else:
                                    QMessageBox.information(None, "Layman", "This layer has old format of metadata.")
                                return
                            #url = layer['url']                           
                            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name  
                            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                            data = r.json()
                            url = data['wms']['url']
                            
                            layer['className'] = "HSLayers.Layer.WMS"
                            layer['url'] = url
                            layer['params'] = {
                                "FORMAT": "image/png",
                                "FROMCRS": "EPSG:3857",                          
                                "LAYERS": name,
                                "VERSION": "1.3.0"
                              }
                            del layer['protocol']
                       
                #print(self.compositeList[self.dlg.listWidget.currentRow()])
                self.importMap(self.dlg.listWidget.currentRow(), 'mod')
                self.refreshLayerListReversed()
    def showThumbnail(self, it):
        self.params = list()
        self.params.append(it)
        QgsMessageLog.logMessage("showThumbnail2")
    def showThumbnail2(self, it):
        try:
            layer = it.text(0) ##pro QTreeWidget
            workspace = it.text(1)
        except:
            layer = it.text()##pro listWidget
        try:
            layer = self.removeUnacceptableChars(layer)
            #url = self.URI+'/rest/' +self.laymanUsername+'/layers/'+layer+'/thumbnail'    
            url = self.URI+'/rest/' +workspace+'/layers/'+layer+'/thumbnail'    
            print("thubmnailURL" + url)          
            r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
            data = r.content
            #print(data)
            pixmap = QPixmap(200, 200)
            pixmap.loadFromData(data)
            smaller_pixmap = pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.FastTransformation)
            self.dlg.label_thumbnail.setPixmap(smaller_pixmap)
            self.dlg.label_thumbnail.setAlignment(Qt.AlignCenter)
        except:
            self.dlg.label_thumbnail.setText('  Unable to load thumbnail.')
    def showSmallThumbnail(self, it):
        try:
            layer = it.text(0) ##pro QTreeWidget
            workspace = it.text(1)
        except:
            layer = it.text()##pro listWidget
        try:
            layer = self.removeUnacceptableChars(layer)
            url = self.URI+'/rest/'+workspace+'/layers/'+layer+'/thumbnail'
            print("thubmnailURL" + url)
            #data = urlopen(url).read()
            #print(data)
            r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
            data = r.content
            pixmap = QPixmap(200, 200)
            pixmap.loadFromData(data)
            smaller_pixmap = pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.FastTransformation)
            self.dlg.label_thumbnail.setPixmap(smaller_pixmap)
            self.dlg.label_thumbnail.setAlignment(Qt.AlignCenter)
        except:
            self.dlg.label_thumbnail.setText('  Unable to load thumbnail.')
    def showThumbnailMap(self, it):
        self.params = list()
        self.params.append(it)
        QgsMessageLog.logMessage("showThumbnailMap2")
    def showThumbnailMap2(self, it):
        try:
            map = it.text(0) ##pro QTreeWidget
            workspace = it.text(1)
        except:
            map = it.text()##pro listWidget
        
        try:
            map = self.removeUnacceptableChars(str(map))
            url = self.URI+'/rest/'+workspace+'/maps/'+str(map).lower()+'/thumbnail'   
            print("thubmnailURL" + url) 
          
            data = urlopen(url).read()
            pixmap = QPixmap(200, 200)
            pixmap.loadFromData(data)
            smaller_pixmap = pixmap.scaled(200, 200, Qt.KeepAspectRatio, Qt.FastTransformation)
            self.dlg.label_thumbnail.setPixmap(smaller_pixmap)
           # self.dlg.label_thumbnail.setAlignment(Qt.AlignCenter)
        except:
            self.dlg.label_thumbnail.setText('       Unable to load thumbnail.')
    def setup_oauth(self, authcfg_id, authcfg_name):
        """Setup oauth configuration to access OAuth API,
        return authcfg_id on success, None on failure
        """
        #cfgjson = {
        #"accessMethod": 0,
        #"apiKey": "",
        #"clientId": self.client_id,
        #"clientSecret": "secret-401774e6-769c-42b5-42ac-1c1763e619f",
        #"configType": 1,
        #"description": "",
        #"grantFlow": 0,
        #"id": "esa2024",
        #"name": "auth",
        #"objectName": "",
        #"password": "",
        #"persistToken": False,
        #"queryPairs": {
        #},
        #"redirectPort": 7070,
        #"redirectUrl": "",
        #"refreshTokenUrl": "",
        #"requestTimeout": 60,
        #"requestUrl": self.liferayServer + "/o/oauth2/authorize", 
        #"scope": "",
        #"tokenUrl": self.liferayServer + "/o/oauth2/token",
        #"username": "",
        #"version": 1
        #}
        if authcfg_id != '7f22y3f' and authcfg_id != '7f22y3d': ## prozatím pro test toto id ma wagtail
            cfgjson = {
            "accessMethod": 0,
            "apiKey": "",
            "clientId": self.client_id,
            "clientSecret": self.client_secret,
            "configType": 1,
            "description": "",
            "grantFlow": 0,
            "id": "esa2024",
            "name": "auth",
            "objectName": "",
            "password": "",
            "persistToken": False,
            "queryPairs": {
            },
            "redirectPort": 7070,
            "redirectUrl": "client/oauthn2-liferay/callback",
            "refreshTokenUrl": "",
            "requestTimeout": 60,
            "requestUrl": self.liferayServer + "/o/oauth2/authorize", 
            "scope": "",
            "tokenUrl": self.liferayServer + "/o/oauth2/token",
            "username": "",
            "version": 1
            }
        else:
            cfgjson = {
            "accessMethod": 0,
            "apiKey": "",
            "clientId": self.client_id,
            "clientSecret": self.client_secret,
            "configType": 1,
            "description": "",
            "grantFlow": 0,
            "id": "esa2024",
            "name": "auth",
            "objectName": "",
            "password": "",
            "persistToken": False,
            "queryPairs": {
            },
            "redirectPort": 7070,
            "redirectUrl": "client/oauthn2-liferay/callback",
            "refreshTokenUrl": "",
            "requestTimeout": 60,
            "requestUrl": self.liferayServer + "/o/authorize", 
            "scope": "",
            "tokenUrl": self.liferayServer + "/o/token/",
            "username": "",
            "version": 1
            }

        if authcfg_id not in QgsApplication.authManager().availableAuthMethodConfigs():
            authConfig = QgsAuthMethodConfig('OAuth2')
            authConfig.setId(authcfg_id)
            authConfig.setName(authcfg_name)
            authConfig.setUri(self.liferayServer)
            authConfig.setConfig('oauth2config', json.dumps(cfgjson))
            if QgsApplication.authManager().storeAuthenticationConfig(authConfig):
                return authcfg_id
        else:
            authConfig = QgsAuthMethodConfig()
            QgsApplication.authManager().loadAuthenticationConfig(authcfg_id, authConfig, True)
            authConfig.setName(authcfg_name)
            authConfig.setUri(self.liferayServer)
            authConfig.setConfig('oauth2config', json.dumps(cfgjson))
            if QgsApplication.authManager().updateAuthenticationConfig(authConfig):
                return authcfg_id
                
        return None
    def checkForSpecialChars(self, s):
        special_characters = "!@#$%^&*()+?=,<>/"
        numbers = "0123456789"
        try:
            if s[0] in numbers:
                return True
        except:
            pass
        if any(c in special_characters for c in s):
            return True
        else:
            return False
    def checkForChars(self, string):
        if self.checkForSpecialChars(string):
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nepodporovaný znak.")
            else:
                QMessageBox.information(None, "Layman", "Unsupported char.")
        else:
            self.dlg.pushButton_CreateComposition.setEnabled(True)
            self.dlg.label_info.setText("")
    def checkNameCreateMap(self):
        text = self.dlg.lineEdit_2.text()
        if text != "":
            text = self.removeUnacceptableChars(text)
           
            ### map check
            url = self.URI + "/rest/"+self.laymanUsername+"/maps/"+str(text)+"/file"
           
            r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
         
            res = r.json()
            print(res)
            ch = True
            e = False
            try:
                if res['code'] == 2:
                    ch = False
                else:
                    ch = True
            except:
                ch = True
                e = True ## kdyz nevraci rescode tak je to v poradku

            #if not ch:
            if False:
                self.dlg.pushButton_CreateComposition.setEnabled(False)
                self.dlg.label_info.show()
                if self.locale == "cs":
                    self.dlg.label_info.setText("Nepřípustný znak v názvu!")
                else:
                    self.dlg.label_info.setText("Unacceptable char in title!")
            elif (not e):            
                self.dlg.pushButton_CreateComposition.setEnabled(True)
                self.dlg.label_info.hide()
            
            else:
                self.dlg.pushButton_CreateComposition.setEnabled(False)
                self.dlg.label_info.show()
                if self.locale == "cs":
                    self.dlg.label_info.setText("Kompozice s tímto jménem již existuje!")
                else:
                    self.dlg.label_info.setText("Composition name already exists!")
            ##
            self.dlg.label_info.setStyleSheet("color: red;")

            #if (self.checkIfMapExist(text)):
            #    self.dlg.pushButton_CreateComposition.setEnabled(False)
            #    self.dlg.label_info.show()
            
            #else:
            #    self.dlg.pushButton_CreateComposition.setEnabled(True)
            #    self.dlg.label_info.hide()
        #----------------------------------------------------------
    def readLayerJson(self,layerName, service):
        self.params = list()
        self.params.append(layerName)
        self.params.append(service) 
        self.dlg.progressBar_loader.show()
        QgsMessageLog.logMessage("readlayerjson")
    def readLayerJson2(self,layerName, service):
        #self.threadAddMap = threading.Thread(target=lambda: self.readLayerJsonThread(layerName,service))
        #self.threadAddMap.start()
        for i in range (0, len(self.dlg.treeWidget.selectedItems())):
            name = self.dlg.treeWidget.selectedItems()[i].text(0)        
            workspace = self.dlg.treeWidget.selectedItems()[i].text(1)
            self.selectedWorkspace = workspace
            threading.Thread(target=lambda: self.readLayerJsonThread(name,service, workspace)).start()
            #self.readLayerJsonThread(name,service, workspace)            
        QgsMessageLog.logMessage("disableProgressBar")    
    def readLayerJsonThread(self, layerName,service, workspace):
        if self.checkLayerOnLayman(layerName):
            layerNameTitle =layerName
            layerName = self.removeUnacceptableChars(layerName)
            #url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layerName  
            url = self.URI+'/rest/'+workspace+'/layers/'+layerName  
           
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            data = r.json()
            if (service == "WMS"):
               
                try:
                    wmsUrl = data['wms']['url']
                except:
                    QgsMessageLog.logMessage("wrongLoaded")
                    return
                format = 'png'
                epsg = 'EPSG:4326' 
                timeDimension = {}
                groupName=""
                subgroup=""
                #threading.Thread(target=lambda: self.loadWms(wmsUrl, layerName,layerNameTitle, format, epsg, groupName,subgroup, timeDimension) ).start()
                success = self.loadWms(wmsUrl, layerName,layerNameTitle, format, epsg, groupName,subgroup, timeDimension) 
                if not success:
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Vrstva: "+layerName + " je poškozena a nebude načtena.")
                    else:
                        QMessageBox.information(None, "Layman", "Layer: "+layerName + " is corrupted and will not be loaded.")
            if (service == "WFS"):
                try:
                    wfsUrl = data['wfs']['url']
                except:
                    QgsMessageLog.logMessage("wrongLoaded")
                    return
                print("loading WFS")
                success = self.loadWfs(wfsUrl, layerName, layerNameTitle) 
                #threading.Thread(target=lambda: self.loadWfs(wfsUrl, layerName, layerNameTitle)).start()
                if not success:
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Vrstva: "+layerName + " je poškozena a nebude načtena.")
                    else:
                        QMessageBox.information(None, "Layman", "Layer: "+layerName + " is corrupted and will not be loaded.")
            QgsMessageLog.logMessage("disableProgressBar")
        else:
            
            QgsMessageLog.logMessage("readJson")
            
    def write_log_message(self,message, tag, level):
        #print(message)
        if message[0:15] == "notifyTwoGroups":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva " + message[15:100] +" je vnořena do dvou skupin. Uložena bude pouze nadřazená.")
            else:
                QMessageBox.information(None, "Layman", "Layer " + message[15:100] +" is nested in two groups. Only parent group will be saved.")
            # if self.locale == "cs":
            #     iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Vrstva " + message[15:100] +" je vnořena do dvou skupin. Uložena bude pouze nadřazená."), Qgis.Warning, duration=5)               
            # else:
            #     iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Layer " + message[15:100] +" is nested in two groups. Only parent group will be saved."), Qgis.Warning, duration=5)
        if message == "updateMapDone":
            self.dlg.progressBar_loader.hide()
            self.dlg.pushButton_save.setEnabled(True)
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Změny v kompozici byly uloženy."), Qgis.Success, duration=3)               
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Changes in composition were saved."), Qgis.Success, duration=3)
            try:
                self.dlg.label_raster.hide() 
            except:
                pass
            
        if message == "errConnection":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Připojení k serveru selhalo!"), Qgis.Warning, duration=3)               
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Connection with server failed!"), Qgis.Warning, duration=3)
            try:
                self.dlg.progressBar_loader.hide() 
            except:
                print("progressbar doesnt exist")
        if message == "successLoadComp":
            try:
                self.dlg.label_loading.hide() 
                self.dlg.progressBar_loader.hide() 
                #self.dlg.listWidget.setSelectionMode(QAbstractItemView.SingleSelection)
                self.importMapEnvironmnet(True)
            except:
                pass
        if message == "compositionLoaded":
            try:
                self.menu_ImportMapDialog.setEnabled(True) 
            except:
                if self.locale == "cs":
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice nebyly nahrány!"), Qgis.Warning, duration=3)               
                else:
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Compositions was not loaded!"), Qgis.Warning, duration=3)
        if message == "reorderGroups":
            for thread in self.threads:
                try:
                    thread.join()
                except:
                    pass
            for g in self.groups:
                print(g[0], g[1])
                #try:
                self.reorderToTop(g[0], g[1]) 
                #except:
                #    print("reoder exception")
                #    pass
                    
        if message == "layersUploaded":
            
            #threadsB = set()
            #for thread in threading.enumerate(): 
            #    threadsB.add(thread.name)  
            #print("threadsA")
            #print(self.ThreadsUploadsA)
            #threadsB = threading.enumerate()
            #while (len(threadsB) > 1 or self.ThreadsUploadsA != threadsB):
            #    threadsB = set()
            #    for thread in threading.enumerate(): 
            #        threadsB.add(thread.name)  
            #    time.sleep(1)
            try:
                print("toUpload" +str(self.toUpload) )
                if (self.toUpload <= 1):
                    try:
                        self.dlg.progressBar_loader.hide()
                    except:
                        self.old_dlg.progressBar_loader.hide()
            except:
                print("different form")
        if message == "afterCompositionLoaded":
            self.afterCompositionLoaded()
        if message == "layersLoaded":
            #time.sleep(2)
            try:
                self.dlg.progressBar_loader.hide() 
                self.dlg.label_loading.hide() 
            except:
                pass
        if message == "disableProgressBar":
            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
        if message == "readJson":            
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Tato vrstva nelze nahrát")
            else:
                QMessageBox.information(None, "Layman", "Something went wrong with this layer.")
        if message == "authOptained":
            self.authOptained()
            self.getToken()
            try:
                self.dlg.progressBar.hide() 
            except:
                pass
        if message == "showLoader":            
            try:
                self.dlg.progressBar_loader.show()
            except:
                pass
        if message == "readmapjson":
            #name, service
            #threading.Thread(target=lambda: self.readMapJson2(self.params[0],self.params[1],self.params[2])).start()
            self.readMapJson2(self.params[0],self.params[1],self.params[2])
            #self.readMapJsonThread(self.params[0],self.params[1])
        if message =="showThumbnailMap2":
            try:
                self.showThumbnailMap2(self.params[0])
            except:
                print("problem with thumbnail")
        if message =="showThumbnail2":
            self.showThumbnail2(self.params[0])
        if message =="requestError":
            if self.locale == "cs":                
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Chyba spojení se serverem!"), Qgis.Error, duration=3)
            else:              
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Connection with server lost!"), Qgis.Error, duration=3)
        if message =="compositionSchemaError":            
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Schéma kompozice není ve validním formátu")
            else:
                QMessageBox.information(None, "Layman", "Composition is not in valid format")
            self.dlg.progressBar_loader.hide()
        if message == "readlayerjson":
            #name, service ,workspace
            self.readLayerJson2(self.params[0],self.params[1])
        if message[:13] == "loadSymbology": ## slovník random   
            num = message[13:] 
            if (isinstance(self.currentLayerDict[num], QgsVectorLayer)):
                style = self.getStyle(self.currentLayerDict[num].name())
                    #code = self.getSLD(layerName)
                layerName = self.currentLayerDict[num].name()
                if (style[0] == 200):
                    if (style[1] == "sld"):
                        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                        self.currentLayerDict[num].loadSldStyle(tempf)
                        self.currentLayerDict[num].triggerRepaint()
                    if (style[1] == "qml"):
                        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
                        self.currentLayerDict[num].loadNamedStyle(tempf)
                        self.currentLayerDict[num].triggerRepaint()
        if message[:10] == "loadVector": ## slovník random            
            num = message[10:]
            QgsProject.instance().addMapLayer(self.currentLayerDict[num])
            
            
            if (isinstance(self.currentLayerDict[num], QgsVectorLayer)):
                style = self.getStyle(self.currentLayerDict[num].name())
                    #code = self.getSLD(layerName)
                layerName = self.currentLayerDict[num].name()
                if (style[0] == 200):
                    if (style[1] == "sld"):
                        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                        self.currentLayerDict[num].loadSldStyle(tempf)
                        self.currentLayerDict[num].triggerRepaint()
                    if (style[1] == "qml"):
                        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
                        self.currentLayerDict[num].loadNamedStyle(tempf)
                        self.currentLayerDict[num].triggerRepaint()
            
        if message == "loadLayer":
            
          
            print("loading layer")
            print("###############################z")
            print(self.currentLayer)
            print(self.currentLayer[len(self.currentLayer)-1].name())
            print(self.currentLayer[len(self.currentLayer)-1].isValid())            
            print("###############################z")
            QgsProject.instance().addMapLayer(self.currentLayer[0])
         
            try:
                visibility = self.instance.getVisibilityForLayer(self.currentLayer[0].name())
                QgsProject.instance().layerTreeRoot().findLayer(self.currentLayer[0]).setItemVisibilityChecked(visibility)
            except:
                print("missing visibility parameter")
                QgsProject.instance().layerTreeRoot().findLayer(self.currentLayer[0]).setItemVisibilityChecked(True)
            #try:
            #    QgsProject.instance().mapLayersByName(self.currentLayer[0].name())[0]
            #except:
            #    self.unloadedLayers.append(self.currentLayer[0].name())
            del self.currentLayer[0]

           
        if message == "patchMapP":
            if self.locale == "cs":            
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Kompozice byla upravena"), Qgis.Success, duration=3)
            else:           
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Composition was changed"), Qgis.Success, duration=3)
        if message == "patchMapN":
            if self.locale == "cs":            
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Kompozice nebyla upravena"), Qgis.Warning, duration=3)
            else:           
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Error: Composition was not changed"), Qgis.Warning, duration=3)
        if message == "layerDeleteFromCompositeWrong":
            if self.locale == "cs":
            
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Vrsta v kompozici nebyla úspěšně smazána."), Qgis.Warning, duration=3)
            else:
           
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Layer in composition was not successfully deleted."), Qgis.Warning, duration=3)
        if message == "refreshComposite":
            try:
                self.refreshCompositeList()        ## pouze pro import Form     
            except:
                pass
        if message == "loadMaps":
            try:
                self.dlg.progressBar_loader.hide() 
                self.dlg.label_loading.hide()
            except:
                print("chyba")
        if message == "delLayComposite":
            try:
                self.dlg.progressBar.hide() 
                self.dlg.label_import.hide()
                self.refreshLayerListReversed()
                self.dlg.pushButton_addMap.setEnabled(True)
                self.dlg.pushButton_deleteMap.setEnabled(True)
                self.dlg.pushButton_editMeta.setEnabled(True)
                self.dlg.pushButton_setMapPermissions.setEnabled(True)
                self.dlg.pushButton_addRaster.setEnabled(True)
                if (self.dlg.mMapLayerComboBox.count() > 0):
                    self.dlg.pushButton.setEnabled(True)
            except:
                print("chyba")
        if message == "unsupportedCRS":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", "Nepodporované CRS souboru"), Qgis.Warning, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", "Unsupported CRS of data file"), Qgis.Warning, duration=3)


        if message == "resetProgressbar":
            try:
                self.dlg.progressBar.hide()
                self.dlg.progressBar.setValue(0)
            except:
                pass                  
        if message == "disableProgress":
            try:
                self.dlg.progressBar_loader.hide()
                self.dlg.label_raster.hide() 
            except:
                pass                
        if message == "enableProgress":
            try:
                self.dlg.progressBar_loader.show()   
                self.dlg.label_raster.show() 
            except:
                pass
        if message == "errorConnection":
            if self.locale == "cs":                
                QMessageBox.information(None, "Error", "Spojení se serverem selhalo! Vrstva nebyla nahrána.")
            else:
                QMessageBox.information(None, "Error", "Connection with server failed! Layer was not exported.")
        if message == "export":
            #try:
            threadsB = set()
            for thread in threading.enumerate(): 
                threadsB.add(thread.name)  
            try:                
                if(self.ThreadsA == threadsB):
                    self.dlg.progressBar.hide() 
                    self.dlg.label_import.hide()

            

            except:
                pass        
        if message[:9] == "mProgress": 
            print("mProgress")
            progress = int(message[9:].split(";")[0])
            max = int(message[9:].split(";")[1])
            prog = int((progress / max) * 100)
            print(max, progress, prog)
            if progress < max:
                if (prog == 10 or prog == 20 or prog == 30 or prog == 40 or prog == 50 or prog == 60 or prog == 70 or prog == 80 or prog == 90  or prog == 100):
                    if self.locale == "cs":            
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Nahrávání rastru: "+ str(prog) + "%"), Qgis.Success, duration=5)
                    else:           
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Export raster: "+ str(prog) + "%"), Qgis.Success, duration=5)
        if message[:8] == "progress":
            progress = int(message[8:].split(";")[0])
            max = int(message[8:].split(";")[1])
            self.dlg.progressBar.setMaximum(max)
            self.dlg.progressBar.setValue(progress)


            pass
        if message == "limitSize":
            if self.locale == "cs":                
                QMessageBox.information(None, "Upozornění", "Tato vrstva je větší než 2GB. Může být serverem odmítnuta.")
            else:
                QMessageBox.information(None, "Warning", "This layer is bigger than 2GB. It can be refused by server.")
        if message == "exportPatch":
            try:
                threadsB = set()
                for thread in threading.enumerate(): 
                    threadsB.add(thread.name)
              
                if(self.ThreadsA == threadsB):
                    self.dlg.progressBar.hide() 
                    self.dlg.label_import.hide()
                

            except:
                pass
            try: ## některé formuláře nemají progress bar
                ## resime situaci kdy se dela patch v kompozici
                self.dlg.pushButton.setEnabled(True)
                self.dlg.pushButton_deleteMap.setEnabled(True)
                self.dlg.pushButton_editMeta.setEnabled(True)
                self.dlg.pushButton_setMapPermissions.setEnabled(True)
                self.dlg.pushButton_down.setEnabled(True)
                self.dlg.pushButton_up.setEnabled(True)
                self.dlg.pushButton_deleteLayers.setEnabled(True)
                self.dlg.pushButton_up.setEnabled(True)
                self.dlg.pushButton_addRaster.setEnabled(True)
                self.dlg.progressBar.hide() 
                self.dlg.label_import.hide() 
                
                
            except:
                pass
                
            #try:
            #    self.dlg.pushButton.setEnabled(True)
            #except:
            #    pass    
        if message == "delLayErr":
            if self.locale == "cs":                
                QMessageBox.information(None, "Error", "Vrstva nebyla smazána!")
            else:
                QMessageBox.information(None, "Error", "Layer was not deleted!")
        if message == "delLay":
            try:
                self.dlg.label_thumbnail.setText(' ')
            except:
                pass
            try:
                if not (self.threadLayers.is_alive()):
                    
                    self.dlg.progressBar_loader.hide()
                    
            except:
                pass
            #self.loadLayersThread()
                       
        if message[0:15] == "permissionsDone":    
            try:
                self.dlg.progressBar_loader.hide() 
                #if (message[-1:] == "T"):
                #if len(self.failed) == 0:
                if self.statusHelper:
                    if self.locale == "cs":                
                        QMessageBox.information(None, "Uloženo", "Práva byla úspěšně uložena.")
                    else:
                        QMessageBox.information(None, "Saved", "Permissions was saved successfully.")
                else:
                    if self.locale == "cs":
                        QMessageBox.information(None, "Chyba", "Práva nebyla uložena pro vrstvu/mapu: " + str(self.failed).replace("[","").replace("]",""))               
                    else:
                        QMessageBox.information(None, "Error", "Permissions was not saved for layer/map: " + str(self.failed).replace("[","").replace("]",""))  
            except:
                print("form was killed before response")
        if message[0:8] == "importl_":
            try:
                self.progressColor(message[8:100], True)
            except:
                pass
            if self.locale == "cs":               
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+message[8:100]+" nebyla úspěšně nahrána, protože je příliž velká."), Qgis.Warning, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+message[8:100]+" was not successfully imported because is too large"), Qgis.Warning, duration=3)
            done = 0
        
            for i in range (0, len(self.processingList)):
                if self.processingList[i][2] == 1:                    
                    self.processingList[i][2] = 2
                   # print(self.processingList)
                    done = done + 1
            try:
                if self.locale == "cs":
                    self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(self.uploaded) + " / " + str(self.batchLength) )
                else:
                    self.dlg.label_progress.setText("Sucessfully exported: " +  str(self.uploaded) + " / " + str(self.batchLength) )
            except:
                pass
            try:
                if self.uploaded == self.batchLength:
                    self.dlg.progressBar.hide()
            except:
                pass
        if message[0:8] == "imports_":
            try:
                self.progressColor(message[8:100], True)
            except:
                pass
            if self.locale == "cs":               
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+message[8:100]+" byla úspěšně nahrána "), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+message[8:100]+" was successfully imported"), Qgis.Success, duration=3)
            done = 0
        
            for i in range (0, len(self.processingList)):
                if self.processingList[i][2] == 1:                    
                    self.processingList[i][2] = 2
                   # print(self.processingList)
                    done = done + 1
            try:
                if self.locale == "cs":
                    self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(self.uploaded) + " / " + str(self.batchLength) )
                else:
                    self.dlg.label_progress.setText("Sucessfully exported: " +  str(self.uploaded) + " / " + str(self.batchLength) )
            except:
                pass
            try:
                if self.uploaded == self.batchLength:
                    self.dlg.progressBar.hide()
            except:
                pass
        if message[0:8] == "importn_":
            try:
                self.progressColor(message[8:100], False)
            except:
                pass
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva: "+message[8:100]+" nebyla úspěšně nahrána "), Qgis.Warning, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer: "+message[8:100]+" was not imported successfully"), Qgis.Warning, duration=3)
            done = 0
        
            for i in range (0, len(self.processingList)):
                if self.processingList[i][2] == 1:
                   
                    self.processingList[i][2] = 2
                    #print(self.processingList)
                    done = done + 1
            #try:
            #    if self.locale == "cs":
            #        self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(self.uploaded) + " / " + str(self.batchLength) )
            #    else:
            #        self.dlg.label_progress.setText("Sucessfully exported: " +  str(self.uploaded) + " / " + str(self.batchLength) )
            #except:
            #    pass
        if message == "wrongName":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nepodporovaný znak v názvu.")
            else:
                QMessageBox.information(None, "Layman", "Unsupported char in name.")
        if message == "invalid":
            try:
                self.dlg.progressBar.hide()
            except:
                pass

            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva není validní!")
            else:
                QMessageBox.information(None, "Layman", "Layer is invalid!")
        if message == "wrongCrs":
            try:
                self.dlg.progressBar.hide()
            except:
                pass

            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Použijte EPSG:4326")
            else:
                QMessageBox.information(None, "Layman", "Use EPSG:4326")
        if message[:9] == "wrongCrss":
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Použijte EPSG:4326 pro vrstvy:" + "\n" + message[9:])
            else:
                QMessageBox.information(None, "Layman", "Use EPSG:4326 for layers:" + "\n" +  message[9:])
        if message == "BmpNotSupported":
            try:
                self.dlg.progressBar.hide()
            except:
                pass

            try:
                self.dlg.progressBar_loader.hide()
            except:
                pass
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Formát rastru BMP není podporován.")
            else:
                QMessageBox.information(None, "Layman", "Raster format BMP is not supported.")
            try:
                self.dlg.progressBar.hide()
            except:
                pass
        if message == "path added":
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Parametr path byl modifikován."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Parameter path was modified."), Qgis.Success, duration=3)
        if message == "addRaster":
            try:
                self.dlg.progressBar.hide() 
                self.dlg.label_import.hide()
                self.dlg.pushBuqgistton_down.setEnabled(True)
                self.dlg.pushButton_up.setEnabled(True)
                self.dlg.pushButton_deleteLayers.setEnabled(True)
                self.dlg.label_raster.hide()
            except:
                pass
            
            try:    
                self.dlg.pushButton_addRaster.setEnabled(True)
                self.importMapEnvironmnet(True)
             
            except:
                pass # pro formulár kde neni progressbar
            
            try:
                self.dlg.label_thumbnail.setText(' ')
            except:
                pass
            #self.refreshLayerListReversed()
        if message == "wrongLoaded": 
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Vrstva není k dispozici!"), Qgis.Warning, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Layer is not available!"), Qgis.Warning, duration=3)
    def loadAllComposites(self):
        url = self.URI+'/rest/' + self.laymanUsername + '/maps'
        
        try:
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        except:
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Připojení k serveru selhalo!"), Qgis.Warning, duration=3)               
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Connection with server failed!"), Qgis.Warning, duration=3)
        try:
            data = r.json()  
            
        except:
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Připojení k serveru selhalo!"), Qgis.Warning, duration=3)               
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Connection with server failed!"), Qgis.Warning, duration=3)
            return
        for i in data:
           # print(i['name'])
            url = self.URI+'/rest/' + self.laymanUsername + '/maps/'+i['name']+'/file'  
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            try:
                map = r.json()
            except:
                if self.locale == "cs":
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Připojení k serveru selhalo!"), Qgis.Warning, duration=3)              
                else:
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Connection with server failed!"), Qgis.Warning, duration=3)
            self.compositeList.append (map)
        self.loadedInMemory = True
    def loadAllCompositesT(self):
        self.compositeList = list() 
        url = self.URI+'/rest/' + self.laymanUsername + '/maps'   
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))        
        try:
            data = r.json()
        except:
            QgsMessageLog.logMessage("errConnection")
            QgsMessageLog.logMessage(url)
            self.disableEnvironment()
            return
        for i in data:
            url = self.URI+'/rest/' + i['workspace'] + '/maps/'+i['name']+'/file' 
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            try:
                map = r.json()
            except:
                QgsMessageLog.logMessage("errConnection")
                QgsMessageLog.logMessage(map)
                self.disableEnvironment()
                return
            self.compositeList.append(map)
        self.loadedInMemory = True
        #QgsMessageLog.logMessage("compositionLoaded")
    def readMapJson(self,name, service, workspace=""):    
        QgsProject.instance().setTitle(name)
        url = self.URI+'/rest/'+workspace+'/maps/'+name+'/file'  
        print(url)
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        data = r.json()
        try:
            QgsProject.instance().crsChanged.disconnect() 
        except:
            print("signal crsChanged was not connected")
        projection = data['projection'].replace("epsg:","")
        if projection != "":
            crs=QgsCoordinateReferenceSystem(int(projection))
            
            QgsProject.instance().setCrs(crs)
            QgsProject.instance().crsChanged.connect(self.crsChanged)
             
        #canvas = iface.mapCanvas()     
        #rect = QgsRectangle(float(data['extent'][0]),float(data['extent'][1]),float(data['extent'][2]),float(data['extent'][3]))
        #canvas.setExtent(rect)
        self.dlg.pushButton_map.setEnabled(False)
        
                #    msgbox = QMessageBox(QMessageBox.Question, "Layman", "More accurate transformations can be set for layers in this project. Do you want to set up this transformation?")
                #msgbox.addButton(QMessageBox.Yes)
                #msgbox.addButton(QMessageBox.No)
                #msgbox.setDefaultButton(QMessageBox.No)
                #reply = msgbox.exec()
                #if (reply == QMessageBox.Yes):
                #    crs = QgsCoordinateReferenceSystem() 
                #    crs.createFromProj("+proj=pipeline +step +inv +proj=webmerc +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +step +proj=push +v_3 +step +proj=cart +ellps=WGS84 +step +inv +proj=helmert +x=570.8 +y=85.7 +z=462.8 +rx=4.998 +ry=1.587 +rz=5.261 +s=3.56 +convention=position_vector +step +inv +proj=cart +ellps=bessel +step +proj=pop +v_3 +step +proj=krovak +lat_0=49.5 +lon_0=24.8333333333333 +alpha=30.2881397527778 +k=0.9999 +x_0=0 +y_0=0 +ellps=bessel")
                #    QgsProject.instance().setCrs(crs)
        self.params = list()
        self.params.append(name)
        self.params.append(service)
        self.params.append(workspace)
     
        QgsMessageLog.logMessage("readmapjson")
    def readMapJson2(self,name, service, workspace=""):
        #self.dlg.progressBar_loader.show() 
        #self.dlg.label_loading.show()
        self.unloadedLayers = list()
        self.processingRequest = True
        #name = self.removeUnacceptableChars(name)
        self.current = name
        if workspace != "":### nactemdef loadData(self,name):
            
            self.selectedWorkspace = workspace
            print(workspace)
            print(name)
            url = self.URI+'/rest/'+workspace+'/maps/'+name+'/file'  
            print(url)
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            data = r.json()
            self.instance = CurrentComposition(self.URI, name, workspace, self.getAuthHeader(self.authCfg),self.laymanUsername)
            self.instance.setComposition(data)
            #try:
            #    projection = data['projection'].replace("epsg:","")
            #    crs=QgsCoordinateReferenceSystem(int(projection))
            #    QgsProject.instance().setCrs(crs)
            
            #except:
            #    print("parameter projection was not found")
            
            if QgsProject.instance().crs().authid() == 'EPSG:5514':
                if QgsProject.instance().crs().toProj() == '+proj=krovak +lat_0=49.5 +lon_0=24.8333333333333 +alpha=30.2881397527778 +k=0.9999 +x_0=0 +y_0=0 +ellps=bessel +towgs84=589,76,480,0,0,0,0 +units=m +no_defs':
                
                    if self.locale == "cs":
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "Používáte EPSG: 5514. Doporučujeme používat tranformaci 5514-1623"), Qgis.Success, duration=10)
                    #    msgbox = QMessageBox(QMessageBox.Question, "Layman", "Pro vrstvy v tomto projektu lze nastavit přesnější tranformace. Chcete tuto tranformaci nastavit?")
                       # QMessageBox.information(None, "Layman", "Používáte EPSG: 5514. Doporučujeme používat tranformaci 5514-1623")
                    else:
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", "You are using EPSG: 5514. We recommend using the transformation 5514-1623 "), Qgis.Success, duration=10)
        else:
            print("workspace nepredan")
        #try:
        #    self.timerLayer.timeout.disconnect()
        #    print("sync order vypinani")
        #except:
        #    print("sync order vypinani")
        self.readMapJsonThread(name,service)
        #self.params = list()
        #self.params.append(name)
        #self.params.append(service)        
        #self.dlg.progressBar_loader.show()
        #QgsMessageLog.logMessage("readmapjson")
 
    def checkRemovedLayersInComposition(self, layers):
        composition = self.instance.getComposition()

        for layer in layers:
            #if layer.name() in composition['title']
            pass
    def layerStyleToUpdate(self):        
        layer = iface.activeLayer()
        self.stylesToUpdate.add(layer)
        print("symbology was changed")
    def readMapJsonThread(self,name, service):
        
        nameWithDiacritics = name        
        name = self.removeUnacceptableChars(name)
        
        #if not self.checkLoadedMap(name): ## je nactena mapa?
        if False: ## je nactena mapa?    
      #  if True:
          
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name   +'/file'     
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            data = r.json()   
            #print(data)
        
            self.addComposite(data,service, name)
            QgsMessageLog.logMessage("refreshComposite")
            
        
        else:
            print("debug in readMapJson - false")
            workspace = self.getCompositionWorkspace(name)
            self.selectedWorkspace = workspace 
            #url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name+'/file' 
            try:    
                url = self.URI+'/rest/'+workspace+'/maps/'+name+'/file'     
            except:
                QgsMessageLog.logMessage("compositionSchemaError")
                return
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            data = r.json() 
            ## rozvetveni zdali chce uzivatel otevrit kompozici v novem projektu
            #layers = iface.mapCanvas().layers() ## pokud neexistuej vrstva otazka nema smysl
            layers = QgsProject.instance().mapLayers()
            if len(layers) > 0:
                if self.locale == "cs":
                    msgbox = QMessageBox(QMessageBox.Question, "Layman", "Chcete otevřít kompozici v prázdném projektu QGIS? Váš stávající projekt se zavře. Pokud zvolíte Ne, kompozice se sloučí se stávajícím mapovým obsahem.")
                else:
                    msgbox = QMessageBox(QMessageBox.Question, "Layman", "Do you want open a composition in an empty QGIS project? Your existing project will be closed. If you select No, the composition will be merged with the existing map content.")
                msgbox.addButton(QMessageBox.Yes)
                msgbox.addButton(QMessageBox.No)
                msgbox.setDefaultButton(QMessageBox.No)
                reply = msgbox.exec()
                if (reply == QMessageBox.Yes):
                    iface.newProject()
                    QgsProject.instance().setTitle(data['title'])

                    self.loadService2(data,service, name)
                else:
                    self.loadService2(data,service, name)
                
            else:

                self.loadService2(data,service, name)
            
    def afterCompositionLoaded(self):
        try:
            self.prj.layerWasAdded.disconnect()
        except:
            pass
        print("afterCompositionLoaded")
        #self.prj.layersRemoved.connect(self.checkRemovedLayersInComposition)
        if self.instance.getPermissions() == "w" or self.instance.getPermissions() == "n" :
            ## startuje naslouchani na zmenu do groupy
            prj = QgsProject().instance()
            root = prj.layerTreeRoot()
            print("xxxxxx")
            print(root)
            print("xxxxxx")
            #serverOrder = self.instance.getLayerNamesList()
            #print(serverOrder)
           # root.layerOrderChanged.connect(lambda: self.getLayerGroupTest()) ## tato funkce nesnese otevřenou konzoli
            #root.layerOrderChanged.connect(lambda: self.syncOrder(iface.mapCanvas().layers()))
            ## konec naslouchani

            #self.prj=QgsProject.instance()
            composition = self.instance.getComposition()
            try:
                projection = composition['projection'].replace("epsg:","")
                crs=QgsCoordinateReferenceSystem(int(projection))
               # QgsProject.instance().setCrs(crs)
                print(QgsProject.instance().crs().authid())
                layers = QgsProject.instance().mapLayers().values()    
                #wkt = 'PROJCRS["S-JTSK / Krovak", BASEGEOGCRS["S-JTSK", DATUM["System of the Unified Trigonometrical Cadastral Network", ELLIPSOID["Bessel 1841",6377397.155,299.1528128, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]], ID["EPSG",4156]], CONVERSION["Krovak (Greenwich)", METHOD["Krovak", ID["EPSG",9819]], PARAMETER["Latitude of projection centre",49.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8811]], PARAMETER["Longitude of origin",24.8333333333333, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8833]], PARAMETER["Co-latitude of cone axis",30.2881397527778, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",1036]], PARAMETER["Latitude of pseudo standard parallel",78.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8818]], PARAMETER["Scale factor on pseudo standard parallel",0.9999, SCALEUNIT["unity",1], ID["EPSG",8819]], PARAMETER["False easting",0, LENGTHUNIT["metre",1], ID["EPSG",8806]], PARAMETER["False northing",0, LENGTHUNIT["metre",1], ID["EPSG",8807]]], CS[Cartesian,2], AXIS["southing (X)",south, ORDER[1], LENGTHUNIT["metre",1]], AXIS["westing (Y)",west, ORDER[2], LENGTHUNIT["metre",1]], USAGE[ SCOPE["unknown"], AREA["Europe - Czechoslovakia"], BBOX[47.73,12.09,51.06,22.56]], ID["EPSG",5513]]'
                if crs == 5514:
                    wkt = 'PROJCRS["S-JTSK / Krovak East North", BASEGEOGCRS["S-JTSK", DATUM["System of the Unified Trigonometrical Cadastral Network", ELLIPSOID["Bessel 1841",6377397.155,299.1528128, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]], ID["EPSG",4156]], CONVERSION["Krovak East North (Greenwich)", METHOD["Krovak (North Orientated)", ID["EPSG",1041]], PARAMETER["Latitude of projection centre",49.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8811]], PARAMETER["Longitude of origin",24.8333333333333, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8833]], PARAMETER["Co-latitude of cone axis",30.2881397527778, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",1036]], PARAMETER["Latitude of pseudo standard parallel",78.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8818]], PARAMETER["Scale factor on pseudo standard parallel",0.9999, SCALEUNIT["unity",1], ID["EPSG",8819]], PARAMETER["False easting",0, LENGTHUNIT["metre",1], ID["EPSG",8806]], PARAMETER["False northing",0, LENGTHUNIT["metre",1], ID["EPSG",8807]]], CS[Cartesian,2], AXIS["easting (X)",east, ORDER[1], LENGTHUNIT["metre",1]], AXIS["northing (Y)",north, ORDER[2], LENGTHUNIT["metre",1]], USAGE[ SCOPE["unknown"], AREA["Europe - Czechoslovakia"], BBOX[47.73,12.09,51.06,22.56]], ID["EPSG",5514]]'
                if crs == 4326:
                    wkt = 'GEOGCRS["WGS 84",   DATUM["World Geodetic System 1984", ELLIPSOID["WGS 84",6378137,298.257223563, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]],    CS[ellipsoidal,2],        AXIS["geodetic latitude (Lat)",north,            ORDER[1],ANGLEUNIT["degree",0.0174532925199433]],AXIS["geodetic longitude (Lon)",east, ORDER[2], ANGLEUNIT["degree",0.0174532925199433]],USAGE[SCOPE["unknown"], AREA["World"], BBOX[-90,-180,90,180]], ID["EPSG",4326]]'
                crs = QgsCoordinateReferenceSystem(wkt) 
                #crs = QgsCoordinateReferenceSystem() 
                #crs.createFromProj("+proj=pipeline +step +inv +proj=webmerc +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +step +proj=push +v_3 +step +proj=cart +ellps=WGS84 +step +inv +proj=helmert +x=570.8 +y=85.7 +z=462.8 +rx=4.998 +ry=1.587 +rz=5.261 +s=3.56 +convention=position_vector +step +inv +proj=cart +ellps=bessel +step +proj=pop +v_3 +step +proj=krovak +lat_0=49.5 +lon_0=24.8333333333333 +alpha=30.2881397527778 +k=0.9999 +x_0=0 +y_0=0 +ellps=bessel")
                #crs.createFromProj(QgsDatumTransform().datumTransformToProj(1623)) ## epsg:5514/1623
          
                for layer in layers:
                    layer.setCrs(crs)
            except:
                print("parameter projection was not found")
            
           # QgsProject.instance().crsChanged.connect(self.crsChanged)
            self.project.removeAll.connect(self.removeSignals)
            #self.prj.layerWasAdded.connect(self.layerAdded)
            layers = self.project.mapLayers().values() ## hlidac vrstvy
            self.instance.setIds(layers)
            for layer in layers:
                layerType = layer.type()
                if layerType == QgsMapLayer.VectorLayer:
                    layer.editingStopped.connect(self.layerEditStopped)
                    layer.styleChanged.connect(self.layerStyleToUpdate)
            self.menu_CurrentCompositionDialog.setEnabled(True)                 
            #iface.layerTreeView().currentLayerChanged.connect(lambda: self.syncOrder(iface.mapCanvas().layers()))
            #self.timerLayer = QTimer()
            #self.timerLayer.setInterval(5000)
            #self.timerLayer.timeout.connect(lambda: self.syncOrder([layer for layer in QgsProject.instance().mapLayers().values()])) 
            #self.timerLayer.start()
            self.processingRequest = False

            composition = self.instance.getComposition()
            self.backupComposition = copy.deepcopy(composition) 
            #self.syncComposition = QTimer()
            #self.syncComposition.setInterval(10000)
            #self.syncComposition.timeout.connect(lambda: self.updateComposition()) 
            #self.syncComposition.start()

            root = self.project.layerTreeRoot()
           # root.visibilityChanged.connect(self.changeVisibility)
        try:
            self.dlg.pushButton_map.setEnabled(True)
        except:
            print("different dialog loaded")
        if self.wrongLayers:
            self.wrongLayers = False 
            if self.locale == "cs":
               QMessageBox.information(None, "Layman", "Některé vrstvy nebyly načteny.")
            else:
               QMessageBox.information(None, "Layman", "Some layers was not loaded")

        QgsMessageLog.logMessage("layersLoaded")
    def changeVisibility(self, layerTreeNode):   
        print(layerTreeNode)
        if layerTreeNode.nodeType() == 0:
            print ("Group " + layerTreeNode.name())
            print(layerTreeNode.isVisible())
            sublayers = layerTreeNode.children()
            for lay in sublayers:
                print ("sub " + lay.name())
                self.modifyVisibilityOfLayer(lay.name(), lay.isVisible())
        else:
            if layerTreeNode.nodeType() == 1:
                print ("Layer " + layerTreeNode.name())
                self.modifyVisibilityOfLayer(layerTreeNode.name(), layerTreeNode.isVisible())
            else:
                print ("Error")
    def modifyPathOfLayer(self, name, path):
        composition = self.instance.getComposition()
        #x = self.getCompositionIndexByName()
        for i in range (0, len(composition['layers'])):
            #print("path")        
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)):                
                composition['layers'][i]['path'] = path
       
    def modifyVisibilityOfLayer(self, name, checked):
        composition = self.instance.getComposition()
        #x = self.getCompositionIndexByName()
        for i in range (0, len(composition['layers'])):
            #print("visibility")
            #print(self.removeUnacceptableChars(composition['layers'][i]['title']), self.removeUnacceptableChars(name))
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)):
                #print(composition['layers'][i]['visibility'])
                composition['layers'][i]['visibility'] = checked
                #print(composition['layers'][i]['visibility'])
                #self.patchMap2()

    def removeSignals(self):
        print("removing signals")
        layers = QgsProject.instance().mapLayers().values()
        for layer in layers:
            try:
                layer.editingStopped.disconnect()
            except:
                print("TypeError: disconnect() failed between 'editingStopped' and all its connections")

    def layerAdded(self, layer):
        self.run_CurrentCompositionDialog()

    def layerEditStopped(self):
        layer = iface.activeLayer()
        try:
            self.postRequest(layer.name(), True)
        except:
            pass

    def deleteMapFromServer(self,name):        
        
        url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name    
        response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))
       # print(response)
        if (response.status_code == 200):
            if self.locale == "cs":
            #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " byla úspešně smazána."), Qgis.Success, duration=3)
            else:
            #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was sucessfully deleted."), Qgis.Success, duration=3)
        else:
            if self.locale == "cs":
            #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " nebyla úspešně smazána."), Qgis.Warning, duration=3)
            else:
            #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was not sucessfully deleted."), Qgis.Warning, duration=3)
       # self.refreshMapList()            
        self.refreshListWidgetMaps() ## pro treewidget
        
    def deleteCurrentMap(self):  
        composition = self.instance.getComposition()
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Chcete opravdu smazat tuto kompozici?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Do you want really delete this composition?")
        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+composition['name']    
            response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))         
            if (response.status_code == 200):
                if self.locale == "cs":
                #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + composition['name'] + " byla úspešně smazána."), Qgis.Success, duration=3)
                else:
                #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + composition['name'] + " was sucessfully deleted."), Qgis.Success, duration=3)
            else:
                if self.locale == "cs":
                #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + composition['name'] + " nebyla úspešně smazána."), Qgis.Warning, duration=3)
                else:
                #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + composition['name'] + " was not sucessfully deleted."), Qgis.Warning, duration=3)
          
            self.instance = None
            self.current = None
            self.dlg.close()           
    def deleteMap(self,name, x):   
        print(name, x)
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Chcete opravdu smazat kompozici "+name+"?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Delete map", "Do you want really delete composition "+name+"?")
    
        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            name = self.removeUnacceptableChars(name)
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name    
            response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))
            #print(response)
            #print(response.content)
            if (response.status_code == 200):
                if self.locale == "cs":
                #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " byla úspešně smazána."), Qgis.Success, duration=3)
                else:
                #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was sucessfully deleted."), Qgis.Success, duration=3)
            else:
                if self.locale == "cs":
                #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + name + " nebyla úspešně smazána."), Qgis.Warning, duration=3)
                else:
                #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                    iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + name + " was not sucessfully deleted."), Qgis.Warning, duration=3)
                  
            try:
                del (self.compositeList[x]) 
                self.refreshCompositeList()## pro import map form
                self.dlg.treeWidget_listLayers.clear()
                self.dlg.treeWidget_listLayers.addTopLevelItem(item)
                self.dlg.pushButton_deleteMap.setEnabled(False)
                self.dlg.pushButton_editMeta.setEnabled(False)
                self.dlg.pushButton_setMapPermissions.setEnabled(False)
                self.dlg.pushButton.setEnabled(False)
                self.dlg.pushButton_addRaster.setEnabled(False)
      
            except:
                pass
            #try:
            #self.dlg.listWidget_listLayers.clear()
           # x = self.getCompositionIndexByName(self.dlg.treeWidget.selectedItems()[0].text(0))
            print("cvxcv" + str(x))
            #self.dlg.treeWidget.clear()
            #del (self.compositeList[x]) 
           # for i in range (0, len(self.compositeList)):
           ## self.dlg.listWidget.addItem(self.compositeList[i]['name'])
                
           #     item = QTreeWidgetItem([self.compositeList[i]['title']])
           #     self.dlg.treeWidget.addTopLevelItem(item)
            try:
                checked = self.getConfigItem("mapcheckbox")          
                print(checked)
            except:
                checked = False
            if checked == "0":               
                checked = False
            if checked == "1":               
                checked = True
            print(checked)
            self.loadMapsThread(checked)
            #except:
            #    print("jiny form")
            
        
        
      
    def deleteMapandLayers(self,name, x):        
        try:
            url = self.URI+'/rest/'+self.laymanUsername+'/maps/'+name    
            response = requests.delete(url, headers = self.getAuthHeader(self.authCfg))
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Kompozice byla úspěšně smazána.")
            else:
                QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
            
      
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Warning", "Deleting composition failed.")
            else:
                QMessageBox.information(None, "Warning", "Mazání kompozice selhalo.")
        #self.refreshItems()
        self.deleteMapFromCanvas(x)
        self.dlg.listWidget_listLayers.clear()
        self.dlg.pushButton_deleteLayers.setEnabled(False)
        self.dlg.pushButton.setEnabled(False)
        self.dlg.pushButton_deleteMap.setEnabled(False)
        self.refreshCompositeList()

    def deleteMapFromCanvas(self, x):
        for i in range (0,len(self.compositeList[x]['layers'])):  #[0]['params']['LAYERS']:
            name = self.compositeList[x]['layers'][i]['params']['LAYERS']
            lay = QgsProject.instance().mapLayersByName(name)[0]
            if (lay != None and lay.type() != QgsMapLayer.VectorLayer):
                QgsProject.instance().removeMapLayer(lay.id())
        del (self.compositeList[x])

    def deleteLayerFromCanvas(self, name):        
        lay = QgsProject.instance().mapLayersByName(name)[0]        
        if (lay != None and lay.type() != QgsMapLayer.VectorLayer):
            QgsProject.instance().removeMapLayer(lay.id())
        
        
    def getSelectedLayers(self):
        arr = self.dlg.listWidget_listLayers2.selectedItems()
        layers = []
        for a in arr:
            layer = QgsProject.instance().mapLayersByName(a.text())
            for lay in layer:

                if (lay.type() == QgsMapLayer.VectorLayer):
                    layers.append(lay)
            
        return layers
    def run_getLayer(self):
        self.recalculateDPI()
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            
            
        self.dlgGetLayers.items.clear()
        # show the dialog
        self.dlgGetLayers.show()
        data= self.getExistingLayers()
        for x in range(len(data)):
           # print(data[x]['name'])
            self.dlgGetLayers.items.addItem(data[x]['name'])
        # Run the dialog event loop
        
        result = self.dlgGetLayers.exec_()
       
        
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.
           
            print ("test tlacitka")
   
    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING Atlas"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

      
       # self.thread1.terminate()
        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        authm = QgsApplication.authManager()
        authm.clearCachedConfig(self.authCfg)
        #print "** UNLOAD Atlas"
      ## killing daemons
        #self.thread1.terminate()
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Layman'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar

    #--------------------------------------------------------------------------
    def bounds(self, layers):

        extent = None
        for layer in layers:
            if layer.type() == 0:
                transform = QgsCoordinateTransform(layer.crs(), QgsCoordinateReferenceSystem('EPSG:4326'), QgsProject.instance()) # WGS 84 / UTM zone 33N
                try:
                    layerExtent = transform.transform(layer.extent())
                except QgsCsException:
                    print("exception in transform layer srs")
                    layerExtent = QgsRectangle(-180, -90, 180, 90)
                if extent is None:
                    extent = layerExtent
                else:
                    extent.combineExtentWith(layerExtent)

        return (extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum())
    def copySymbols(self,symbol, tempPath, fileNames):
        for i in range(symbol.symbolLayerCount()):
            sl = symbol.symbolLayer(i)
            if isinstance(sl, QgsSvgMarkerSymbolLayer):
                symbolPath = sl.path();
                shutil.copy(symbolPath, tempPath)
                print("Copying " + str(sl.path()))
                fileNames.append(tempPath + os.sep + os.path.basename(symbolPath))
            else:
                print("Ignoring " + str(sl))

    def setDefaultExtent (self, ext):        
        self.dlg.lineEdit_3.setText(str(ext.xMinimum()))
        self.dlg.lineEdit_4.setText(str(ext.xMaximum()))
        self.dlg.lineEdit_5.setText(str(ext.yMinimum()))
        self.dlg.lineEdit_6.setText(str(ext.yMaximum()))

    def setWritePermissionList(self):
        if self.checkAddedItemDuplicity("write"):
            itemsTextListRead =  [str(self.dlg.listWidget_read.item(i).text()) for i in range(self.dlg.listWidget_read.count())]
            if (self.dlg.comboBox_users.currentText().split(' , ')[0] in itemsTextListRead):
                self.dlg.listWidget_write.addItem(self.dlg.comboBox_users.currentText().split(' , ')[0])
                print("1")
            else:
                self.dlg.listWidget_write.addItem(self.dlg.comboBox_users.currentText().split(' , ')[0])
                self.dlg.listWidget_read.addItem(self.dlg.comboBox_users.currentText().split(' , ')[0])
                print("2")
    def removeWritePermissionList(self):
        self.deleteItem(self.dlg.listWidget_read.currentItem().text())
        self.dlg.listWidget_read.removeItemWidget(self.dlg.listWidget_read.takeItem(self.dlg.listWidget_read.currentRow()))
        #self.dlg.listWidget_write.removeItemWidget(self.dlg.listWidget_write.takeItem(self.dlg.listWidget_write.currentRow()))
        
    def deleteItem(self, itemName):
       
        items_list = self.dlg.listWidget_write.findItems(itemName,QtCore.Qt.MatchExactly)
        
        for item in items_list:
            r = self.dlg.listWidget_write.row(item)
            self.dlg.listWidget_write.takeItem(r)    
    def loadJsonLayer(self, fileName):    
        name = (os.path.splitext(os.path.basename(fileName))[0])
        vlayer = QgsVectorLayer(fileName, name,"ogr")
        sldPath = os.path.splitext(fileName[:-4])[0] + ".sld"
        qmlPath = os.path.splitext(fileName[:-4])[0] + ".qml"
        
        sldExists = os.path.isfile(sldPath)
        qmlExists = os.path.isfile(qmlPath)
        if (qmlExists):
            print("qml loaded")
            vlayer.loadNamedStyle(qmlPath)
        elif (sldExists):
            vlayer.loadSldStyle(os.path.splitext(fileName)[0]+ ".sld")
            print("sld loaded")
        QgsProject.instance().addMapLayer(vlayer)
        vlayer.triggerRepaint()
    def checkLoadedLayer(self):
        layers = iface.layerTreeView().selectedLayers()
        if (len(layers) > 0):
            self.json_export()    
        else:
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není načtena vrstva!")
            else:
                QMessageBox.information(None, "Message", "You must load layer first!")
    def tranformExtent(self, ext):
        src = QgsProject.instance().crs()
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        transfomedExtent = tform.transform(ext)
        return transfomedExtent


    def getEmptyComposite(self, compositeName, compositeTitle):        
       # compositeEPSG  = "epsg:4326"   
        compositeEPSG = QgsProject.instance().crs().authid().lower()
        ext = iface.mapCanvas().extent() 
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        #if (self.dlg.lineEdit_3.text() == "" or self.dlg.lineEdit_4.text() == "" or self.dlg.lineEdit_5.text() == "" or self.dlg.lineEdit_6.text() == ""):
        #   ext = iface.mapCanvas().extent() 
        #   #ext = (self.tranformExtent(ext))
        #   xmin = ext.xMinimum()
        #   xmax = ext.xMaximum()
        #   ymin = ext.yMinimum()
        #   ymax = ext.yMaximum()
        
        #else:   
        #   xmin = self.dlg.lineEdit_3.text()
        #   xmax = self.dlg.lineEdit_4.text()
        #   ymin = self.dlg.lineEdit_5.text()
        #   ymax = self.dlg.lineEdit_6.text()  
        #   src = QgsProject.instance().crs()
        #   dest = QgsCoordinateReferenceSystem(4326)
        #   tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        #   #print(xmax,ymax)
        #   #print(xmin,ymin)
        #   max = tform.transform(QgsPointXY(float(xmax),float(ymax)))
        #   min = tform.transform(QgsPointXY(float(xmin),float(ymin)))
        #   xmin = min.x()
        #   xmax = max.x()
        #   ymin = min.y()
        #   ymax = max.y()
        #center = tform.transform(QgsPointXY(iface.mapCanvas().extent().center().x(), iface.mapCanvas().extent().center().y()))
        center = QgsPointXY(iface.mapCanvas().extent().center().x(), iface.mapCanvas().extent().center().y())
        abstract = self.dlg.lineEdit_7.text()  
        self.schemaURl= "https://raw.githubusercontent.com/hslayers/map-compositions/2.0.0/schema.json"
        self.schemaVersion = "2.0.0"
        #comp = {"abstract":abstract,"center":[center.x(),center.y()],"current_base_layer":{"title":"Composite_base_layer"},"extent":[str(xmin),str(ymin),str(xmax),str(ymax)],"groups":{"guest":"w"},"layers":[],"name":compositeName,"projection":compositeEPSG,"scale":1,"title":compositeTitle,"units":"m","user":{"email":"","name":self.laymanUsername}}
        if LooseVersion(self.laymanVersion) > LooseVersion("1.16.0"):
            comp = {"abstract":abstract,"center":[center.x(),center.y()],"current_base_layer":{"title":"Composite_base_layer"},"describedBy": self.schemaURl,"schema_version": self.schemaVersion,"nativeExtent": [xmin,ymin,xmax,ymax],"extent":[xmin,ymin,xmax,ymax],"groups":{"guest":"w"},"layers":[],"name":compositeName,"projection":compositeEPSG,"scale":1,"title":compositeTitle,"units":"m","user":{"email":"","name":self.laymanUsername}}
        else:
            comp = {"abstract":abstract,"center":[center.x(),center.y()],"current_base_layer":{"title":"Composite_base_layer"},"extent":[str(xmin),str(ymin),str(xmax),str(ymax)],"groups":{"guest":"w"},"layers":[],"name":compositeName,"projection":compositeEPSG,"scale":1,"title":compositeTitle,"units":"m","user":{"email":"","name":self.laymanUsername}}
        print(comp)
        
       ## iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + compositeName + " byla úspešně vytvořena."), Qgis.Success, duration=3)
        return comp
    def loadLocalFile(self):
        options = QFileDialog.Options()
        dialog = QFileDialog()
        dialog.setStyleSheet("QPushButton {color: #fff !important;text-transform: uppercase; font-size:"+self.fontSize+"; text-decoration: none;   background: #72c02c;   padding: 20px;  border-radius: 50px;    display: inline-block; border: none;transition: all 0.4s ease 0s;} QPushButton:hover{background: #66ab27 ;}QPushButton:disabled{background: #64818b ;}");
        try:
            if self.locale == "cs":
                fileName = dialog.getOpenFileName(None,"Načíst soubor", "","GeoJson Files (*.geojson);;Json Files (*.json)", options=options)
            else:
                fileName = dialog.getOpenFileName(None,"Load file", "","GeoJson Files (*.geojson);;Json Files (*.json)", options=options)

            print ("načítám json ze souboru:" + fileName[0])
            if (fileName[0] != ""):
                self.loadJsonLayer(fileName[0])
        except:
            pass
    def modifyMap(self, x = None): 
        if not x:
            x = self.getCompositionIndexByName()
        name = self.removeUnacceptableChars(self.dlg.lineEdit_title.text())
        #self.compositeList[x]['name'] = self.dlg.lineEdit_name.text()        
        self.compositeList[x]['name'] = name
        self.compositeList[x]['abstract'] = self.dlg.lineEdit_abstract.text()
        self.compositeList[x]['title'] = self.dlg.lineEdit_title.text()
        src = QgsProject.instance().crs()
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        #transformace extentu
     

        self.compositeList[x]['extent'][0] = self.dlg.lineEdit_xmin.text().replace(",",".")
        self.compositeList[x]['extent'][2] = self.dlg.lineEdit_xmax.text().replace(",",".")
        self.compositeList[x]['extent'][1] = self.dlg.lineEdit_ymin.text().replace(",",".")
        self.compositeList[x]['extent'][3] = self.dlg.lineEdit_ymax.text().replace(",",".")
   
        center = tform.transform(QgsPointXY(iface.mapCanvas().extent().center().x(), iface.mapCanvas().extent().center().y()))
        self.compositeList[x]['center'][0] = center.x()
        self.compositeList[x]['center'][1] = center.y()
        #print(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'])       
        oldName = self.dlg.lineEdit_name.text()
        response = requests.delete(self.URI+'/rest/'+self.laymanUsername+'/maps/'+oldName,headers = self.getAuthHeader(self.authCfg))
       
        #self.dlg.close()
        #self.afterCloseEditMapDialog()
        self.importMap(x, 'mod')
        
        try:
            #self.refreshCompositeList()
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Map metadata was saved successfully."), Qgis.Success, duration=3)
        except:
            pass
    def modifyMapNew(self): 
        composition = self.instance.getComposition()
        #name = self.removeUnacceptableChars(self.dlg.lineEdit_title.text())
        #self.compositeList[x]['name'] = self.dlg.lineEdit_name.text()
        self.compositionDict[composition['name']] = self.dlg.lineEdit_title.text()
        #composition['name'] = name
        composition['abstract'] = self.dlg.lineEdit_abstract.text()
        composition['title'] = self.dlg.lineEdit_title.text()
        src = QgsProject.instance().crs()
        dest = QgsCoordinateReferenceSystem(4326)
        tform = QgsCoordinateTransform(src, dest, QgsProject.instance())
        #transformace extentu
     

        composition['extent'][0] = self.dlg.lineEdit_xmin.text().replace(",",".")
        composition['extent'][2] = self.dlg.lineEdit_xmax.text().replace(",",".")
        composition['extent'][1] = self.dlg.lineEdit_ymin.text().replace(",",".")
        composition['extent'][3] = self.dlg.lineEdit_ymax.text().replace(",",".")
   
        center = tform.transform(QgsPointXY(iface.mapCanvas().extent().center().x(), iface.mapCanvas().extent().center().y()))
        composition['center'][0] = center.x()
        composition['center'][1] = center.y()
        #print(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'])       
             
        #print(self.patchMap2())
        if (self.patchMap2() == 200):
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Metadata byla úspěšně upravena."), Qgis.Success, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Map metadata was saved successfully."), Qgis.Success, duration=3)
        else:
            if self.locale == "cs":
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Metadata nebyla upravena."), Qgis.Warning, duration=3)
            else:
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Map metadata was not saved."), Qgis.Warning, duration=3)
        
        self.dlg.close()
        composition = self.instance.getComposition()
        try:
            if self.locale == "cs":
                self.dlg.setWindowTitle("Kompozice: "+composition['title'])
            else:
                self.dlg.setWindowTitle("Composition: "+composition['title'])
        except:
            pass
    def saveLocalFile(self):
        
        layer = self.iface.activeLayer()       
        print(layer.commitChanges()) ## změny uloženy
        path = iface.activeLayer().dataProvider().dataSourceUri()
        path = path.split("|")[0].replace("'","")
        if (layer == None):
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není načtena vrstva!")
            else:
                QMessageBox.information(None, "Message", "You must load layer first!")
        else:
           # defaultDir = QDir().home()
            defaultDir = os.path.dirname(path)
            #print(defaultDir)
            #print(defaultDir +os.sep+ str(layer.name()) + ".geojson")
            #print(QDir().homePath() +os.sep+ str(layer.name()) + ".geojson")
            dialog = QFileDialog()
            dialog.setFileMode(1)
            dialog.setDirectory(defaultDir)
            #print(dialog.directory().path())
           # layer_name = dialog.getSaveFileName(None, "Save file", QDir().homePath() +os.sep+ str(layer.name()) + ".geojson", "*.geojson")        
            if self.locale == "cs":
                layer_name = dialog.getSaveFileName(None, "Uložit soubor", defaultDir +os.sep+ str(layer.name()) + ".geojson", "*.geojson")   
            else:
                layer_name = dialog.getSaveFileName(None, "Save file", defaultDir +os.sep+ str(layer.name()) + ".geojson", "*.geojson")   
            
            self.json_export_local(layer_name[0], layer)

    def json_export_local(self, layer_name, lay):     
        import shutil
        filePath = self.getTempPath(layer_name)  
        ogr_driver_name = "GeoJSON" 
        project = QgsProject.instance()
        fileNames = []
        ## zde musí být zajištěna vektorová vrstva
        layer = lay        
        layerType = layer.type()
        if layerType == QgsMapLayer.VectorLayer:

            renderer = layer.renderer()
            hasIcon = False
            if isinstance(renderer, QgsSingleSymbolRenderer):

                self.copySymbols(renderer.symbol(), tempfile.gettempdir(), fileNames)
                hasIcon = True


            layerCrs = qgis.utils.iface.activeLayer().crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)          
            result2 = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, layer_name, "utf-8", crs, ogr_driver_name) # export jsonu do souboru
            
            if(result2[0] == 2): ## testujeme zda není soubor otevřený v jiném procesu / návratový kod 2
                
                tempFile = self.getTempPath(os.path.basename(layer_name.replace(".geojson", "") ))
                print(tempFile)
                #QMessageBox.information(None, "Layman", "It is not possible overwrite this file. File is already open in other process.")  
                sld_temp_filename = tempFile.replace("geojson", "sld") 
                qml_temp_filename = tempFile.replace("geojson", "qml")
                layer.saveSldStyle(sld_temp_filename)
                layer.saveNamedStyle(qml_temp_filename)
                result2 = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, tempFile, "utf-8", crs, ogr_driver_name)
                print(result2)
                if(result2[0] == 2):
                    if self.locale == "cs":
                        QMessageBox.information(None, "Layman", "Soubor není možné přepsat. Je již otevřený jiným procesem.")  
                    else:
                        QMessageBox.information(None, "Layman", "It is not possible overwrite this file. File is already open in other process.")  
                    return
                if os.path.basename(layer_name.replace(".geojson", "")) != '':
                    QgsProject.instance().removeMapLayer(layer.id())
                    print(tempFile, layer_name)
                    shutil.copy(tempFile, layer_name)
                    shutil.copy(sld_temp_filename, layer_name.replace(".geojson", ".sld"))
                    shutil.copy(qml_temp_filename, layer_name.replace(".geojson", ".qml"))
                    self.loadJsonLayer(layer_name)
                
            else:                
                sld_filename = layer_name.replace("geojson", "sld")     
                qml_filename = layer_name.replace("geojson", "qml") 
                result3 = False
                layer.saveSldStyle(sld_filename)
                layer.saveNamedStyle(qml_filename)

    def json_export(self, layer_name, id=None):     

        filePath = self.getTempPath(self.removeUnacceptableChars(layer_name).lower())  
        ogr_driver_name = "GeoJSON"     
        project = QgsProject.instance()
        fileNames = []      
        if id != None:
            layers = QgsProject.instance().mapLayersByName(layer_name)
            print(layers)
            for lay in layers:
                if lay.id() == id:
                    layer = lay
                    print("zzzzz")
        else:    
            layer = QgsProject.instance().mapLayersByName(layer_name)[0]       
        
        layerType = layer.type()
        if layerType == QgsMapLayer.VectorLayer:

            renderer = layer.renderer()
            hasIcon = False
            if isinstance(renderer, QgsSingleSymbolRenderer):
                self.copySymbols(renderer.symbol(), tempfile.gettempdir(), fileNames)
                hasIcon = True
            #layerCrs = qgis.utils.iface.activeLayer().crs().authid()
            layerCrs = layer.crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)# původně bylo
            layer_filename = filePath 
            ## transform test
            if os.path.exists(layer_filename):
                os.remove(layer_filename)
            else:
                print("The file does not exist")
            epsg = layer.crs().authid()
            parameter = {'INPUT': layer, 'TARGET_CRS': epsg, 'OUTPUT': layer_filename}
            print(processing.run('qgis:reprojectlayer', parameter))
            ## transforma test
          #  result2 = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, layer_filename, "utf-8", crs, ogr_driver_name) # export jsonu do souboru
            
            sld_filename = filePath.replace("geojson", "sld").lower()     
            qml_filename = filePath.replace("geojson", "qml").lower() 
            if os.path.exists(sld_filename):
                os.remove(sld_filename)
            else:
                print("The file does not exist")
            if os.path.exists(qml_filename):
                os.remove(qml_filename)
            else:
                print("The file does not exist")
            result3 = False
            layer.saveSldStyle(sld_filename)
            self.insertPictureToQML(layer)
            layer.saveNamedStyle(qml_filename)
            self.insertBinaryToQml(layer, qml_filename)
    def json_exportMix(self, layer):    
    
        filePath = self.getTempPath(self.removeUnacceptableChars(layer.name() + str(layer.geometryType())).lower())  
        ogr_driver_name = "GeoJSON"     
        project = QgsProject.instance()
        fileNames = []              
        
        layerType = layer.type()
        if layerType == QgsMapLayer.VectorLayer:

            renderer = layer.renderer()
            hasIcon = False
            if isinstance(renderer, QgsSingleSymbolRenderer):

                self.copySymbols(renderer.symbol(), tempfile.gettempdir(), fileNames)
                hasIcon = True


            #layerCrs = qgis.utils.iface.activeLayer().crs().authid()
            layerCrs = layer.crs().authid()
            crs = QgsCoordinateReferenceSystem(layerCrs)# původně bylo
            layer_filename = filePath 
            ## transform test
            parameter = {'INPUT': layer, 'TARGET_CRS': 'EPSG:4326', 'OUTPUT': layer_filename}
            processing.run('qgis:reprojectlayer', parameter)
            ## transforma test
          #  result2 = qgis.core.QgsVectorFileWriter.writeAsVectorFormat(layer, layer_filename, "utf-8", crs, ogr_driver_name) # export jsonu do souboru

            sld_filename = filePath.replace("geojson", "sld").lower()            
            result3 = False
            layer.saveSldStyle(sld_filename)
        return layer_filename
    def checkValidAttributes(self, layer_name):
        layers = QgsProject.instance().mapLayersByName(layer_name)
        if len(layers) > 1:
            for l in layers:
                if (isinstance(l, QgsVectorLayer)):
                   
                    layers.clear()
                    layers.append(l)
                    break
        isValid = True
        if (isinstance(layers[0], QgsVectorLayer)):
            pom =layers[0].getFeature(1)  
        else:
            return True
        for nam in pom.fields().names():
            if (nam == ''):
                isValid = False
        return isValid


    def checkWgsExtent(self, layer):
        WgsXmax = 180
        WgsXmin = -180
        WgsYmax = 90
        WgsYmin = -90
        extent = layer.extent()
        if (extent.xMaximum() > WgsXmax or extent.xMinimum() < WgsXmin or extent.yMaximum() > WgsYmax or extent.yMinimum() < WgsYmin ):
            return False
        else:
            return True

    def insertBinaryToQml(self,layer, stylePath):
        single_symbol_renderer = layer.renderer()
        #stylePath = r"C:\Users\Honza\Downloads\xxx\out.qml"
        layer.saveNamedStyle(stylePath)
        if isinstance(single_symbol_renderer, QgsCategorizedSymbolRenderer):
            #print(single_symbol_renderer.embeddedRenderer())
            symbol  = layer.renderer().categories()
            for i in symbol: 
                #print(i.symbol().symbolLayer(0))
        
                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()  
                    print(type(i.symbol().symbolLayer(0).subSymbol() )) 
                    if path[:4] != "base":
                        if os.path.exists(path):
                            with open(path, "rb") as image_file:
                                encoded_string = base64.b64encode(image_file.read())
                                #print(encoded_string)    
                            path2 = i.symbol().symbolLayer(0).path()          
                            decoded =   encoded_string.decode("utf-8") 
                            path3 = ("base64:"  + decoded)
                            #i.symbol().symbolLayer(0).setPath("base64:"  + decoded)  
                
                            #print(i.symbol().symbolLayer(0).path())
                
                            print(path2)
                            print(path3)
                            with open(stylePath, 'r') as file :
                                filedata = file.read()
       
                            filedata = filedata.replace(path2, path3)

                            with open(stylePath, 'w') as file:
                                file.write(filedata)
                j = 0
                pom = True
        
                while pom:
                    #print(i.symbol().symbolLayer(j))
                    if isinstance(i.symbol().symbolLayer(j), QgsMarkerLineSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                
                        path = (i.symbol().symbolLayer(j).subSymbol().symbolLayer(0).path())
                        #print(path)   
                        if path[:4] != "base":
                            if os.path.exists(path):
                                with open(path, "rb") as image_file:
                                    encoded_string = base64.b64encode(image_file.read())
                                    #print(encoded_string)    
                                path = i.symbol().symbolLayer(j).subSymbol().symbolLayer(0).path()         
                                decoded =   encoded_string.decode("utf-8") 
                                path2 = ("base64:"  + decoded)
                                #i.symbol().symbolLayer(0).setPath("base64:"  + decoded)  
                                #print(path2)
                                #print(i.symbol().symbolLayer(0).path())
                                with open(stylePath, 'r') as file :
                                    filedata = file.read()
                           
                                filedata = filedata.replace(path, path2)

                                with open(stylePath, 'w') as file:
                                    file.write(filedata)
                    j = j +1
                    try:
                        i.symbol().symbolLayer(j).subSymbol
                    except:
                        pom = False
                #if isinstance(i.symbol().symbolLayer(0), QgsMarkerLineSymbolLayer):
                #    path = i.symbol().symbolLayer(0).subSymbol().symbolLayer(0).path()
        
                #    if os.path.exists(path):
                #        with open(path, "rb") as image_file:
                #            encoded_string = base64.b64encode(image_file.read())
                #            #print(encoded_string)    
                #        path2 = i.symbol().symbolLayer(0).subSymbol().symbolLayer(0).path()
                #        decoded =   encoded_string.decode("utf-8") 
                #        #print("base64:"  + decoded)
                #        #i.symbol().symbolLayer(0).setPath("base64:"  + decoded)  
                #        path3 = ("base64:"  + decoded)
                #        with open(stylePath, 'r') as file :
                #            filedata = file.read()
       
                #        filedata = filedata.replace(path2, path3)

                #        with open(stylePath, 'w') as file:
                #            file.write(filedata)
   
        elif isinstance(single_symbol_renderer, QgsRuleBasedRenderer):
            print(type(layer.renderer()))
            symbol  = layer.renderer().rootRule().children()
            for i in symbol: 
                print(i.symbol().symbolLayer(0))
        
                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()
        
                    if os.path.exists(path):
                        with open(path, "rb") as image_file:
                            encoded_string = base64.b64encode(image_file.read())
                            #print(encoded_string)    
                        path2 = i.symbol().symbolLayer(0).path()   
                        decoded =   encoded_string.decode("utf-8") 
                        #print("base64:"  + decoded)
                        #i.symbol().symbolLayer(0).setPath("base64:"  + decoded)  
                        path3 = ("base64:"  + decoded)
                        with open(stylePath, 'r') as file :
                            filedata = file.read()
       
                        filedata = filedata.replace(path2, path3)

                        with open(stylePath, 'w') as file:
                            file.write(filedata)
    def insertPictureToQML(self, layer):       
        single_symbol_renderer = layer.renderer()
        
        if isinstance(single_symbol_renderer, QgsCategorizedSymbolRenderer):
            symbol  = layer.renderer().categories()
            for i in symbol: 
                print(i.symbol().symbolLayer(0))
               
                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()
                    try:
                        if os.path.exists(path):
                            with open(path, "rb") as image_file:
                                encoded_string = base64.b64encode(image_file.read())
                                #print(encoded_string)    
                            decoded =   encoded_string.decode("utf-8") 
                            #print("base64:"  + decoded)
                            i.symbol().symbolLayer(0).setPath("base64:"  + decoded)  
                            print(i.symbol().symbolLayer(0).path())
                    except:
                        print("binary path")
        elif isinstance(single_symbol_renderer, QgsRuleBasedRenderer):
            print(type(layer.renderer()))
            symbol  = layer.renderer().rootRule().children()
            for i in symbol: 
                print(i.symbol().symbolLayer(0))
       
                if isinstance(i.symbol().symbolLayer(0), QgsSvgMarkerSymbolLayer) or isinstance(i.symbol().symbolLayer(0), QgsRasterMarkerSymbolLayer):
                    path = i.symbol().symbolLayer(0).path()
            
                    if os.path.exists(path):
                        with open(path, "rb") as image_file:
                            encoded_string = base64.b64encode(image_file.read())
                            #print(encoded_string)    
                        decoded =   encoded_string.decode("utf-8") 
                        #print("base64:"  + decoded)
                        i.symbol().symbolLayer(0).setPath("base64:"  + decoded)  
                        print(i.symbol().symbolLayer(0).path())
        elif isinstance(single_symbol_renderer, QgsSingleSymbolRenderer):
            try:
                symbols = single_symbol_renderer.symbol()

            except:
                print("nevhodny typ" + str(type(single_symbol_renderer)))
                return
            for symbol in symbols:
                if isinstance(symbol, QgsSvgMarkerSymbolLayer) or isinstance(symbol, QgsRasterMarkerSymbolLayer):
                    path = symbol.path()
                    try:
                        if os.path.exists(path):
                            with open(path, "rb") as image_file:
                                encoded_string = base64.b64encode(image_file.read())
                                #print(encoded_string)    
                            decoded =   encoded_string.decode("utf-8") 
                            #print("base64:"  + decoded)
                            symbol.setPath("base64:"  + decoded)  
                            print(symbol.path())
                    except:
                        print("binary path")
        
    def mergeGeojsons(self, paths, output, layerName):
        feats = list()
        #top = """
        #{
        #"type": "FeatureCollection",
        #"name": "jan_vrobelmix",
        #"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG::3857" } },
        #"features": ["""
        #"crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG::3857" } },
        top = '''
        {
        "type": "FeatureCollection",
        "name": "'''+layerName+'''",        
        "crs": { "type": "name", "properties": { "name": "urn:ogc:def:crs:EPSG:3857" } },
        "features": ['''
        bottom = """]
        }
        """
        for path in paths:
            with open(path) as json_file:
                data = json.load(json_file)
                for p in data['features']:
                   
                    feats.append(p)
          
        #print(top + str(feats)[1:-1] + bottom) 

        text_file = open(output, "w")
        text_file.write((top + str(feats)[1:-1] + bottom).replace("'", "\""))
        text_file.close()
    def callPostRequest(self, layers):    
       # self.processingList = []        
        #if self.batchLength == 0:
        #    self.batchLength = self.batchLength + len(layers)
        self.ThreadsA = set()
        for thread in threading.enumerate(): 
            self.ThreadsA.add(thread.name)
        self.uploaded = 0
        self.batchLength = len(layers)
        if self.locale == "cs":
            self.dlg.label_progress.setText("Úspěšně exportováno: 0 / " + str(len(layers)) )
        else:
            self.dlg.label_progress.setText("Sucessfully exported 0 / " + str(len(layers)) )
        #else:
        #    self.batchLength = self.batchLength + len(layers)
        #    if self.locale == "cs":
        #        self.dlg.label_progress.setText("úspěšně exportováno: "+str(self.done)+" / " + str(self.batchLength) )
        #    else:
        #        self.dlg.label_progress.setText("Sucessfully exported "+str(self.done)+" / " + str(self.batchLength) )
        self.layersToUpload = len(layers)
        for item in layers:
            print (item.text(0))
            
            
                

            self.postRequest(item.text(0))
        #self.dlg.label_progress.setText("")
    def setCurrentLayer(name):
        layers = QgsProject.instance().mapLayersByName(name) 
        if(len(layers) >1):
            layerss = QgsProject.instance().mapLayers().values()    
            i = 0
            for layer in layerss:  
                if layers[0].name == layer.name():
                    if (i == item.currentIndex()):
                        i = i + 1
                        break
                    i = i + 1
        return i
    def transformLayer(self, layer):
        layer = iface.activeLayer()
        crsSrc = layer.crs()
        print(crsSrc.authid())
        crsDest = QgsCoordinateReferenceSystem(4326, QgsCoordinateReferenceSystem.EpsgCrsId)
        print(crsSrc, crsDest)
        xform = QgsCoordinateTransform(crsSrc, crsDest, 5514, 4326)
        feats=[]

        if (layer.geometryType() == 0):
            destLayer = QgsVectorLayer("Point?crs=EPSG:4326","lay","memory")
        if (layer.geometryType() == 1):
            destLayer = QgsVectorLayer("Linestring?crs=EPSG:4326","lay","memory")
        if (layer.geometryType() == 2):
            destLayer = QgsVectorLayer("Polygon?crs=EPSG:4326","lay","memory")

        for f in layer.getFeatures():
            g = f.geometry()
    
            g.transform(xform)
            print(g)
            f.setGeometry(g)
            feats.append(f)
    
        destLayer.dataProvider().addFeatures(feats)
        return destLayer
    def setChunkSizeBigger(self):
        self.CHUNK_SIZE = 2098152
    def checkFileSizeLimit(self, size):
        if size > 2000000000:
            QgsMessageLog.logMessage("limitSize")
    def patchThread2(self, layer_name, data, id):
        self.json_export(layer_name, id)
        
        #try:
        geoPath = self.getTempPath(self.removeUnacceptableChars(layer_name))

        if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
            if os.path.getsize(geoPath) > 800000000:
                self.checkFileSizeLimit(os.path.getsize(geoPath))
                self.setChunkSizeBigger()
            self.postInChunks(layer_name, "patch")                          
        else:
            self.patchLayer(layer_name, data)
    def patchThread(self, layer_name, data,q, progress):
        #print("layername: " + layer_name)
        #print(self.removeUnacceptableChars(layer_name))
        #print(self.mixedLayers)
        
        if layer_name in self.mixedLayers:
            layers = QgsProject.instance().mapLayersByName(layer_name)  
            paths = list()
            for layer in layers:
                print(paths.append(self.json_exportMix(layer)))
            self.mergeGeojsons(paths, self.getTempPath(self.removeUnacceptableChars(layer.name())),self.removeUnacceptableChars(layer.name()))

        else:
            self.json_export(layer_name)
        #self.json_export(layer_name)     
        
        geoPath = self.getTempPath(self.removeUnacceptableChars(layer_name))
        #try:
        if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
            if os.path.getsize(geoPath) > 800000000:
                self.checkFileSizeLimit(os.path.getsize(geoPath))
                self.setChunkSizeBigger()
            self.postInChunks(layer_name, "patch")                          
        else:
            self.patchLayer(layer_name, data)
        #time.sleep(1)
        if progress:
            
            self.importedLayer = layer_name
            self.processingList[q][2] = 1
            try:
                response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name), headers = self.getAuthHeader(self.authCfg))
                print("after upload")
                print(response.content)
                if (response.status_code == 400):
                    time.sleep(3)
                    response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name), headers = self.getAuthHeader(self.authCfg))
            except:
                if self.locale == "cs":                
                    QMessageBox.information(None, "Layman import layer", "Připojení se serverem selhalo!")
                else:
                    QMessageBox.information(None, "Layman import layer", "Connection with server failed!")
                return
            
            if (response.status_code == 200):
                try:
                    self.uploaded = self.uploaded + 1
                except:
                    pass
                QgsMessageLog.logMessage("imports_"+layer_name)
                
            else:
                QgsMessageLog.logMessage("importn_"+layer_name)
           ## self.writeState(1)
            QgsMessageLog.logMessage("exportPatch")
            try:
                self.toUpload - 1
                QgsMessageLog.logMessage("layersUploaded")
            except:
                pass
            
            #iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer  " + layer_name + " was imported successfully."), Qgis.Success, duration=3)
    def returnPathIfFileExists(self, path, ext, onlyExt = False):
        print(path, ext)
        pathWithoutExt = path.replace(ext,"")
        ext = ext.lower()
        if ext == ".tif" or ".tiff":
            if os.path.exists(pathWithoutExt + ".tfw") or os.path.exists(pathWithoutExt + ".TFW"):
                print("external file detected")
                if not onlyExt:
                    return pathWithoutExt + ".tfw"
                else:
                    return ".tfw"
            else:
                return None
        if ext == ".jp2":
            if os.path.exists(pathWithoutExt + ".j2w"):
                if not onlyExt:
                    return pathWithoutExt + ".j2w"
                else:
                    return ".j2w"
            else:
                return None
        if ext == ".jpg":
            if os.path.exists(pathWithoutExt + ".jgw"):
                if not onlyExt:
                    return pathWithoutExt + ".jgw"
                else:
                    return ".jgw"
            else:
                return None
        if ext == ".png":
            if os.path.exists(pathWithoutExt + ".pgw"):
                if not onlyExt:
                    return pathWithoutExt + ".pgw"
                else:
                    return ".pgw"
            else:
                return None
                
    def replaceInfiniteInSLD(self, filepath):
        with open(filepath, 'r') as file :
          filedata = file.read()

        # Replace the target string
        filedata = filedata.replace('"inf"', '"9999"')

        # Write the file out again
        with open(filepath, 'w') as file:
          file.write(filedata)

    #def replaceNoDataInSLD(self, filepath):
    #    with open(filepath, 'r') as file :
    #      filedata = file.read()

    #    # Replace the target string
    #    filedata = filedata.replace('"inf"', '"9999"')

    #    # Write the file out again
    #    with open(filepath, 'w') as file:
    #      file.write(filedata)        
    def postRasterThread(self, layer,data, q,progress, patch):
        QgsMessageLog.logMessage("enableProgress")

        #data['crs'] = 'EPSG:4326'
        data['crs'] = layer.crs().authid()
        print(layer.name())
        stylePath = self.getTempPath(self.removeUnacceptableChars(layer.name())).replace("geojson", "sld")
        layer.saveSldStyle(stylePath)
        self.replaceInfiniteInSLD(stylePath)
        layer_name = layer.name()
        path = layer.dataProvider().dataSourceUri()
        basename = os.path.basename(path)
        if basename == 'OUTPUT.tif':
            name = self.removeUnacceptableChars(layer_name)
            newPath = path.replace(basename, name+ ".tif")
            shutil.copy2(path, newPath)
            path = newPath
        ext = (layer.dataProvider().dataSourceUri()[-4:])
        files = {'file': (path, open(path, 'rb')),'style': open(stylePath, 'rb')} 
        if os.path.getsize(path) > 800000000:
            self.checkFileSizeLimit(os.path.getsize(path))
            self.setChunkSizeBigger()
        externalFile = self.returnPathIfFileExists(path,ext)
        print(externalFile)
        if (os.path.getsize(path) > self.CHUNK_SIZE):
            if patch:
            #self.postInChunks(layer_name, "post")
            #if (reqType == "patch"):
                #url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layer_name.lower().replace(" ", "_")
                url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+self.removeUnacceptableChars(layer_name)
                r = requests.delete(url,headers = self.getAuthHeader(self.authCfg))
           
        
            #self.registerLayer(layer_name)
            url = self.URI + "/rest/"+self.laymanUsername+"/layers"
            name = self.removeUnacceptableChars(layer_name) 
            ## registrovat obě vrstvy musím pokud existuje externí souory,poslat jako pole?
            

            #files = [('file', open(geoPath, 'rb')), ('style', open(stylePath, 'rb'))]
            if externalFile:
                payload = {        
                #'file': name.lower()+ext,
                'file': [name.lower()+ext,name.lower() + self.returnPathIfFileExists(path,ext, True)],
                'title': name,
                'crs': str(layer.crs().authid()),
                'style': open(stylePath, 'rb') 
                }    
            else:
                payload = {        
                'file': name.lower()+ext,                
                'title': name,
                'crs': str(layer.crs().authid())                
                }    
            files = {'style': open(stylePath, 'rb')} 
            #if externalFile != None:
            #    files = {'file': (externalFile, open(externalFile, 'rb')),} 
            #    response = requests.request("POST", url,  data=payload, files = files, headers = self.getAuthHeader(self.authCfg)) 
            #else:
            response = requests.request("POST", url, files=files,  data=payload, headers = self.getAuthHeader(self.authCfg)) 
            print(response.content)
            layer_name = self.removeUnacceptableChars(layer_name)
            filePath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) ## chunky se ukládají do adresáře v tempu
        
            if not (os.path.exists(filePath)):
                os.mkdir(filePath)
            #file = self.getTempPath(layer_name) 
            if externalFile:
                #### externi soubory
                f = open(externalFile, 'rb')
                externalExt = externalFile[-4:]
                arr = []
            
                for piece in self.read_in_chunks(f):
                    arr.append(piece)
                resumableFilename = layer_name+ externalExt
                layman_original_parameter = "file"  
                resumableTotalChunks = len(arr)
                #print ("resumable" + resumableFilename)
                print(resumableTotalChunks)
                self.processChunks(arr, resumableFilename, layman_original_parameter,resumableTotalChunks, layer_name,filePath,externalExt)
                ###############
            f = open(path, 'rb')
            arr = []
            for piece in self.read_in_chunks(f):
                arr.append(piece)
            #layer_name = self.removeUnacceptableChars(layer_name)
            
            
            
            resumableFilename = layer_name+ ext
            layman_original_parameter = "file"  
            resumableTotalChunks = len(arr)
            #print ("resumable" + resumableFilename)
            print(resumableTotalChunks)
            self.processChunks(arr, resumableFilename, layman_original_parameter,resumableTotalChunks, layer_name,filePath,ext)
            
            #iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer  " + layer_name + " was imported successfully."), Qgis.Success, duration=3)
            
        else:
            #name = self.removeUnacceptableChars(layer_name) 
            #if externalFile:
            #    payload = {        
            #    #'file': name.lower()+ext,
            #    'file': [name.lower()+ext,name.lower() + self.returnPathIfFileExists(path,ext, True)],
            #    'title': name,
            #    'crs': str(layer.crs().authid()),
            #    'style': open(stylePath, 'rb') 
            #    }    
            #else:
            #    payload = {        
            #    'file': name.lower()+ext,                
            #    'title': name,
            #    'crs': str(layer.crs().authid())
            #    }    

            if patch:          
                url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+self.removeUnacceptableChars(layer_name)
                r = requests.delete(url,headers = self.getAuthHeader(self.authCfg))
            if externalFile:               
               
          
                zipPath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) + os.sep +self.removeUnacceptableChars(layer_name)+".zip"
                zipObj = ZipFile(zipPath, 'w')
                # Add multiple files to the zip              
                
                zipObj.write(externalFile, os.path.basename(externalFile))
                zipObj.write(path,os.path.basename(path))
                zipObj.close()
                files = {'file': (zipPath, open(zipPath, 'rb')),'style': open(stylePath, 'rb')} 
           
            data['crs'] = 'EPSG:4326'
            response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/layers', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
            print(response.content)
            res = self.fromByteToJson(response.content)
        
            print(res)
            try:
                if res['code'] == 4:
                    QgsMessageLog.logMessage("unsupportedCRS")
                    QgsMessageLog.logMessage("resetProgressbar")
                    return
            except:
                print("uuid")

        if self.layersToUpload == 1:
            QgsMessageLog.logMessage("resetProgressbar")
            if self.locale == "cs":
                self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(1) + " / " + str(1) )
            else:
                self.dlg.label_progress.setText("Sucessfully exported: " +  str(1) + " / " + str(1) )

        QgsMessageLog.logMessage("export")
        QgsMessageLog.logMessage("disableProgress")
    def processChunks(self, arr, resumableFilename, layman_original_parameter,resumableTotalChunks, layer_name,filePath,ext ):
        for i in range (1, len(arr)+1):  ##chunky jsou počítané od 1 proto +1  
            failedRequest = -1
            print("chunk" + str(i))
            file = arr[i-1] # rozsekaná část souboru
            resumableChunkNumber = i  # cislo casti
            payload = {
            'file' : "chunk"+str(i)+ ext,
            'resumableFilename': resumableFilename,
            'layman_original_parameter': layman_original_parameter,
            'resumableChunkNumber': i,
            'resumableTotalChunks': resumableTotalChunks
            }           
            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layer_name+'/chunk'   
            f = open(filePath + os.sep+"chunk"+str(i)+ ext, "wb")
            f.write(bytearray(arr[i-1]))
            f.close()              
            files = {'file': (layer_name.lower().replace(" ", "_")+ext, open(filePath +os.sep+ "chunk"+str(i)+ext, 'rb')),}  
            #response = requests.post(url, files = files, data=payload, headers = self.getAuthHeader(self.authCfg))
            while failedRequest != 0:
                try:
                    failedRequest = 0
                    response = requests.post(url, files = files, data=payload, headers = self.getAuthHeader(self.authCfg))
                    print(response.content)
                except:
                    failedRequest = failedRequest + 1
                    if failedRequest == 3:
                        QgsMessageLog.logMessage("errorConnection")
                        QgsMessageLog.logMessage("resetProgressbar")
                        if self.locale == "cs":
                            self.dlg.label_progress.setText("Úspěšně exportováno: " +  str(0) + " / " + str(1) )
                        else:
                            self.dlg.label_progress.setText("Sucessfully exported: " +  str(0) + " / " + str(1) )
                        return

            try:    
                if self.layersToUpload == 1:
                    QgsMessageLog.logMessage("progress"+str(i)+";"+str(resumableTotalChunks))
            except:
                    QgsMessageLog.logMessage("mProgress"+str(i)+";"+str(resumableTotalChunks))
             #print(layer_name)

        QgsMessageLog.logMessage("export")
    def postThread(self, layer_name,data, q,progress):
        if layer_name in self.mixedLayers:
            layers = QgsProject.instance().mapLayersByName(layer_name)  
            paths = list()
            for layer in layers:
                paths.append(self.json_exportMix(layer))
            self.mergeGeojsons(paths, self.getTempPath(self.removeUnacceptableChars(layer.name()))),self.removeUnacceptableChars(layer.name())

        else:
            self.json_export(layer_name)
        #### transform test
        #path = self.transformLayer(layer_name)
        ######
      #  sldPath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "sld")
      #  qmlPath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "qml")
        geoPath = self.getTempPath(self.removeUnacceptableChars(layer_name))
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0"):
            stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "qml")
        else:
            stylePath = self.getTempPath(self.removeUnacceptableChars(layer_name)).replace("geojson", "sld")
        if (os.path.getsize(geoPath) > self.CHUNK_SIZE):
            if os.path.getsize(geoPath) > 800000000:
                self.checkFileSizeLimit(os.path.getsize(geoPath))
                self.setChunkSizeBigger()
            self.postInChunks(layer_name, "post")
        else:
            if(os.path.isfile(stylePath)): ## existuje style?
                #files = [('file', open(geoPath, 'rb')), ('sld', open(qmlPath, 'rb'))]
                files = [('file', open(geoPath, 'rb')), ('style', open(stylePath, 'rb'))]
            else:
                files = {'file': (geoPath, open(geoPath, 'rb')),} 

    

            response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/layers', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
            print(response.content)
            status = response.status_code
            print(status)
        #time.sleep(1.5)
        if progress:

           # QgsMessageLog.logMessage("export")
            response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name), headers = self.getAuthHeader(self.authCfg))
         
            if (response.status_code == 200):
                try:
                    self.uploaded = self.uploaded + 1
                except:
                    pass
                QgsMessageLog.logMessage("imports_"+layer_name)
            elif (status == 413):
                QgsMessageLog.logMessage("importl_"+layer_name)
            else:
                
                QgsMessageLog.logMessage("importn_"+layer_name)
            self.importedLayer = layer_name
            self.processingList[q][2] = 1
            #self.writeState(1)
            QgsMessageLog.logMessage("export")
            
            #QMessageBox.information(None, "Message", "Layer exported sucessfully.")
    def getLayerGroupTest(self):
        if self.run == False:
            self.run = True
            return
        self.syncOrder2(self.getLayersOrder())
    
    def getLayersOrder(self):
        bridge = iface.layerTreeCanvasBridge()
        root = bridge.rootGroup()
        return root.layerOrder()
    def getLayerGroup(self, layer):
        try:
            serverOrder = self.instance.getLayerNamesList()
        except:
            return
        if self.run == False:
            self.run = True
            return
        self.syncOrder2(self.getLayersOrder())
        self.run = False        
        #time.sleep(1)
        self.processingRequest = True
        if (layer != None):
            prj = QgsProject().instance()
            root = prj.layerTreeRoot()
            #print("test")
            for child in root.children():
                #print(child)
                if isinstance(child, QgsLayerTreeGroup): ##pokud je intance group tak hledáme shodu pres layer ID
                    #print ("- group: " + child.name())
                    for child2 in child.children():
                       # print ("- layer: "+ "  ID: " + child2.layerId())
                        #print(iface.activeLayer().id(),child2.layerId())  
                        #print(child2.name())                 
                        if isinstance(child2, QgsLayerTreeLayer):
                            try:
                                splitted = child2.layerId().split(" ")                            
                            except:
                               # print("Nejedna se o vhodnou vrstvu")
                                #print(child2.name())
                                return
                            for s in splitted:
                               # print(iface.activeLayer().id(),s)
            
                                if (layer.id() == s):                    
                                    #print(iface.activeLayer().name(), child.name())
                                    self.addLayerToPath(layer.name(), child.name())
                                    return
                elif isinstance(child, QgsLayerTreeLayer):
                    
                    print(child.layerId(), layer.id())
                    if (layer.id() == child.layerId()): 
                        self.checkLayerPath(layer.name())
                   # print ("- layer: "+ "  ID: " + child.layerId())
                   # print(child.parent().isGroup(child.parent()))
                   # print(child.parent().depth())
                   #   
        self.processingRequest = False                     
    def addLayerToPath(self, name, groupName):
        #x = self.getCompositionIndexByName()
        composition = self.instance.getComposition()
       # print(x)
        for i in range (0, len(composition['layers'])):
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)): #
                composition['layers'][i]['path'] = groupName
                print("modifing " + composition['name'] + "adding group name " + groupName)
                #self.importMap(x, 'mov') ## ukládáme změny na server
                #QgsMessageLog.logMessage("path added")
                
                
    def checkLayerPath(self, name):
        #x = self.getCompositionIndexByName()
        composition = self.instance.getComposition()
        for i in range (0, len(composition['layers'])):
            if (self.removeUnacceptableChars(composition['layers'][i]['title']) == self.removeUnacceptableChars(name)): 
                try:
                    if composition['layers'][i]['path'] != "":
                        del composition['layers'][i]['path']
                        print("modifing " + composition['name'] + "layer " + name)
                        #self.importMap(x, 'mov') ## ukládáme změny na server
                    else:
                        pass                        
                except:
                    print("path not found. Skipping")

    def getCompositionIndexByName(self, name=""):
        if name == "":
            current = self.current
        else:
            current = name
        print(self.current)
        for x in range (0, len(self.compositeList)):
            if self.removeUnacceptableChars(self.compositeList[x]['title']) == self.removeUnacceptableChars(current):
                return x
    def checkPossibleChars(self, layername):
        unacceptable = "/*+-%!?:><&@#'"
        for ch in layername:
            if ch in unacceptable:
                return False
        return True

    def readDimFromCapatibilites(self, url, name):
        r = requests.get(url + "?service=wms&request=GetCapabilities")
        print("redDim")
        #print(r.content)
        dimension = ""
        e = ET.ElementTree(ET.fromstring(r.content))
        #e = ET.ElementTree.fromstring(r.content)
        check = False
        for elt in e.iter():    
            if (elt.tag.split("}")[1] == "Title"):
                if (self.removeUnacceptableChars(elt.text)== self.removeUnacceptableChars(name)):
                    check = True
            if (elt.tag.split("}")[1] == "Dimension"):
                if check:
                    print(elt.text)
                    dimension = elt.text 
                    check = False                  
                    return dimension
    def postRequest(self, layer_name, auto=False):     
        nameCheck = True
        validExtent = True
        layers = QgsProject.instance().mapLayersByName(layer_name)       
        #if (isinstance(layers[0], QgsVectorLayer)):
        #    if layers[0].featureCount() == 0:
        #        if self.locale == "cs":                
        #            QMessageBox.information(None, "Layman import layer", "Nelze nahrát vrstvu: "+layers[0].name()+", protože neobsahuje žádný prvek!")
        #        else:
        #            QMessageBox.information(None, "Layman import layer", "Unable to load layer: "+layers[0].name()+", because it has no feature!")
        #        return
        layers[0].setName(layer_name)
        if len(layers) > 1:
            for l in layers:
                if (isinstance(l, QgsVectorLayer)):                   
                    layers.clear()
                    layers.append(l)
                    break
        
        

        if (re.match('[0-9]{1}', layer_name)): ## nesmí být nesmysl v názvu na prvním místě
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Není povoleno číslo v prvním znaku.")
            else:
                QMessageBox.information(None, "Layman", "Number in first character is not allowed.")
            nameCheck = False
        if not self.checkPossibleChars(layer_name):
            QgsMessageLog.logMessage("wrongName")
            return
        


        #if not self.checkWgsExtent(layers[0]):
        if False:
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Prostorový rozsah vrstvy je mimo rozsah WGS 84. (EPSG: 4326)")
            else:
                QMessageBox.information(None, "Layman", "Extent of layer is out of WGS 84 range. (EPSG: 4326)")
            validExtent = False

        if (nameCheck and validExtent):
                     
           # crs = layers[0].crs().authid()
            crs = "EPSG:3857"          
            data = { 'name' :  str(layer_name).lower(), 'title' : str(layer_name)}            
            if (self.checkValidAttributes(layer_name)):
                if (self.checkExistingLayer(layer_name)):
                    
                    #print("vrstva již existuje")
                    if not auto:
                        if self.locale == "cs":
                            msgbox = QMessageBox(QMessageBox.Question, "Layman", "Vrstva "+layer_name+" již na serveru existuje. Chcete přepsat její geometrii?")
                        else:
                            msgbox = QMessageBox(QMessageBox.Question, "Layman", "Layer "+layer_name+" already exists in server. Do you want overwrite it´s geometry?")
                        msgbox.addButton(QMessageBox.Yes)
                        msgbox.addButton(QMessageBox.No)
                        msgbox.setDefaultButton(QMessageBox.No)
                        reply = msgbox.exec()
                        if (reply == QMessageBox.Yes):
                            self.dlg.progressBar.show() 
                            self.dlg.label_import.show()
                            q = self.setProcessingItem(layer_name)
                            if (isinstance(layers[0], QgsVectorLayer)):
                                threading.Thread(target=lambda: self.patchThread(layer_name,data, q, True)).start()
                            if (isinstance(layers[0], QgsRasterLayer)): 
                                if layers[0].isValid():
                                    if layers[0].crs().authid() in self.supportedEPSG:
                                        ext = layers[0].dataProvider().dataSourceUri()[-4:]
                                        if ext.lower() != ".bmp": 
                                            threading.Thread(target=lambda: self.postRasterThread(layers[0],data, q,True, True)).start()   
                                        else:
                                            QgsMessageLog.logMessage("BmpNotSupported")
                                    else:
                                        QgsMessageLog.logMessage("wrongCrs")
                                else:
                                    QgsMessageLog.logMessage("invalid")
                            #print("vrstva již existuje")
                        
                        else:
                            self.batchLength = self.batchLength - 1 
                    else:
                       
                        q = self.setProcessingItem(layer_name)
                        if (isinstance(layers[0], QgsVectorLayer)):
                            threading.Thread(target=lambda: self.patchThread(layer_name,data, q, True)).start()
                        if (isinstance(layers[0], QgsRasterLayer)): 
                            if layers[0].isValid():
                                if layers[0].crs().authid()  in self.supportedEPSG:
                                    ext = layers[0].dataProvider().dataSourceUri()[-4:]
                                    if ext.lower() != ".bmp":
                                        threading.Thread(target=lambda: self.postRasterThread(layers[0],data, q,True, True)).start()   
                                    else:
                                        QgsMessageLog.logMessage("BmpNotSupported")  
                                else:
                                    QgsMessageLog.logMessage("wrongCrs")
                            else:
                                QgsMessageLog.logMessage("invalid")    
                else:
            
                    self.layerName = layer_name
                   # if (self.checkEpsg(layer_name)):
                    if(True): ##Pravděpodobně nebude třeba testovat EPSG, pokud se detekuje, je vrstva transformována. 
                      #  print (layer_name)
                        if not auto:
                            self.dlg.progressBar.show() 
                            self.dlg.label_import.show()
                        if auto:
                            read = self.instance.getAllPermissions()['read']
                            write = self.instance.getAllPermissions()['write']
                            data['access_rights.read'] =  self.listToString(read)
                            data['access_rights.write'] = self.listToString(write)
                          
                            print("dfasfsadfdddddddddddddddddd")
                        q = self.setProcessingItem(layer_name)
                        
                        if (isinstance(layers[0], QgsVectorLayer)):
                            threading.Thread(target=lambda: self.postThread(layer_name,data, q,True)).start()   
                        if (isinstance(layers[0], QgsRasterLayer)): 
                            if layers[0].isValid():
                                if layers[0].crs().authid()  in self.supportedEPSG:
                                    ext = layers[0].dataProvider().dataSourceUri()[-4:]
                                    if ext.lower() != ".bmp":
                                        threading.Thread(target=lambda: self.postRasterThread(layers[0],data, q,True, False)).start()   

                                    else:
                                        QgsMessageLog.logMessage("BmpNotSupported")
                                else:
                                    QgsMessageLog.logMessage("wrongCrs")
                            else:
                                QgsMessageLog.logMessage("invalid")
                    #        if response.status_code == 200:
                    #            iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer  " + layer_name + " was imported successfully."), Qgis.Success, duration=3)
                    #        else:
                    #            iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer  " + layer_name + " was not imported."), Qgis.Warning, duration=3)
                    else:
                        if self.locale == "cs":
                            QMessageBox.information(None, "Layman", "Použijte EPSG:4326")
                        else:
                            QMessageBox.information(None, "Layman", "Use EPSG:4326")
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Layman", "Vrstva "+layer_name+" nemá atributy!")
                else:
                    QMessageBox.information(None, "Layman", "Layer "+layer_name+" does not have attributes!")
    def setProcessingItem(self, layer_name):
        queue = len(self.processingList)
        self.processingList.append([queue, layer_name, 0])
        return queue
    def postRequest2(self, layer_name):     
        nameCheck = True
        validExtent = True
        layers = QgsProject.instance().mapLayersByName(layer_name)         
        layers[0].setName(layer_name)
        if len(layers) > 1:
            for l in layers:
                if (isinstance(l, QgsVectorLayer)):                   
                    layers.clear()
                    layers.append(l)
                    break
        
        

        if (re.match('[0-9]{1}', layer_name)): ## nesmí být nesmysl v názvu na prvním místě
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Není povoleno číslo v prvním znaku.")
            else:
                QMessageBox.information(None, "Layman", "Number in first character is not allowed.")
            nameCheck = False
        
        #print(layer_name)


        if not self.checkWgsExtent(layers[0]):
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Prostorový rozsah vrstvy je mimo rozsah WGS 84. (EPSG: 4326)")
            else:
                QMessageBox.information(None, "Layman", "Extent of layer is out of WGS 84 range. (EPSG: 4326)")
            validExtent = False

        if (nameCheck and validExtent):
                     
            crs = layers[0].crs().authid()
            crs = "EPSG:4326"
            data = { 'name' :  str(layer_name).lower(), 'title' : str(layer_name), 'crs' : str(crs) } 
            
            if (self.checkValidAttributes(layer_name)):
                if (self.checkExistingLayer(layer_name)):
                    
                   # print("vrstva již existuje")
                    if self.locale == "cs":
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Vrstva "+layer_name+" již na serveru existuje. Chcete přepsat její geometrii?")
                    else:
                        msgbox = QMessageBox(QMessageBox.Question, "Layman", "Layer "+layer_name+" already exists in server. Do you want overwrite it´s geometry?")
                    msgbox.addButton(QMessageBox.Yes)
                    msgbox.addButton(QMessageBox.No)
                    msgbox.setDefaultButton(QMessageBox.No)
                    reply = msgbox.exec()
                    if (reply == QMessageBox.Yes):
                     
                        threading.Thread(target=lambda: self.patchThread(layer_name,data, False)).start()
                        #print("vrstva již existuje")
                        
                    else:
                        pass
                else:
            
                    self.layerName = layer_name
                   # if (self.checkEpsg(layer_name)):
                    if(True): ##Pravděpodobně nebude třeba testovat EPSG, pokud se detekuje, je vrstva transformována. 
                      #  print (layer_name)
                        self.dlg.progressBar.show() 
                        self.dlg.label_import.show()
                        threading.Thread(target=lambda: self.postThread(layer_name,data, False)).start()    
                  
                    else:
                        if self.locale == "cs":
                            QMessageBox.information(None, "Layman", "Použijte EPSG:4326")
                        else:
                            QMessageBox.information(None, "Layman", "Use EPSG:4326")
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Layman", "Vrstva "+layer_name+" nemá atributy!")
                else:
                    QMessageBox.information(None, "Layman", "Layer "+layer_name+" does not have attributes!")

    def addExistingLayerToComposite(self, name, type):
        #self.dlg.label_loading.show() 
        #self.dlg.progressBar_loader.show()
        
        nameInList = name
        oldname = name
        title = name
        name = self.removeUnacceptableChars(name).lower()
        try:
            self.dlg.pushButton_addRaster.setEnabled(False)
        except:
            print("different dialog")
        x = self.dlg.listWidget.currentRow()
        if self.checkLayerOnLayman(name):
            inComposite = name in self.isRasterLayerInComposite(x, name)
            if not(inComposite):
                if (type == "raster"):
                    self.importMapEnvironmnet(False)
                    self.threadAddRaster = threading.Thread(target=lambda: self.addExistingLayerToCompositeThread(nameInList,x))
                    self.threadAddRaster.start()
                if (type == "wms"): 
                    
                    #nameInList = nameInList.split(" ")[0]
                    threading.Thread(target=lambda: self.addExistingWMSLayerToCompositeThread(name, nameInList,x)).start()
                if (self.current):
                    url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+name           
                    r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                    data = r.json()
                    url = data['wms']['url']
                    layerNameTitle = data['title']
                    epsg =""
                    self.loadWms(url, name,layerNameTitle, "", epsg, groupName = '', subgroupName = '', timeDimension={})
                    
                    
                self.dlg.progressBar.show() 
                self.dlg.label_import.show()
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Message", "Kompozice již obsahuje vrstvu "+title+"!")
                else:
                    QMessageBox.information(None, "Message", "Composition already include layer "+title+"!")
        else:
            
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Nelze načíst vrstvu: "+title)
            else:
                QMessageBox.information(None, "Layman", "Something went wrong with this layer: "+title)
    
    def addExistingLayerToCompositeThread(self, title, x):
        name = self.removeUnacceptableChars(title).lower()
        response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(name), headers = self.getAuthHeader(self.authCfg))
        res = self.fromByteToJson(response.content)
        #print(res)
        wmsUrl = res['wms']['url']
        wfsUrl = res['wfs']['url']
        
        self.existLayer = False
        #self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(name),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","FROMCRS":"EPSG:3857","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
        if (self.dlg.radioButton_wms.isChecked()):
            self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"opacity":1,"url": wmsUrl ,"params":{"LAYERS": str(name),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
        if (self.dlg.radioButton_wfs.isChecked()):
            self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(title),"className":"OpenLayers.Layer.Vector","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"name": str(name),"opacity":1 ,"protocol":{"format": "hs.format.WFS","url": wfsUrl,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"visibility": True,"dimensions":{}})
        self.importMap(x, 'add', 1)
        #self.refreshLayerListReversed()
           
        #self.dlg.label_loading.hide() 
        
        #self.dlg.progressBar_loader.hide()
        time.sleep(1)
        QgsMessageLog.logMessage("addRaster")
    def isXYZ(self, name):
        layer = QgsProject.instance().mapLayersByName(name)[0]
        params = layer.dataProvider().dataSourceUri().split("&")
        layers = list()
        for p in params:
            #param = p.split("=")  
            print(p)
            if(str(p) == "type=xyz"):
                return True

        return False
    def addExistingWMSLayerToCompositeThread(self, title,nameInList, x):
        print("nameInList"+ nameInList)
        name = self.removeUnacceptableChars(title).lower()
        #response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(name), verify=False)
        #res = self.fromByteToJson(response.content)
        #print(res)
       # wmsUrl = res['wms']['url']
        dimension = ""
        layer = QgsProject.instance().mapLayersByName(nameInList)[0]
        params = layer.dataProvider().dataSourceUri().split("&")
        if not (self.isXYZ(layer.name())):
            params = layer.dataProvider().dataSourceUri().split("&")
            layers = list()
            for p in params:
                #print(p)
                param = p.split("=")                
                if(str(param[0]) == "crs"):
                    crs = (param[1])
                if(str(param[0]) == "format"):
                    format = (param[1])   
                   # print(format)
                if(str(param[0]) == "url"):
                    url = (param[1])   
                    #print(url) 
                if(str(param[0]) == "layers"):
                    layers.append(param[1])   
                if(str(param[0]) == "timeDimensionExtent"):
                    dimension = (param[1]) 
                 #   print(layers) 
                    #   
                    #      
            if (len(layers) == 1):
                layers = str(layers).replace("[", "").replace("]", "").replace("'", "")
            else:
                layers = str(layers).replace("'", "")           
            self.existLayer = False
            print(dimension)
            if dimension == "":
                self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS","dimensions":{},"singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
            else:
             
                self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS","dimensions": { "time": { "default": dimension.split(",")[0], "name": "time", "unitSymbol": None, "units": "ISO8601", "value": dimension.split(",")[0], "values": dimension} },"singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5})
            #self.importMap(x, "mod")
            self.importMap(x, 'add', 1)
            time.sleep(1)
            #self.refreshLayerListReversed()
           
            #self.dlg.label_loading.hide() 
        
            #self.dlg.progressBar_loader.hide()
        else:
            for p in params:
                param = p.split("=")  
                #print(p)
                if(param[0] == "url"):
                    url = param[1] 
            crs = layer.crs().authid()    
            self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"XYZ","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": "","INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})    
           
            self.importMap(x, 'add', 1)
            
            time.sleep(1)
            self.refreshLayerListReversed() ## mozna bude treba odstranit kvuli padum
        
        QgsMessageLog.logMessage("addRaster")
    def saveXYZ(self, layer): 
        #title = self.removeUnacceptableChars(layer.name()).lower()      
        title = layer.name()     
        dimension = ""
        params = layer.dataProvider().dataSourceUri().split("&")
        composition = self.instance.getComposition()
        for p in params:
            param = p.split("=")  
            #print(p)
            if(param[0] == "url"):
                url = param[1] 
        crs = layer.crs().authid()    
        composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":title,"className":"XYZ","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": "","INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})    
           
    def addExistingWMSLayerToCompositeThread2(self, title,nameInList):
        composition = self.instance.getComposition()
        print("nameInList"+ nameInList)
        name = self.removeUnacceptableChars(title).lower()
        #response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(name), verify=False)
        #res = self.fromByteToJson(response.content)
        #print(res)
       # wmsUrl = res['wms']['url']
        dimension = ""
        layer = QgsProject.instance().mapLayersByName(nameInList)[0]
        params = layer.dataProvider().dataSourceUri().split("&")
        if not (self.isXYZ(layer.name())):
            params = layer.dataProvider().dataSourceUri().split("&")
            layers = list()
            for p in params:
                #print(p)
                param = p.split("=")                
                if(str(param[0]) == "crs"):
                    crs = (param[1])
                if(str(param[0]) == "format"):
                    format = (param[1])   
                   # print(format)
                if(str(param[0]) == "url"):
                    url = (param[1])   
                    #print(url) 
                if(str(param[0]) == "layers"):
                    layers.append(param[1])   
                if(str(param[0]) == "timeDimensionExtent"):
                    dimension = (param[1]) 
                 #   print(layers) 
                    #   
                    #      
            if (len(layers) == 1):
                layers = str(layers).replace("[", "").replace("]", "").replace("'", "")
            else:
                layers = str(layers).replace("'", "")           
            self.existLayer = False
            print(dimension)
            if dimension == "":
                composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS","dimensions":{},"singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
            else:
                #dim = { "time": { "default": dimension.split(",")[0], "name": "time", "unitSymbol": None, "units": "ISO8601", "value": dimension.split(",")[0], "values": dimension} }
               # print({"dimensions": { "time": { "default": dimension.split(",")[0], "name": "time", "unitSymbol": None, "units": "ISO8601", "value": dimension.split(",")[0], "values": dimension} }})
                #print({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS","dimensions": { "time": { "default": dimension.split(",")[0], "name": "time", "unitSymbol": None, "units": "ISO8601", "value": dimension.split(",")[0], "values": dimension} },"singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5})
                
                composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"HSLayers.Layer.WMS","dimensions": { "time": { "default": dimension.split(",")[0], "name": "time", "unitSymbol": None, "units": "ISO8601", "value": dimension.split(",")[0], "values": dimension} },"singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": layers,"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":format,"VERSION":"1.3.0"},"ratio":1.5})
            #self.importMap(x, "mod")
            #self.patchMap2()
            time.sleep(1)
            #self.refreshLayerListReversed()
           
            #self.dlg.label_loading.hide() 
        
            #self.dlg.progressBar_loader.hide()
        else:
            for p in params:
                param = p.split("=")  
                #print(p)
                if(param[0] == "url"):
                    url = param[1] 
            crs = layer.crs().authid()    
            composition['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(nameInList).replace("'", ""),"className":"XYZ","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": url ,"params":{"LAYERS": "","INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})    
           
            #self.patchMap2()
            
            time.sleep(1)
            
        
        QgsMessageLog.logMessage("addRaster")
    def getStyle(self, layer_name):        
        if self.selectedWorkspace:
            response = requests.get(self.URI+'/rest/'+self.selectedWorkspace+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', headers = self.getAuthHeader(self.authCfg))
        else:
            response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', headers = self.getAuthHeader(self.authCfg))
        #h = requests.head(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', headers = self.getAuthHeader(self.authCfg))
        #header = h.headers
        #content_type = header.get('content-type')
        print("zz")
        #print(contentType)
        res = response.content
        res = res.decode("utf-8")
        if (res[0:5] == "<qgis" and response.status_code == 200):
            print("got qml")
            suffix = ".qml"

        if (res[0:5] == "<?xml" and response.status_code == 200):
            print("got sld")
            suffix = ".sld"
        try:
            tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layer_name) + suffix
        except:
            print("symbologie nenalezena")
            return (400,"")
        #print(tempf)
        with open(tempf, 'wb') as f:
            f.write(response.content)
        return response.status_code, suffix.replace(".","")
    def getSLD(self, layer_name):
        response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/' + self.removeUnacceptableChars(layer_name)+ '/style', headers = self.getAuthHeader(self.authCfg))
        #response = requests.get('https://layman.lesprojekt.cz/rest/lay3/layers/' + layer_name+ '/style') test
        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layer_name)+ ".sld"
        #print(tempf)
        with open(tempf, 'wb') as f:
            f.write(response.content)
        #print(response.status_code)
        #print("sld")
        return response.status_code
        
    def addExistingMapToMemory(self, name):
        response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/maps/'+str(name), headers = self.getAuthHeader(self.authCfg))
        res = self.fromByteToJson(response.content)
        print(res)
        wmsUrl = res['wms']['url']
        
        x = self.dlg.listWidget.currentRow()


        self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(name),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(name),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
        self.importMap(x, 'add', 1)
        self.refreshLayerList()

    def layerInfoRedirect(self, name):
        url = self.URI+'/rest/'+self.laymanUsername+"/layers/" + name
        print(url)
        response = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        r = self.fromByteToJson(response.content)
        try:
            url = r['metadata']['record_url']
            webbrowser.open(url, new=2) ## redirect na micku pro více info
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Odkaz není k dispozici.")
            else:
                QMessageBox.information(None, "Layman", "Link is unavailable.")
    def checkLayerOnLayman(self, layer_name, workspace=""):
        if self.selectedWorkspace:
            url = self.URI+'/rest/'+self.selectedWorkspace+"/layers/"+layer_name
        else:
            url = self.URI+'/rest/'+self.laymanUsername+"/layers/"+layer_name
        print(url)
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        #print(r.content)        
        try:
            data = r.json()
        
            if data['wms']['status'] == 'NOT_AVAILABLE' or data['wms']['status'] == 'PENDING':
                return False
            else:
                return True
        except:
            return True # validní vrstva nemá status

    def checkServiceAvailability(self):
        try:
            if (isinstance(self.dlg.mMapLayerComboBox.currentLayer(),QgsRasterLayer)):
                self.dlg.radioButton_wfs.setEnabled(False)
            else:
                self.dlg.radioButton_wfs.setEnabled(True)
        except:
            pass
    def addLayerToComposite(self,x):
        if (isinstance(self.dlg.mMapLayerComboBox.currentLayer(),QgsRasterLayer)) and self.dlg.mMapLayerComboBox.currentLayer().dataProvider().uri().uri() != "":            
            print("External WMS detected")
            self.addExternalWMSToComposite(self.dlg.mMapLayerComboBox.currentLayer().name())
        if (isinstance(self.dlg.mMapLayerComboBox.currentLayer(),QgsVectorLayer)) or self.dlg.mMapLayerComboBox.currentLayer().dataProvider().uri().uri() == "":
            self.dlg.pushButton.setEnabled(False)
            self.compositeListOld = copy.deepcopy(self.compositeList) ## list pred upravou pro vraceni zmen
            #layers = self.getSelectedLayers() #odkomentovat pro zapnuti nacitani vrstev z listwidgetu
            layers = []
            layers.append(self.dlg.mMapLayerComboBox.currentLayer())
            successful = 0
            print (len(layers))
            #try:
            #    step = self.getProgressBarStep(len(layers))
            #except:
            #    if self.locale == "cs":
            #        QMessageBox.information(None, "Layman", "Není vybrána žádná vrstva!")
            #    else:
            #        QMessageBox.information(None, "Layman", "No layer selected!")
        
            for i in range (0, len(layers)):
                print(type(layers[i]))           
            
                print (self.isLayerInComposite(x))
                print (layers[i].name() in self.isLayerInComposite(x))
                inComposite = layers[i].name() in self.isLayerInComposite(x)
                layerName = self.removeUnacceptableChars(layers[i].name()).lower()
                if (self.checkExistingLayer(layers[i].name()) and inComposite):
                    j = self.getLayerInCompositePosition(x)
                    print("j je: " + str(j))
                
            
             
                    self.postRequest(layers[i].name())
                    layerName = self.removeUnacceptableChars(layers[i].name())
           
                else:
                    self.postRequest(layers[i].name())
                    wmsStatus = 'PENDING'
                    j = 0
                    while ((wmsStatus == 'PENDING') and (j < 10)):
                        print("waiting")
                        print(wmsStatus)
                        print (self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(layerName))
                        #response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(layerName), verify=False)
                        response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(layerName), headers = self.getAuthHeader(self.authCfg))
                        res = self.fromByteToJson(response.content)
                 
                        print(res)
                        try:
                            #wmsStatus = res['wms']['status']
                            wmsStatus = res['wms']['url']
                        except:
                            #wmsStatus = "done"
                            wmsStatus = "PENDING"
                        time.sleep(1)
                        j = j + 1
            

                    print(res)
                    try:
                        wmsUrl = res['wms']['url']
                    except:
                        wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'/ows'
                    try:
                        wfsUrl = res['wfs']['url']
                    except:
                        wfsUrl = self.URI+'/geoserver/'+self.laymanUsername+'/wfs'
                    #self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(layerName),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(layers[i].name()),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","FROMCRS":"EPSG:3857","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
                    if (self.dlg.radioButton_wms.isChecked()):
                        self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"opacity":1,"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
                    if (self.dlg.radioButton_wfs.isChecked()):
                        self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(layers[i].name()),"className":"OpenLayers.Layer.Vector","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"name": str(layerName),"opacity":1 ,"protocol":{"format": "hs.format.WFS","url": wfsUrl},"ratio":1.5,"visibility": True,"dimensions":{}})
                    successful = successful + 1
                    #self.dlg.progressBar.setValue(self.dlg.progressBar.value()+step)
                    self.dlg.progressBar.show() 
                    self.dlg.label_import.show()
                    self.importMapEnvironmnet(False)
                    threading.Thread(target=lambda: self.importMap(x, "add", successful) ).start()
                    #self.importMap(x, "add", successful) 
    def addLayerToComposite2(self,composition, layersList):
        layersList = self.removeRastersWithoutCrs(layersList)
        print(layersList)
        
        for layer in layersList:
            
            if (isinstance(layer,QgsRasterLayer)) and layer.dataProvider().uri().uri() != "":            
                print("External WMS detected")
                self.addExternalWMSToComposite(layer.name())
            if (isinstance(layer,QgsVectorLayer))  or layer.dataProvider().uri().uri() == "":     
                
                layers = []
                layers.append(layer)
                successful = 0
                print (len(layers))
                path = ""
                path = self.getGroupOfLayer(layer)
                if path == 'root':
                    path = ""
                
                
                #print("path " + str(path))
                for i in range (0, len(layers)):
                    for item in self.currentSet: 
                        if self.removeUnacceptableChars(item[0]) == self.removeUnacceptableChars(layers[i].name()):
                            service = item[1].lower()
                    self.dlg.progressBar_loader.show()
                    layerName = self.removeUnacceptableChars(layers[i].name()).lower()
                    #if self.layerServices[layerName] == "HSLayers.Layer.WMS":
                    if service == 'wms':
                        print(layers[i].crs().authid())
                        print(layers[i].crs().authid() in self.supportedEPSG)
                        print("xx")
                        if layers[i].crs().authid() in self.supportedEPSG:
                            if self.isXYZ(layers[i].name()):
                                self.saveXYZ(layers[i])
                            else:
                                wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'_wms/ows'
                                composition['layers'].append({"metadata":{},'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":1,"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":20,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
                                print(composition)
                    #if (self.dlg.radioButton_wfs.isChecked()):
                    #elif self.layerServices[layerName] == "OpenLayers.Layer.Vector":
                    elif service == 'wfs':
                        wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'/wfs'
                        styleUrl = self.URI+'/rest/'+self.laymanUsername+'/layers/'+ str(layerName) + "/style"
                        
                        composition['layers'].append({"metadata":{}, 'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":1,"title":str(layers[i].name()),"className":"OpenLayers.Layer.Vector","style": styleUrl,"singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":20,"minResolution":0,"name": str(layerName),"opacity":1 ,"protocol":{"format": "hs.format.WFS","url": wmsUrl},"ratio":1.5,"visibility": True,"dimensions":{}})
                        

                    else:
                        wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'_wms/ows'
                        composition['layers'].append({"metadata":{},'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":1,"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":20,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
                    successful = successful + 1 
                print("saving layer records to composition")                
             
                for i in range (0, len(layers)):
                          
            
                    #print (self.isLayerInComposite(x))
                    #print (layers[i].name() in self.isLayerInComposite(x))
                    #inComposite = layers[i].name() in self.isLayerInComposite(x)
                    
                    inComposite = False
                    layerName = self.removeUnacceptableChars(layers[i].name()).lower()
                    if (self.checkExistingLayer(layers[i].name()) and inComposite):
                        j = self.getLayerInCompositePosition(x)
                        print("j je: " + str(j))               
                        if self.isXYZ(layers[i].name()):
                            #self.saveXYZ(layers[i])
                            pass
                        else:
                            self.postRequest(layers[i].name(), True)
                            layerName = self.removeUnacceptableChars(layers[i].name())
           
                    else:
                        if self.isXYZ(layers[i].name()):
                            #self.saveXYZ(layers[i])
                            pass
                        else:
                            self.postRequest(layers[i].name(), True)
                      #  wmsStatus = 'PENDING'
                      #  j = 0
                      #  while ((wmsStatus == 'PENDING') and (j < 10)):
                      #      print("waiting")
                      #      print(wmsStatus)
                      #      print (self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(layerName))
                      #      #response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(layerName), verify=False)
                      #      response = requests.get(self.URI+'/rest/'+self.laymanUsername+'/layers/'+str(layerName), headers = self.getAuthHeader(self.authCfg))
                      #      res = self.fromByteToJson(response.content)
                 
                      #      #print(res)
                      #      try:
                      #          #wmsStatus = res['wms']['status']
                      #          #wmsStatus = res['wms']['url']
                      #          wmsStatus = res['wfs']['url']
                      #      except:
                      #          #wmsStatus = "done"
                      #          wmsStatus = "PENDING"
                      #      time.sleep(1)
                      #      j = j + 1
            

                      ##  print(res)
                      #  try:
                      #      #wmsUrl = res['wms']['url']
                      #      wmsUrl = res['wfs']['url']
                      #  except:
                      #      #wmsUrl = self.URI+'/geoserver/'+layerName+'/ows'
                      #      wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'/wfs'
                        #self.compositeList[x]['layers'].append({"metadata":{},"visibility":True,"opacity":1,"title":str(layerName),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":None,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(layers[i].name()),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","FROMCRS":"EPSG:3857","VERSION":"1.3.0"},"ratio":1.5,"dimensions":{}})
                       # if (self.dlg.radioButton_wms.isChecked()): 
                       # 
                       # ############# old                       
                        #if self.layerServices[layerName] == "HSLayers.Layer.WMS":
                        #    wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'_wms/ows'
                        #    composition['layers'].append({"metadata":{},'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":1,"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":20,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
                        ##if (self.dlg.radioButton_wfs.isChecked()):
                        #elif self.layerServices[layerName] == "OpenLayers.Layer.Vector":
                        #    wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'/wfs'
                        #    composition['layers'].append({"metadata":{}, 'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":1,"title":str(layers[i].name()),"className":"OpenLayers.Layer.Vector","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":20,"minResolution":0,"name": str(layerName),"opacity":1 ,"protocol":{"format": "hs.format.WFS","url": wmsUrl},"ratio":1.5,"visibility": True,"dimensions":{}})

                        #else:
                        #    wmsUrl = self.URI+'/geoserver/'+self.laymanUsername+'_wms/ows'
                        #    composition['layers'].append({"metadata":{},'path': path, "visibility":True,"workspace":self.laymanUsername,"opacity":1,"title":str(layers[i].name()),"className":"HSLayers.Layer.WMS","singleTile":True,"wmsMaxScale":0,"legends":[""],"maxResolution":20,"minResolution":0,"url": wmsUrl ,"params":{"LAYERS": str(layerName),"INFO_FORMAT":"application/vnd.ogc.gml","FORMAT":"image/png","VERSION":"1.3.0"},"ratio":1.5,"singleTile": True,"visibility": True,"dimensions":{}})
                        #successful = successful + 1 
                        ### old
        #self.patchMap2()
                        #threading.Thread(target=lambda: self.importMap(x, "add", successful) ).start()
                        #self.importMap(x, "add", successful) 
        self.processingRequest = False
    def removeRastersWithoutCrs(self, layers):
        unacceptableLayers = list()
        nonValid = list()
        pom = 0
        for layer in layers:
            if not layer.isValid():
                nonValid.append(layer.name())
                layers = (set(layers)- set([layer]))
                pom = pom + 1
            if isinstance(layer, QgsRasterLayer):
                if layer.crs().authid() not in self.supportedEPSG:
                    pom = pom + 1
                    unacceptableLayers.append(layer.name())
                    print(set(layers))
                    print(set([layer]))
                    layers = (set(layers)- set([layer]))
                    print(layers)

        if pom > 0 :
            toOutput = "\n".join(unacceptableLayers)        
            if len(nonValid) > 0:
                if self.locale == "cs":
                    toOutput = toOutput + "\n" + "Nevalidní vrstvy:" + "\n" + "\n".join(nonValid) 
                else:
                    toOutput = toOutput + "\n"+ "\n" + "Non valid layers:" + "\n" + "\n".join(nonValid) 
            QgsMessageLog.logMessage("wrongCrss" + toOutput)
        return layers


    def getProgressBarStep(self, count):
        return (100/count)

    def deteteLayerFromComposite(self, x, position, name):   ## pro verzi s komboboxem   
        
        self.threadDelLayer = threading.Thread(target=lambda: self.deteteLayerFromCompositeThread2(x, position, name))
        self.threadDelLayer.start()   
        self.importMapEnvironmnet(False)
        self.dlg.progressBar.show() 
        self.dlg.label_import.show()
    def deteteLayerFromCompositeThread2(self, x, position, name):
        previousLayers = self.compositeList[x]['layers']       #zaloha  
        self.compositeList[x]['layers'] = []            #vymazat vsechny vrstvy
        for i in range (0,len(previousLayers)):
            
            if (i != len(previousLayers) - (position+1)):      ## kompozice je obracena oproti HSlayers proto odecist        
               self.compositeList[x]['layers'].append(previousLayers[i])        
        #self.importMap(x, "del")
        self.importMap(x, "delLay")
        done = True
        if (len(self.compositeList[x]['layers']) != 0 and len(self.compositeList[x]['layers']) != None):
            for i in range (0, len(self.compositeList[x]['layers'])):
                #if (self.compositeList[x]['layers'][i]['params']['LAYERS'] == name):
                if (self.compositeList[x]['layers'][i]['title'] == name):
                    done = False
        if (done and QgsProject.instance().mapLayersByName(name)):    ## kompozice může mít načtené vrstvy, které nejsou v canvasu
            self.deleteLayerFromCanvas(name)   
        time.sleep(1)
        QgsMessageLog.logMessage("delLayComposite")
    def deteteLayerFromCompositeThread(self, x, position, name, title):        
        previousLayers = []       
        lenBefore = len(self.compositeList[x]['layers'])
        for i in range (0, len(self.compositeList[x]['layers'])):
            if (self.compositeList[x]['layers'][i]['title'] == title):
                #print("del:" + title)
                pass
            else:
                previousLayers.append(self.compositeList[x]['layers'][i])
        #print(previousLayers)
        self.compositeList[x]['layers'] = []            #vymazat vsechny vrstvy
        for i in range (0,len(previousLayers)):         
           
            if (i != len(previousLayers) - (position+1)):      ## kompozice je obracena oproti HSlayers proto odecist   
                
                self.compositeList[x]['layers'].append(previousLayers[i])        
        #self.importMap(x, "del") 
        print(lenBefore)
        print(len(self.compositeList[x]['layers']))
        if (lenBefore - 1) ==  len(self.compositeList[x]['layers']):     
            self.importMap(x, "delLay")
            done = True
            if (len(self.compositeList[x]['layers']) != 0 and len(self.compositeList[x]['layers']) != None):
                for i in range (0, len(self.compositeList[x]['layers'])):
                    #if (self.compositeList[x]['layers'][i]['params']['LAYERS'] == name):
                    if (self.compositeList[x]['layers'][i]['title'] == title):
                        done = False
            #if (done and QgsProject.instance().mapLayersByName(title)):    ## kompozice může mít načtené vrstvy, které nejsou v canvasu
            #    self.deleteLayerFromCanvas(title)   
            #time.sleep(1)
        else:
            QgsMessageLog.logMessage("layerDeleteFromCompositeWrong")
       
        
        
    def importCleanComposite(self,x):
        tempFile = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(tempFile, 'w') as outfile:  
            json.dump(self.compositeList[x], outfile)
        with open(tempFile, 'rb') as f:
            d = json.load(f)        
        files = {'file': (tempFile, open(tempFile, 'rb')),} 
        #data = { 'name' :  self.compositeList[x]['name'], 'title' : self.compositeList[x]['title'], 'description' : self.compositeList[x]['abstract']} 
        #data = { 'name' :  self.compositeList[x]['name'], 'title' : self.compositeList[x]['title'], 'description' : self.compositeList[x]['abstract'], 'access_rights.read': self.laymanUsername + ', EVERYONE',   'access_rights.write': self.laymanUsername} 
        data = { 'name' :  self.compositeList[x]['name'], 'title' : self.compositeList[x]['title'], 'description' : self.compositeList[x]['abstract'], 'access_rights.read': self.laymanUsername,   'access_rights.write': self.laymanUsername} 
        
        response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/maps', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        print(response.content)
        if (response.status_code == 200):
            if self.locale == "cs":
            #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + self.compositeList[x]['name'] + " byla úspešně vytvořena."), Qgis.Success, duration=3)
            else:
            #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + self.compositeList[x]['name'] + " was sucessfully created."), Qgis.Success, duration=3)
        else:
            if self.locale == "cs":
            #    QMessageBox.information(None, "Message", "Kompozice byla úspěsně smazána.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + self.compositeList[x]['name'] + " nebyla úspešně vytvořena."), Qgis.Warning, duration=3)
            else:
            #    QMessageBox.information(None, "Message", "Composition deleted sucessfully.")
                iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + self.compositeList[x]['name'] + " was not sucessfully created."), Qgis.Warning, duration=3)
        #print(response.content)



    def showProgressBar(self, bar):
        bar = QProgressBar() 
        bar.setRange(0,0) ## range 0,0 je nekonečný
        self.showProgressBar(bar)
        bar.show()
        iface.mainWindow().statusBar().addWidget(bar)
    def fromByteToJson(self, res):
        pom = res        
        pom = pom.decode('utf_8')
        try:
            pom = json.loads(pom)
        except:
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "Došlo k chybě při komunikaci se serverem.") 
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Layman", "An error occurred while communicating with the server.")
            return     
        
        return pom
    def patchMap(self, x):
        tempFile = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(tempFile, 'w') as outfile:  
            json.dump(self.compositeList[x], outfile)
        jsonPath = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(jsonPath, 'rb') as f:
            d = json.load(f)

        files = {'file': (jsonPath, open(jsonPath, 'rb')),} 
        data = { 'name' :  self.compositeList[x]['name'], 'title' : self.compositeList[x]['title'], 'description' : self.compositeList[x]['abstract']} 
        print("movvvvvvvvvvvvvvvvxr")
        #response = requests.delete(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'],headers = self.getAuthHeader(self.authCfg))
        
        response = requests.patch(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'], files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        self.processingRequest = False
        print(response.status_code)
        if (response.status_code == 200):
            QgsMessageLog.logMessage("patchMapP")
        else:
           # QgsMessageLog.logMessage("patchMapN")
           pass
        return
    def compositionToClipboard(self):    
      
        composition = self.instance.getComposition()        
        df=pd.DataFrame([composition])
        df.to_clipboard(index=False,header=False)
    def patchMap2(self, attempt=0):
        composition = self.instance.getComposition()
        print(composition)
        tempFile = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(tempFile, 'w') as outfile:  
            json.dump(composition, outfile)
        jsonPath = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(jsonPath, 'rb') as f:
            d = json.load(f)

        files = {'file': (jsonPath, open(jsonPath, 'rb')),} 
       # data = { 'name' :  composition['name'], 'title' : composition['title'], 'description' : composition['abstract'], 'access_rights.read': self.laymanUsername + ', EVERYONE',   'access_rights.write': self.laymanUsername} 
        data = { 'name' :  composition['name'], 'title' : composition['title'], 'description' : composition['abstract']} 
        
        read = self.instance.getAllPermissions()['read']
        write = self.instance.getAllPermissions()['write']
        data['access_rights.read'] =  self.listToString(read)
        data['access_rights.write'] = self.listToString(write)
        # data['access_rights'] = self.instance.getAllPermissions()
        
        #except:
        #    print("nenalezen zaznma")
        print("movvvvvvvvvvvvvvvvx")
        #response = requests.delete(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'],headers = self.getAuthHeader(self.authCfg))
        workspace = self.instance.getWorkspace()
        print(self.URI+'/rest/'+workspace+'/maps/'+composition['name'])
        print(self.getAuthHeader(self.authCfg))
        requests.delete(self.URI+'/rest/'+workspace+'/maps/'+composition['name'], headers = self.getAuthHeader(self.authCfg))
        time.sleep(1)
        response = requests.post(self.URI+'/rest/'+workspace+'/maps', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        #response = requests.patch(self.URI+'/rest/'+workspace+'/maps/'+composition['name'], files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        self.processingRequest = False
        print(response.status_code)
        print(response.content)
        res = self.fromByteToJson(response.content)
        #if response.status_code == 400 and attempt < 4:
        #    time.sleep(5)
        #    attempt = attempt + 1
        #    if attempt == 3:
        #        requests.delete(self.URI+'/rest/'+workspace+'/maps/'+composition['name'], headers = self.getAuthHeader(self.authCfg))
        #        time.sleep(1)
        #        response = requests.post(self.URI+'/rest/'+workspace+'/maps/', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        #        print("post")
        #        print(response.content)
        #    else:
        #        self.patchMap2(attempt)
            
            #i = 0
            #while response.status_code == 400 and i < 3:
            #    response = requests.patch(self.URI+'/rest/'+workspace+'/maps/'+composition['name'], files=files, data = data, headers = self.getAuthHeader(self.authCfg))
            #    print(response.content)
            #    i = i + 1
            #    time.sleep(3)
                
        return response.status_code
        
        if (response.status_code == 200):
            QgsMessageLog.logMessage("patchMapP")
        else:
            return
            QgsMessageLog.logMessage("patchMapN")
        return
    def importMap(self, x, operation, s = 0): ##s je počet vrstev úspěšně nahraných na server   
        #if (s != 0):
        #    self.dlg.progressBar.show() 
        #    self.dlg.label_import.show()
        #self.importMapEnvironmnet(True)
        tempFile = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        
        try:
            existingLayers = self.isLayerInComposite(x)
        except:
            existingLayers = []        
        successful = s
        with open(tempFile, 'w') as outfile:  
            json.dump(self.compositeList[x], outfile)
        jsonPath = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "compsite.json"
        with open(jsonPath, 'rb') as f:
            d = json.load(f)

        files = {'file': (jsonPath, open(jsonPath, 'rb')),} 
        data = { 'name' :  self.compositeList[x]['name'], 'title' : self.compositeList[x]['title'], 'description' : self.compositeList[x]['abstract'], 'access_rights.read': self.laymanUsername + ', EVERYONE',   'access_rights.write': self.laymanUsername} 
        req = requests.get(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'], headers = self.getAuthHeader(self.authCfg))
        mapCode = req.status_code ## test jestli vrstva na serveru existuje. Pokud ne = error 404
        if (mapCode == 404 or operation == "mod" or operation == "del" or operation == "mov" or operation == "delLay"):
        #if(True):
            if (operation == "add"):    
                if self.locale == "cs":
                    msgbox = QMessageBox(QMessageBox.Question, "Import Map", "Chcete přidat do kompozice "+str(successful)+" vrstev?") 
                else:
                    msgbox = QMessageBox(QMessageBox.Question, "Import Map", "Do you want add into composition "+str(successful)+" layers?") 
            if (operation == "mod"): 
                
                
                self.dlg.close()
                try:
                    self.afterCloseEditMapDialog()
                except: 
                    pass
                #print(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'])       
              
                response = requests.delete(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'],headers = self.getAuthHeader(self.authCfg))
                
                response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/maps', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
                
                if (response.status_code == 200):
                    if self.locale == "cs":                
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + self.compositeList[x]['name'] + " byla úspešně změněna."), Qgis.Success, duration=3)
                    else:              
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + self.compositeList[x]['name'] + " was sucessfully modified."), Qgis.Success, duration=3)
                else:
                    if self.locale == "cs":             
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Kompozice  " + self.compositeList[x]['name'] + " nebyla úspešně změněna."), Qgis.Warning, duration=3)
                    else:          
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman:", " Composition  " + self.compositeList[x]['name'] + " was not sucessfully modified."), Qgis.Warning, duration=3)
                if (self.dlg.windowTitle() != "Manage Maps"):
                    self.dlg.show()
                return

            if (operation == "mov"):   
                print("movvvvvvvvvvvvvvvv")
                response = requests.delete(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'],headers = self.getAuthHeader(self.authCfg))
              
                response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/maps', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
                
                return
            
            if (operation == "delLay"):                
                    
              
                response = requests.delete(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'],headers = self.getAuthHeader(self.authCfg))
           

                response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/maps', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
              
                             
                return
            if (operation == "del"):
                if self.locale == "cs":
                    msgbox = QMessageBox(QMessageBox.Question, "Import Map", "Chcete smazat vybranou vrstvu?")
                else:
                    msgbox = QMessageBox(QMessageBox.Question, "Import Map", "Do you want delete selected layer?")
          
            try: # jedná se o mod pokud je except
                msgbox.addButton(QMessageBox.Yes)
                msgbox.addButton(QMessageBox.No)
                msgbox.setDefaultButton(QMessageBox.No)
                reply = msgbox.exec()
            except:
                pass
                
            if (reply == QMessageBox.Yes):
                response = requests.post(self.URI+'/rest/'+self.laymanUsername+'/maps', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
               
                data = response.content
               # self.dlg.progressBar.hide() 
               # self.refreshItems()## refresh formuláře
                if (operation != "mod"):
                   # self.refreshLayerList() bylo
                    self.refreshLayerListReversed()
            else:
                if (operation == "add"):
                    self.dlg.progressBar.setValue(0)                
     
        else:
            
            #self.dlg.pushButton.setEnabled(False)
                 
            files = {'file': (jsonPath, open(jsonPath, 'rb')),} 
            response = requests.patch(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name'], data = data, files=files, headers = self.getAuthHeader(self.authCfg))
            
            try: ## některé formuláře nemají progress bar
                self.dlg.progressBar.hide() 
                self.dlg.label_import.hide() 
                self.importMapEnvironmnet(True)
                pass
            except:
                pass
            try:
                #row = self.dlg.listWidget_listLayers.currentRow()
                row = self.dlg.treeWidget_listLayers.indexOfTopLevelItem(self.dlg.treeWidget_listLayers.currentItem())
                print(row)

               
            except:
              
                pass
            try:
                self.refreshLayerListReversed()
            except:
                ## nacházíme se v jiném formuláři, není co refreshovat
                pass
            try:                
                time.sleep(1)
                
                #self.dlg.listWidget_listLayers.setCurrentRow(row)
                self.dlg.treeWidget_listLayers.setCurrentItem(self.dlg.treeWidget_listLayers.topLevelItem(0),0)
                if (self.dlg.listWidget_listLayers.currentRow() == -1):                    
                    self.dlg.pushButton_deleteLayers.setEnabled(False)
                    self.dlg.pushButton_up.setEnabled(False)
                    self.dlg.pushButton_down.setEnabled(False)
            except:
                print("ss") 
          
        
    def deleteLayer(self, layerName):
        url = self.URI+'/rest/'+self.laymanUsername+"/layers/" + layerName
        r = requests.delete(url)
        
    def getActiveLayer(self):
        layer = self.iface.activeLayer()
        return layer
    
    def createComposite(self, name, title, setCurrent = False):
      #  if (name == "" or title == ""):
        if title[0] in ["0","1","2","3","4","5","6","7","8","9"]:
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není povoleno číslo v prvník znaku titulku!")
            else:
                QMessageBox.information(None, "Message", "Number in first character of title is not allowed!")
            return
        if (title == ""):
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Není vyplněn titulek!")
            else:
                QMessageBox.information(None, "Message", "Title is not filled!")
        else:
            name = self.removeUnacceptableChars(title)
            data = self.getEmptyComposite(name,title)
         
            self.compositeList.append(data)   
            x = len(self.compositeList) - 1
            self.importCleanComposite(x)
            try:
                self.refreshCompositeList(True)
            except:
                pass
            if setCurrent:
                self.current = name
                self.selectedWorkspace = self.laymanUsername
                url = self.URI+'/rest/'+self.selectedWorkspace+'/maps/'+name+'/file'  
                print(url)
                r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
                data = r.json()
                print(data)
                self.instance = CurrentComposition(self.URI, name, self.selectedWorkspace, self.getAuthHeader(self.authCfg),self.laymanUsername)
                self.instance.setComposition(data)
                self.compositionDict[name] = title
                ## sync start
                prj = QgsProject().instance()
                QgsProject().instance().setTitle(title)
                root = prj.layerTreeRoot()
                print("xxxxxx")
                print(root)
                print("xxxxxx")
                #root.layerOrderChanged.connect(lambda: self.getLayerGroupTest())
                #root.layerOrderChanged.connect(lambda: self.syncOrder(iface.mapCanvas().layers()))
                ## konec naslouchani

                self.prj=QgsProject.instance()
            
                self.prj.removeAll.connect(self.removeSignals)              
                self.menu_CurrentCompositionDialog.setEnabled(True)                 
                #iface.layerTreeView().currentLayerChanged.connect(lambda: self.syncOrder(iface.mapCanvas().layers()))
                #self.timerLayer = QTimer()
                #self.timerLayer.setInterval(5000)
                #self.timerLayer.timeout.connect(lambda: self.syncOrder([layer for layer in QgsProject.instance().mapLayers().values()])) 
                #self.timerLayer.start()
                self.processingRequest = False

                composition = self.instance.getComposition()
                self.backupComposition = copy.deepcopy(composition) 
                #self.syncComposition = QTimer()
                #self.syncComposition.setInterval(10000)
                #self.syncComposition.timeout.connect(lambda: self.updateComposition()) 
                #self.syncComposition.start()

                root = QgsProject.instance().layerTreeRoot()
               # root.visibilityChanged.connect(self.changeVisibility)
                ##

                self.afterCloseNewMapDialog()
        
    
    def patchLayer(self, layer_name, data):
        print("patchLayer")
        #self.layerName = layer_name.lower()
        self.layerName = self.removeUnacceptableChars(layer_name)
        
        #sldPath = self.getTempPath(self.layerName).replace("geojson", "sld")
        #qmlPath = self.getTempPath(self.layerName).replace("geojson", "qml")
        geoPath = self.getTempPath(self.layerName)
        
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0"):
            stylePath = self.getTempPath(self.layerName).replace("geojson", "qml")
        else:
            stylePath = self.getTempPath(self.layerName).replace("geojson", "sld")
        ##self.layerName = self.layerName
      
        if(os.path.isfile(stylePath)): ## existuje styl?
            files = [('file', open(geoPath, 'rb')), ('style', open(stylePath, 'rb'))]
            
        else:
            files = {'file': (geoPath, open(geoPath, 'rb')),}  
            
        layer_name = layer_name.lower()
        layer_name = layer_name.replace(" ", "_")
        layer_name = self.removeUnacceptableChars(layer_name)
        url = self.URI+'/rest/' + self.laymanUsername + "/layers/" + layer_name
        r = requests.get(url, headers = self.getAuthHeader(self.authCfg))
        res = r.json()
        read = res['access_rights']['read']
        write = res['access_rights']['write']
        data['access_rights.read'] =  self.listToString(read)
        data['access_rights.write'] = self.listToString(write)
        if r.status_code == 200:
            r = requests.delete(url, headers = self.getAuthHeader(self.authCfg))
        #r = requests.patch(url, files=files, data = data, headers = self.getAuthHeader(self.authCfg), verify=False) 
        time.sleep(0.5)
        url = self.URI+'/rest/' + self.laymanUsername + "/layers/"
        #r = requests.post(url, files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        r = requests.post(self.URI+'/rest/'+self.laymanUsername+'/layers', files=files, data = data, headers = self.getAuthHeader(self.authCfg))
        print("layer posted")
        print(url)
        print(r.content)

    def getTempPath(self, name):

        
        if type(name) is tuple:
            return (name[0] +  name[1])
        else:
            tempFile = tempfile.gettempdir() + os.sep + name +'.geojson'

            return tempFile
    def sendLayer(self):       
        layer = self.getActiveLayer()      
        if (layer == None):
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Neexistuje žádná vrstva k uložení")
            else:
                QMessageBox.information(None, "Message", "No layer to save!")
        else:
            self.json_export()
            self.postRequest()
    def getExistingLayers(self):
        url = self.URI+'/rest/'+self.laymanUsername+"/layers"
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg)) 
        data = r.json()
        for x in range(len(data)):
            print(data[x]['name'])
        return data
    def request(self,type, uri, header, data = ""):
        i = 0
        while i < 2:
            try:
                if type == "get":
                    r = requests.get(url = uri, headers = header)
                    
                if type == "post":
                    r = requests.post(url = uri, data = data, headers = header)
                if r.status_code == 200:
                    return r
            except:
                i = i + 1
                if i == 2:
                    time.sleep(1)
                    QgsMessageLog.logMessage("requestError")
                    return False
        

    def checkExistingLayer(self, layerName):
        layerName = self.removeUnacceptableChars(layerName)
        url = self.URI+'/rest/'+self.laymanUsername+"/layers"
        r = self.request("get", url, self.getAuthHeader(self.authCfg))
        #r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg)) 
        if not r:
            return
        data = r.json()
        #print(data)

        
        pom = set()
        for x in range(len(data)):
            pom.add((data[x]['name']))
        layerName = layerName.replace(" ", "_").lower()
        #print(layerName)
        if (layerName in pom):
            return True
        else:
            return False
   
    def removeUnacceptableChars(self, input):
        input = input.lower()
        input = input.replace("ř","r")
        input = input.replace("š","s")
        input = input.replace("ž","z")
        input = input.replace("ů","u")
        input = input.replace("ú","u")
        input = input.replace(" ","_")
        input = input.replace("é","e")
        input = input.replace("í","i")
        input = input.replace("ý","y")
        input = input.replace("á","a")
        input = input.replace("ň","n")
        input = input.replace("ó","o")
        input = input.replace("č","c")
        input = input.replace("ď","d")
        input = input.replace("ě","e")
        input = input.replace("ť","t")
        input = input.replace("-","_")
        input = input.replace(".","_")
        input = input.replace(":","")
        input = input.replace("/","_")
        input = input.replace("(","")
        input = input.replace(")","")        
        input = input.replace("___","_")
        input = input.replace("__","_")
        input = re.sub(r'[?|$|.|!]',r'',input)
        try:
            if input[len(input) - 1] == "_":
                input = input[:-1]
        except:
            print("removechars exception")
        return input
  
    def test (self):
        item = self.dlgGetLayers.items.currentItem().text()
        #print( item)
    
    def isLayerInComposite(self, x):      
        layers =[]
        layers.append(self.dlg.mMapLayerComboBox.currentLayer())
        #print (self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file')
        req = requests.get (self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file', headers = self.getAuthHeader(self.authCfg))
        data = req.json()
       
        #print (data['abstract'])
        #print (len(self.compositeList[x]['layers']))
        existingLayers = []
        for i in range (0, len(data['layers'])):
            for j in range (0, len(layers)):
                if (data['layers'][i]['title'] in layers[j].name() ):
                    existingLayers.append(data['layers'][i]['title'])
                #if (data['layers'][i]['params']['LAYERS'] in layers[j].name() ):
                 #   existingLayers.append(data['layers'][i]['params']['LAYERS'])

        return existingLayers
    def getLayerInCompositePosition(self, x):      
        layers =[]
        layers.append(self.dlg.mMapLayerComboBox.currentLayer())
        #print (self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file')
        req = requests.get (self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file', headers = self.getAuthHeader(self.authCfg))
        data = req.json()
       
        #print (data['abstract'])
        #print (len(self.compositeList[x]['layers']))
        existingLayers = []
        j = 0
        for i in range (0, len(data['layers'])):
            for j in range (0, len(layers)):
                try:
                    print(data['layers'][i])
                    layer = data['layers'][i]['params']['LAYERS'] # wms
                except:
                    layer = data['layers'][i]['name']
                if (layer in layers[j].name() ):
                  #  existingLayers.append(data['layers'][i]['params']['LAYERS'])
                   j = i
                   #print("founded")

        return j

    def isRasterLayerInComposite(self, x, name):
        name = self.removeUnacceptableChars(name).lower()        
        req = requests.get(self.URI+'/rest/'+self.laymanUsername+'/maps/'+self.compositeList[x]['name']+'/file',headers = self.getAuthHeader(self.authCfg))
        
        data = req.json()        
        existingLayers = []       
        for i in reversed(range (0, len(data['layers']))):
            #if (data['layers'][i]['params']['LAYERS'] ==  name ):
            #    existingLayers.append(data['layers'][i]['params']['LAYERS'])
             if (self.removeUnacceptableChars(data['layers'][i]['title']) ==  name ):
                existingLayers.append(self.removeUnacceptableChars(data['layers'][i]['title']))
        print(name)
        print(existingLayers)
        return existingLayers
    
    def addComposite(self, data, service, groupName = ''):     
        
        
        ##for x in range(0, len(data['layers'])): 
        for x in range(len(data['layers'])- 1, -1, -1):          
          #  repairUrl = self.convertUrlFromHex(data['layers'][x]['url'])  
            repairUrl = self.URI+"/geoserver/"+self.laymanUsername+"/ows"
            layerName = data['layers'][x]['params']['LAYERS']
            format = data['layers'][x]['params']['FORMAT']
           #  epsg = str(data['groups']['projection']).upper()
            epsg = 'EPSG:4326' 
            #abstract = data['data']['layers'][x]['params']['ABSTRACT']
            wmsName = data['layers'][x]['params']['LAYERS']
            className = data['layers'][x]['className']
            
            layerNameTitle = self.getLayerTitle(layerName)           

            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layerName  
           
            r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
            res = r.json()
            
           
            
            if service == 'WMS':        
                
                UrlWms = data['layers'][x]['url']
                if className == 'XYZ':
                    self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName)
                else:
                    self.loadWms(UrlWms, layerName,layerNameTitle, format,epsg, groupName)

            if service == 'WFS': 
                #UrlWfs = res['wfs']['url']
                UrlWms = data['layers'][x]['url']
                self.loadWfs(UrlWfs, layerName,layerNameTitle, groupName)
    def loadService(self, data, service, groupName = ''):     
        
        
        for x in range(len(data['layers'])- 1, -1, -1):       ## descending order 
        #for x in range(len(data['layers'])):       ## descending order 
            #repairUrl = self.convertUrlFromHex(data['layers'][x]['url'])  
            repairUrl = self.URI+"/geoserver/"+self.laymanUsername+"/ows"
            try:
                layerName = data['layers'][x]['params']['LAYERS']
            except:
                layerName = data['layers'][x]['name']
            format = data['layers'][x]['params']['FORMAT']
           #  epsg = str(data['groups']['projection']).upper()
            epsg = 'EPSG:4326' 
            className = data['layers'][x]['className']
            #abstract = data['data']['layers'][x]['params']['ABSTRACT']
            wmsName = data['layers'][x]['params']['LAYERS']  
            layerNameTitle = data['layers'][x]['title']
            if self.checkLayerOnLayman(layerName):
                if service == 'WMS':         
                   
                    repairUrl = data['layers'][x]['url']
                    #self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName)
                    if className == 'XYZ':
                        self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName)
                    else:
                        self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName)
                if service == 'WFS': 
                   # repairUrl = repairUrl.replace("ows","wfs")
                    repairUrl = data['layers'][x]['url']
                    self.loadWfs(repairUrl, layerName,layerNameTitle, groupName)
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Layman", "Vrstva: "+layerName + " je poškozena a nebude načtena.")
                else:
                    QMessageBox.information(None, "Layman", "Layer: "+layerName + " is corrupted and will not be loaded.")
    def convertUrlFromHex(self, url):
        url = url.replace('%3A',':')
        url = url.replace('%2F','/')
        url = url.replace('%3F','?')
        url = url.replace('%3D','=')
        url = url.replace('%26','&') 
        return url
    def getCompositionWorkspace(self, name):
        url = self.URI+'/rest/maps'
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        data = r.json()      
        for row in range(0, len(data)):
            if name == data[row]['name']:
                return data[row]['workspace']
    def loadService2(self, data, service, groupName = ''):           
        success = True
        notify = False
        groupName = ''
        
        try:
            test = data['layers']
        except:
            print("corrupted composition")
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Kompozice je poškozena!")
            else:
                QMessageBox.information(None, "Layman", "Map composition is corrupted!")
            return
        #self.loadservice3(data)
        #QTimer.singleShot(1, lambda: self.loadservice3(data))
        self.service3 = threading.Thread(target=lambda: self.loadservice3(data))
        self.service3.start()
       
    def loadservice3(self, data):
        groupName = ''
        self.threads = list()
        
        self.ThreadsA = set()
        for thread in threading.enumerate(): 
            self.ThreadsA.add(thread.name)
        i=1
        self.groups = list()
        self.groupPositions = list()
        self.groupsSet = set()
        for x in range(len(data['layers'])- 1, -1, -1):       ## descending order     
            print("iteration")
            try:                
                subgroupName =  data['layers'][x]['path']
            except:
                print("path for layer not found")
                subgroupName = ""
            try:
                timeDimension = data['layers'][x]['dimensions']
            except:
                print("time dimensions for layer not found")
                timeDimension = ""
            className = data['layers'][x]['className']     
            visibility = data['layers'][x]['visibility']      
            print(str(visibility) + "visibility")
            if className == 'XYZ':
                layerName = data['layers'][x]['title']
                self.layerServices[layerName] = 'XYZ'
            if className == 'HSLayers.Layer.WMS':
                layerName = data['layers'][x]['params']['LAYERS']
                self.layerServices[layerName] = 'HSLayers.Layer.WMS'
            
            if className == 'OpenLayers.Layer.Vector' or className == 'Vector': 
                print(data['layers'][x])
                try:
                    layerName = data['layers'][x]['name']
                except:
                    try:
                        layerName = data['layers'][x]['protocol']['LAYERS']
                    except:
                        QgsMessageLog.logMessage("compositionSchemaError")
                        self.instance = None
                        self.current = None
                        return
                self.layerServices[layerName] = 'OpenLayers.Layer.Vector'
            try:
                print(layerName)
            except:
                print("wrong format of composition")
                return
            
            if self.checkLayerOnLayman(layerName):
                #QgsMessageLog.logMessage("showLoader")                
                #threading.Thread(target=lambda: self.loadservice3(data,className,x,layerName, visibility, groupName, subgroupName, timeDimension)).start()
                
                if className == 'HSLayers.Layer.WMS':        
                    #repairUrl = self.URI+"/geoserver/"+self.laymanUsername+"/ows"
                    layerName = data['layers'][x]['params']['LAYERS']
                    format = data['layers'][x]['params']['FORMAT']           
                    epsg = 'EPSG:4326'
                    
                    try:
                        groupName = data['layers'][x]['path']
                    except:
                        groupName = ""
                    wmsName = data['layers'][x]['params']['LAYERS']  
                    layerNameTitle = data['layers'][x]['title']
                    repairUrl = data['layers'][x]['url']
                    repairUrl = self.convertUrlFromHex(repairUrl)        
                    print(groupName,i)
                    
                    if groupName != "":
                        self.groups.append([groupName, len(data['layers']) - i])
                        self.groupsSet.add(groupName)
                        self.groupPositions.append([groupName, layerNameTitle, len(data['layers']) -i])
                    else:
                        self.groups.append([layerNameTitle, len(data['layers']) - i])
                    #self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName,"","")
                    self.threads.append(threading.Thread(target=lambda: self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName, subgroupName, timeDimension, visibility)).start())
                    #success = self.loadWms(repairUrl, layerName,layerNameTitle, format,epsg, groupName, subgroupName, timeDimension, visibility)
                    #if not success:
                    #    notify = True
            
               #☺ if False:
                if className == 'XYZ':
                    #repairUrl = self.URI+"/geoserver/"+self.laymanUsername+"/ows"
                    layerName = data['layers'][x]['params']['LAYERS']
                  
                    try:
                        groupName = data['layers'][x]['path']
                    except:
                        groupName = ""
                    format = data['layers'][x]['params']['FORMAT']           
                    epsg = 'EPSG:4326'             
                    wmsName = data['layers'][x]['params']['LAYERS']  
                    layerNameTitle = data['layers'][x]['title']
                    repairUrl = data['layers'][x]['url']
                    repairUrl = self.convertUrlFromHex(repairUrl)
                    if groupName != "":
                        self.groups.append([groupName, len(data['layers']) -i])
                        self.groupsSet.add(groupName)
                        self.groupPositions.append([groupName, layerNameTitle, len(data['layers']) -i])
                    else:
                        self.groups.append([layerNameTitle, len(data['layers']) - i])
                    self.threads.append(threading.Thread(target=lambda: self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName, subgroupName, visibility)).start())
                    #success = self.loadXYZ(data['layers'][x]['url'], layerName,layerNameTitle, format,epsg, groupName, subgroupName, visibility)
                    #if not success:
                    #    notify = True
            
                if className == 'OpenLayers.Layer.Vector' or className == 'Vector': 
                    epsg = 'EPSG:4326'         
        
                    layerNameTitle = data['layers'][x]['title']                    
                    repairUrl = data['layers'][x]['protocol']['url']
                    repairUrl = self.convertUrlFromHex(repairUrl)
                    subgroupName = ""
                    if "path" in  data['layers'][x]:
                        groupName = data['layers'][x]['path']  
                    else:
                        groupName = ""
                    if groupName != "":
                        self.groups.append([groupName, len(data['layers']) -i])
                        self.groupsSet.add(groupName)
                        self.groupPositions.append([groupName, layerNameTitle, len(data['layers']) -i])
                    else:
                        self.groups.append([layerNameTitle, len(data['layers']) - i])
                    try: ## nove rozdeleni
                
                        if (data['layers'][x]['protocol']['type'] == "hs.format.WFS" or data['layers'][x]['protocol']['type'] == "hs.format.externalWFS"):
                    
                            self.threads.append(threading.Thread(target=lambda: self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility)).start())
                            #success = self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility)
                            #if not success:
                            #    notify = True
                    except:
                        print("tst")
                        self.threads.append(threading.Thread(target=lambda: self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility)).start())
                        #success = self.loadWfs(repairUrl, layerName,layerNameTitle, groupName, subgroupName, visibility)
                        #if not success:
                        #    notify = True
                    #elif (data['layers'][x]['protocol']['type'] == "hs.format.externalWFS"):
                    #    self.loadWfs(wfsUrl, layerName, layerNameTitle) 
                    
            else:
                self.wrongLayers = True
                #if self.locale == "cs":
                #    QMessageBox.information(None, "Layman", "Vrstva: "+layerName + " je poškozena a nebude načtena.")
                #else:
                #    QMessageBox.information(None, "Layman", "Layer: "+layerName + " is corrupted and will not be loaded.")

            i = i + 1
        
        threadsB = set()
        while (self.ThreadsA != threadsB):
            threadsB = set()
            for thread in threading.enumerate(): 
                threadsB.add(thread.name)              
        
        #while (len(threads) > 0):
        #    for thread in threads:
        #        print(thread.isAlive())
            
        
        
        
        QgsMessageLog.logMessage("afterCompositionLoaded")  
        
        QgsMessageLog.logMessage("reorderGroups")    
        
     
    def Title(self, layerName):
        layerName = self.removeUnacceptableChars(layerName)
        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layerName
        r = requests.get(url = url, headers = self.getAuthHeader(self.authCfg))
        data = r.json()
       
        title = data['title']
        
        return title
    def parseWMSlayers(self, layerString):
        ### ocekavany string je ve formatu pole napr [vrstva1,vrstva2,...]
        if (layerString[0] == "[" and layerString[-1:] == "]"):    
            s = layerString.replace("[","").replace("]","").split(",")
            res = ""
            for i in range(0, len(s)):
              
                if (i == 0):
                    res = res+ s[i].replace(" ", "") + "&layers="
                elif (i == len(s)-1):
                    res = res+ s[i].replace(" ", "")
                else:
                    res = res+ s[i].replace(" ", "") + "&layers="


            for i in range(0, len(s)-1):
                res = res + "&styles"
            return res.replace("_","")
        else:
            return layerString
 
    def loadWms(self, url, layerName,layerNameTitle, format, epsg, groupName = '', subgroupName = '', timeDimension='', visibility=''):     
      
        
        #layerName = self.removeUnacceptableChars(layerName)        
        print ("url"+ url)
        layerName = self.parseWMSlayers(layerName)
        #epsg = "EPSG:4326"
        epsg = QgsProject.instance().crs().authid()
        
        url = url.replace("%2F", "/").replace("%3A",":")
        urlWithParams = 'contextualWMSLegend=0&crs='+epsg+'&IgnoreReportedLayerExtents=1&dpiMode=7&featureCount=10&format=image/png&layers='+layerName+'&styles=&url=' + url
        
        ### quri
        #authCfg=self.client_id[-7:]
        #authCfg = '957je05'
        quri = QgsDataSourceUri()  
        try:
            if timeDimension != {}:
                if 'value' in timeDimension['time']:
                    if 'values' in timeDimension['time']:
                        print(timeDimension['time']['values'])
                        print(timeDimension)
                        quri.setParam("type", "wmst")
                        #quri.setParam("timeDimensionExtent", "1995-01-01/2021-12-31/PT5M")
                        print(timeDimension)
                        quri.setParam("timeDimensionExtent", str(timeDimension['time']['values']))
                        quri.setParam("allowTemporalUpdates", "true")
                        quri.setParam("temporalSource", "provider")
                    else:         
                        quri.setParam("type", "wmst")
                        quri.setParam("timeDimensionExtent", self.readDimFromCapatibilites(url, layerName))
                        quri.setParam("allowTemporalUpdates", "true")
                        quri.setParam("temporalSource", "provider")
                #except:
                #    print("dimension exception")
        except:
            print("error with time wms")
        quri.setParam("layers", layerName.replace("'", ""))
        quri.setParam("styles", '')
        quri.setParam("format", 'image/png')
        #quri.setParam("crs", 'EPSG:4326')
        quri.setParam("crs", epsg)
        quri.setParam("dpiMode", '7')
        quri.setParam("featureCount", '10')
        quri.setParam("IgnoreReportedLayerExtents", "1")
        if (self.isAuthorized):
            quri.setParam("authcfg", self.authCfg)   # <---- here my authCfg url parameter
        quri.setParam("contextualWMSLegend", '0')
        quri.setParam("url", url)
        print(str(quri.encodedUri()))
        rlayer = QgsRasterLayer(str(quri.encodedUri(), "utf-8").replace("%26","&").replace("%3D","="), layerNameTitle, 'wms')
        #if not url.startswith(self.URI):
        #    print("remove authcfg")
        #    quri.removeParam("authcfg")
       # rlayer = QgsRasterLayer(str(quri.encodedUri(), "utf-8").replace("%26","&").replace("%3D","="), layerNameTitle, 'wms')
        #print(rlayer.isValid())
        ##quri end
        #if epsg == 'EPSG:5514':
        #    #wkt = 'PROJCRS["S-JTSK / Krovak", BASEGEOGCRS["S-JTSK", DATUM["System of the Unified Trigonometrical Cadastral Network", ELLIPSOID["Bessel 1841",6377397.155,299.1528128, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]], ID["EPSG",4156]], CONVERSION["Krovak (Greenwich)", METHOD["Krovak", ID["EPSG",9819]], PARAMETER["Latitude of projection centre",49.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8811]], PARAMETER["Longitude of origin",24.8333333333333, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8833]], PARAMETER["Co-latitude of cone axis",30.2881397527778, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",1036]], PARAMETER["Latitude of pseudo standard parallel",78.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8818]], PARAMETER["Scale factor on pseudo standard parallel",0.9999, SCALEUNIT["unity",1], ID["EPSG",8819]], PARAMETER["False easting",0, LENGTHUNIT["metre",1], ID["EPSG",8806]], PARAMETER["False northing",0, LENGTHUNIT["metre",1], ID["EPSG",8807]]], CS[Cartesian,2], AXIS["southing (X)",south, ORDER[1], LENGTHUNIT["metre",1]], AXIS["westing (Y)",west, ORDER[2], LENGTHUNIT["metre",1]], USAGE[ SCOPE["unknown"], AREA["Europe - Czechoslovakia"], BBOX[47.73,12.09,51.06,22.56]], ID["EPSG",5513]]'
        #    #crs = QgsCoordinateReferenceSystem(wkt) 
        #    crs = QgsCoordinateReferenceSystem() 
        #    #crs.createFromProj("+proj=pipeline +step +inv +proj=webmerc +lat_0=0 +lon_0=0 +x_0=0 +y_0=0 +ellps=WGS84 +step +proj=push +v_3 +step +proj=cart +ellps=WGS84 +step +inv +proj=helmert +x=570.8 +y=85.7 +z=462.8 +rx=4.998 +ry=1.587 +rz=5.261 +s=3.56 +convention=position_vector +step +inv +proj=cart +ellps=bessel +step +proj=pop +v_3 +step +proj=krovak +lat_0=49.5 +lon_0=24.8333333333333 +alpha=30.2881397527778 +k=0.9999 +x_0=0 +y_0=0 +ellps=bessel")
        #    crs.createFromProj(QgsDatumTransform().datumTransformToProj(1623)) ## epsg:5514/1623
        #    rlayer.setCrs(crs)
        #rlayer = QgsRasterLayer(urlWithParams, layerNameTitle, 'wms')
        try:
            print("extents")
            print(rlayer.ignoreExtents())
        except:
            print("ignoreExtents works only with qgis 3.10 and higher")
            pass # pro qgis 3.10 a vys
        self.currentLayer.append(rlayer)        
        if (rlayer.isValid()):  
            if (groupName != '' or subgroupName != ''):
                #pass
                self.addWmsToGroup(subgroupName,rlayer, "") ## vymena zrusena groupa v nazvu kompozice, nyni se nacita pouze vrstva s parametrem path
                #self.addWmsToGroup(groupName,rlayer, subgroupName)
            else:   
                self.params = []
                self.params.append(visibility)
                #self.addWmsToGroup("",rlayer, "")
                #QgsProject.instance().addMapLayer(rlayer,False)
                rand = random.randint(0,10000)
                self.currentLayerDict[str(rand)] = rlayer
                
                QgsMessageLog.logMessage("loadVector" + str(rand))
                #QgsMessageLog.logMessage("loadLayer")
                
                #QgsProject.instance().addMapLayer(rlayer)
            #if visibility == False:
            #    print(rlayer.id())
            #    print(self.project)
            #    print(self.project.layerTreeRoot().findLayer(rlayer.id()))
            #    self.project.layerTreeRoot().findLayer(rlayer.id()).setItemVisibilityChecked(False)
            return True
        else:
            rand = random.randint(0,10000)
            self.currentLayerDict[str(rand)] = rlayer
            QgsMessageLog.logMessage("loadVector" + str(rand))
           # QgsMessageLog.logMessage("loadLayer")
            #QgsProject.instance().addMapLayer(rlayer)
            #if self.locale == "cs":
            #    QMessageBox.information(None, "Layman", "WMS není pro vrstvu "+layerNameTitle+ " k dispozici.")
            #else:
            #    QMessageBox.information(None, "Layman", "WMS for layer "+layerNameTitle+ " is not available.")
            return False
    def loadXYZ(self, url, layerName,layerNameTitle, format, epsg, groupName = '', subgroupName= '', visibility= '', i = -1):      
      
        
        layerName = self.removeUnacceptableChars(layerName)
        print("XYZ")
        
        epsg = "EPSG:4326"
        url = url.replace("%2F", "/").replace("%3A",":")    
       
    
      
        rlayer = QgsRasterLayer("type=xyz&url="+url, layerNameTitle, "wms") 
        print("xyz valid? " + str(rlayer.isValid()))
        try:
            print("extents")
            print(rlayer.ignoreExtents())
        except:
            print("ignoreExtents works only with qgis 3.10 and higher")
            pass # pro qgis 3.10 a vys      
        if (rlayer.isValid()):  
            if (groupName != ''):
                
                self.addWmsToGroup(subgroupName,rlayer, "")
               # self.addWmsToGroup(groupName,rlayer, subgroupName, i)
                
                
            else:  
                self.params = []
                self.params.append(visibility)
                #self.addWmsToGroup("",rlayer, "")
                #QgsProject.instance().addMapLayer(rlayer,False)
                rand = random.randint(0,10000)
                self.currentLayerDict[str(rand)] = rlayer
                
                QgsMessageLog.logMessage("loadVector" + str(rand))
                #return
                #self.currentLayer.append(rlayer) 
                #self.params = []
                #self.params.append(visibility)
                #rand = random.randint(0,10000)
                #self.currentLayerDict[str(rand)] = rlayer
                #QgsMessageLog.logMessage("loadVector" + str(rand))
               # QgsMessageLog.logMessage("loadLayer")
                #QgsProject.instance().addMapLayer(rlayer)
            if visibility == False:
                QgsProject.instance().layerTreeRoot().findLayer(rlayer.id()).setItemVisibilityChecked(False)
            return True
        else:
            return False
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "WMS není pro vrstu "+layerNameTitle+ " k dispozici.")
            else:
                QMessageBox.information(None, "Layman", "WMS for layer "+layerNameTitle+ " is not available.")
    
    def loadWfs(self, url, layerName,layerNameTitle, groupName = '', subgroupName = '', visibility= ''):
        layerName = self.removeUnacceptableChars(layerName)
        #epsg = 'EPSG:3857'    
        epsg = iface.mapCanvas().mapSettings().destinationCrs().authid()
        #if epsg == 'EPSG:5514':
        #    wkt = 'PROJCRS["S-JTSK / Krovak", BASEGEOGCRS["S-JTSK", DATUM["System of the Unified Trigonometrical Cadastral Network", ELLIPSOID["Bessel 1841",6377397.155,299.1528128, LENGTHUNIT["metre",1]]], PRIMEM["Greenwich",0, ANGLEUNIT["degree",0.0174532925199433]], ID["EPSG",4156]], CONVERSION["Krovak (Greenwich)", METHOD["Krovak", ID["EPSG",9819]], PARAMETER["Latitude of projection centre",49.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8811]], PARAMETER["Longitude of origin",24.8333333333333, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8833]], PARAMETER["Co-latitude of cone axis",30.2881397527778, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",1036]], PARAMETER["Latitude of pseudo standard parallel",78.5, ANGLEUNIT["degree",0.0174532925199433], ID["EPSG",8818]], PARAMETER["Scale factor on pseudo standard parallel",0.9999, SCALEUNIT["unity",1], ID["EPSG",8819]], PARAMETER["False easting",0, LENGTHUNIT["metre",1], ID["EPSG",8806]], PARAMETER["False northing",0, LENGTHUNIT["metre",1], ID["EPSG",8807]]], CS[Cartesian,2], AXIS["southing (X)",south, ORDER[1], LENGTHUNIT["metre",1]], AXIS["westing (Y)",west, ORDER[2], LENGTHUNIT["metre",1]], USAGE[ SCOPE["unknown"], AREA["Europe - Czechoslovakia"], BBOX[47.73,12.09,51.06,22.56]], ID["EPSG",5513]]'
        #    epsg = QgsCoordinateReferenceSystem(wkt)            
        uri = self.URI+"/geoserver/"+self.laymanUsername+"/ows?srsname="+epsg+"&typename="+self.laymanUsername+":"+layerName+"&restrictToRequestBBOX=1&pagingEnabled=True&version=auto&request=GetFeature&service=WFS"
        url = url.replace("%2F", "/").replace("%3A",":").replace("/client","")
        r = url.split("/")
        acc = (r[len(r)-2])
       # print(uri)        
        #uri = url + "?srsname="+epsg+"&typename="+acc+":"+layerName+"&restrictToRequestBBOX=1&pagingEnabled=True&version=auto&request=GetFeature&service=WFS"
        #vlayer = QgsVectorLayer(uri, layerNameTitle, "WFS")
        #self.currentLayer.append(vlayer)
        #QgsMessageLog.logMessage("loadLayer")
        #return
       # uri = url + "?srsname="+epsg+"&typename="+acc+":"+layerName+"&restrictToRequestBBOX=1&pagingEnabled=True&version=auto&request=GetFeature&service=WFS"
        print(epsg)
        print(acc+":"+layerName)
        print(url)
        
        quri = QgsDataSourceUri()        
        quri.setParam("srsname", epsg)
        quri.setParam("typename", acc+":"+layerName)
        quri.setParam("restrictToRequestBBOX", "1")
        quri.setParam("pagingEnabled", "true")
        quri.setParam("version", "auto")
        quri.setParam("request", "GetFeature")
        quri.setParam("service", "WFS")
        if (self.isAuthorized):
            print("add authcfg")
            quri.setParam("authcfg", self.authCfg)
        quri.setParam("url", url)     
        vlayer = QgsVectorLayer(url+"?" + str(quri.encodedUri(), "utf-8"), layerNameTitle, "WFS")
        print("validity WFS")
        print(vlayer.isValid()) 
        
        if (vlayer.isValid()):
            print("cc")
            if (self.getTypesOfGeom(vlayer) < 2):
           # if (True):    
                if (groupName != ''):
                    self.addWmsToGroup(groupName,vlayer, subgroupName)

                    self.currentLayer.append(vlayer)
                    rand = random.randint(0,10000)
                    self.currentLayerDict[str(rand)] = vlayer
                    QgsMessageLog.logMessage("loadSymbology" + str(rand))
                else:        
                    #self.addWmsToGroup("",vlayer, "")
                    #QgsProject.instance().addMapLayer(vlayer)
                    self.currentLayer.append(vlayer)
                    rand = random.randint(0,10000)
                    self.currentLayerDict[str(rand)] = vlayer
                    print("###############################")
                    print(self.currentLayer)
                    print(vlayer.name())
                    print(vlayer.isValid())
                    print("###############################")
                    #if not vlayer.name() == "poom3"
                    #QgsMessageLog.logMessage("loadLayer"+ vlayer.name())
                    #QgsMessageLog.logMessage("loadLayer")
                    QgsMessageLog.logMessage("loadVector" + str(rand))
                #if visibility == False:
                #    print(vlayer.id())
                #    QgsProject.instance().layerTreeRoot().findLayer(vlayer.id()).setItemVisibilityChecked(False)
                ## zde bude SLD kod
                print("tt")
                #style = self.getStyle(layerName)
                ##code = self.getSLD(layerName)
                
               
                #if (style[0] == 200):
                #    if (style[1] == "sld"):
                #        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                #        vlayer.loadSldStyle(tempf)
                #        vlayer.triggerRepaint()
                #    if (style[1] == "qml"):
                #        tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".qml"
                #        vlayer.loadNamedStyle(tempf)
                #        vlayer.triggerRepaint()
              
            else: ### cast pro slozenou geometrii
                self.mixedLayers.append(layerName)
                pointFeats = list()
                polyFeats = list()
                lineFeats = list()  
                feats = vlayer.getFeatures()
                #print(len(feats))
    
                pol = 0
                line = 0
                point = 0
                for feat in feats:
                   # print(type(feat))
                    #print(feat.geometry().type())
                    if (feat.geometry().type() == 0):
                        pointFeats.append(feat)
                        point = 1          
         
                    if (feat.geometry().type() == 2):
                        polyFeats.append(feat)        
                        pol = 1
                    if (feat.geometry().type() == 1):
                        lineFeats.append(feat) 
                        line =  1       
                if (point == 1):
                    vl = QgsVectorLayer("Point?crs="+epsg, layerName, "memory")    
                    pr = vl.dataProvider()        
                    pr.addFeatures(pointFeats)
                    vl.updateFields()
                    vl.updateExtents()         
                    vl.commitChanges()        
                    vl.nameChanged.connect(self.forbidRename)
                    if (groupName != ''):
                        self.addWmsToGroup(groupName,vl, True)
                        
                    else:      
                        self.addLayerToGroup(layerName,vl)
                        #QgsProject.instance().addMapLayer(vl)
                        ### zde bude SLD kod
                        #code = self.getSLD(layerName)
                        #if (code == 200):
                        #    tempf = tempfile.gettempdir() + os.sep +self.removeUnacceptableChars(layerName)+ ".sld"
                        #   # print(vlayer.loadSldStyle(tempf))
                        #    vlayer.triggerRepaint()   
                if (line == 1):
                    vl = QgsVectorLayer("LineString?crs="+epsg, layerName, "memory")    
                    pr = vl.dataProvider()        
                    pr.addFeatures(lineFeats)
                    vl.updateFields()
                    vl.updateExtents()         
                    vl.commitChanges()    
                    vl.nameChanged.connect(self.forbidRename)
                    if (groupName != ''):
                        self.addWmsToGroup(groupName,vl, True)
                    else:      
                        self.addLayerToGroup(layerName,vl)
                           
                if (pol == 1):
                    vl = QgsVectorLayer("Polygon?crs="+epsg, layerName, "memory")    
                    pr = vl.dataProvider()        
                    pr.addFeatures(polyFeats)
                    vl.updateExtents()         
                    vl.updateFields()
                    vl.commitChanges()    
                    vl.nameChanged.connect(self.forbidRename)
                    if (groupName != ''):
                        self.addWmsToGroup(groupName,vl, True)
                    else:      
                        self.addLayerToGroup(layerName,vl)
                         

            return True
        else:
            QgsProject.instance().addMapLayer(vlayer)
            return False
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "WFS není pro vrstu "+layerNameTitle+ " k dispozici.")
            else:
                QMessageBox.information(None, "Layman", "WFS for layer "+layerNameTitle+ " is not available.")
    def forbidRename(self):
        if ((int(round(time.time() * 1000)) - self.millis)  > 3000):
            self.millis = int(round(time.time() * 1000))
        
            if self.locale == "cs":
                QMessageBox.information(None, "Layman", "Vrstva s kombinovanou geometií nemůže být přejmenována.")
            else:
                QMessageBox.information(None, "Layman", "Layer with mixed geometry can´t be renamed.")
            self.focusedLayer.setName(self.layerOldName)
      

        
    def getTypesOfGeom(self, vlayer):
        feats = vlayer.getFeatures()
        
        typesL = 0
        typesP = 0
        typesPol = 0
        for feat in feats:
            if (typesL == 0):
                if (feat.geometry().type() == 0):       
                    typesL = 1
            if (typesP == 0):
                if (feat.geometry().type() == 2):             
                    typesP = 1
            if (typesPol == 0):
                if (feat.geometry().type() == 1):        
                    typesPol = 1
            if typesL+typesP+typesPol > 2:
                return typesL+typesP+typesPol
        return typesL+typesP+typesPol
    #def addWmsToGroup(self, groupName, layer, subgroup = False):
    #    root = QgsProject.instance().layerTreeRoot()
    #    group = root.findGroup(groupName)
    #    if subgroup and group:
    #        group = group.findGroup(layer.name())
    #        #if not(sub):
    #        #    group.addGroup(layer.name()) 
    #        #    group = group.findGroup(layer.name())
    #    if not(group):
    #        group = root.addGroup(groupName)  
    #        if subgroup:
    #            sub = group.findGroup(layer.name())
    #            if not(sub):
    #                group.addGroup(layer.name()) 
    #                group = group.findGroup(layer.name())
                        
    #        #group = self.reorderToTop(groupName)
    #    time.sleep(1)
    #    QgsProject.instance().addMapLayer(layer,False)
    #    group.insertChildNode(1000,QgsLayerTreeLayer(layer))       
    def addWmsToGroup(self, groupName, layer, subgroupName="", i = 1000):
        print(groupName)
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(groupName) 
        if groupName == "":
            QgsProject.instance().addMapLayer(layer,False)
            return
        if not(group):
            group = root.addGroup(groupName)           
           # group = self.reorderToTop(groupName, i)
        #####
        #time.sleep(1)
        if subgroupName == "":
            QgsProject.instance().addMapLayer(layer,False)
            group.insertChildNode(1,QgsLayerTreeLayer(layer))     
        else:
            subgroup = group.addGroup(subgroupName)                  
            subgroup.insertChildNode(1,QgsLayerTreeLayer(layer))   
        visibility = self.instance.getVisibilityForLayer(layer.name())   
        try:
            QgsProject.instance().layerTreeRoot().findLayer(layer).setItemVisibilityChecked(visibility)
        except:
            print("missing visibility parameter")
            QgsProject.instance().layerTreeRoot().findLayer(layer).setItemVisibilityChecked(True)
    def addLayerToGroup(self, groupName, layer):
        root = QgsProject.instance().layerTreeRoot()
        group = root.findGroup(groupName) 
        if not(group):
            group = root.addGroup(groupName) 
                                 
                                 
            #group = self.reorderToTop(groupName)
        #####
        #subgroup = group.addGroup("testGroup")
        #####
        time.sleep(1)
        QgsProject.instance().addMapLayer(layer,False)
        group.insertChildNode(1000,QgsLayerTreeLayer(layer))                
        #subgroup.insertChildNode(1000,QgsLayerTreeLayer(layer))                
    def reorderToTop(self, name, i= 1000):        
        print("position" + str(i))
        print(name)
        _ch = ""
        root = QgsProject.instance().layerTreeRoot()
        for ch in root.children():
            if ch.name() == name:
                _ch = ch.clone()
                root.insertChildNode(i, _ch)
                root.removeChildNode(ch)
        try:
            self.reorderInGroup()
        except:
            print("error in reorder group")
        
          
        return _ch

    def reorderInGroup(self):
        from collections import OrderedDict
        root = QgsProject.instance().layerTreeRoot()
        for groupName in self.groupsSet:
            group = root.findGroup(groupName)  # We are interested in group1
            reverse_order = False

            LayerNamesEnumDict=lambda listCh:{listCh[q[0]].name()+str(q[0]):q[1]
                                               for q in enumerate(listCh)}
            print(LayerNamesEnumDict)    
            # group instead of root
            mLNED = LayerNamesEnumDict(group.children())
            print(mLNED)
            mLNEDkeys = OrderedDict(sorted(LayerNamesEnumDict(group.children()).items(), reverse=reverse_order)).keys()
            #print(mLNEDkeys)
            self.groupPosition = sorted(self.groupPositions,key=lambda x: x[2])      
            print(self.groupPosition)
            #mLNEDkeys = list()
            #print(mLNEDkeys)
            #index = len(self.groupPositions) - 1          
            arr = list()
            for item in reversed(self.groupPositions):
                if item[0] == groupName: 
                    res = [x for x in mLNEDkeys if re.search(item[1], x)]
                   # mLNEDkeys.append(item[1]+ str(index))
                    arr.append(str(res).replace("]","").replace("[","").replace("'",""))

                    #index = index - 1
                #mLNEDkeys = (['bod1', 'železnice0'])
            print(arr)
            print(mLNED)
            mLNEDsorted = [mLNED[k].clone() for k in arr]
            group.insertChildNodes(0,mLNEDsorted)  # group instead of root
            for n in mLNED.values():
                group.removeChildNode(n)  # group instead of root
    def convertUrlFromHex(self, url):
        url = url.replace('%3A',':')
        url = url.replace('%2F','/')
        url = url.replace('%3F','?')
        url = url.replace('%3D','=')
        url = url.replace('%26','&') 
        return url

    def checkEpsg(self, name):
        ret = False
        layer = QgsProject.instance().mapLayersByName(name)
        layerCRS = layer[0].crs().authid()
        if ((layerCRS == 'EPSG:4326') or (layerCRS == 'EPSG:3857')):
            ret = True
        return ret

    def registerLayer(self, name):
        

        url = self.URI + "/rest/"+self.laymanUsername+"/layers"
        name = self.removeUnacceptableChars(name)  
        #sldPath = self.getTempPath(name).replace("geojson", "sld").lower()
        #qmlPath = self.getTempPath(name).replace("geojson", "qml").lower()
        geoPath = self.getTempPath(name).lower()
        if LooseVersion(self.laymanVersion) > LooseVersion("1.10.0"):
            stylePath = self.getTempPath(name).replace("geojson", "qml").lower()
        else:
            stylePath = self.getTempPath(self.layerName).replace("geojson", "sld")
        files = {'style': (stylePath, open(stylePath, 'rb')),} # nahrávám sld
        payload = {        
            'file': name.lower()+".geojson",
            'title': name
            }    
        response = requests.request("POST", url, files = files, data=payload, headers = self.getAuthHeader(self.authCfg))    
      
    def writeState(self,value):
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "state.txt" 
        if os.path.exists(path) == False:
            open(path, "w").close
        file = open(path, 'w+')
        file.write(str(value))
        file.close()
    def notifySuccess(self):
        if self.locale == "cs":
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Vrstva "+str(self.importedLayer)+" byla úspěšně importována."), Qgis.Success, duration=3)
        else:
            iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer "+str(self.importedLayer)+" was imported successfully."), Qgis.Success, duration=3)

    def read_in_chunks(self, file_object): ## cca 1MB chunk převzato z laymana test klienta
        chunk_size=self.CHUNK_SIZE
        while True:
            data = file_object.read(chunk_size)
            if not data:
                break
            yield data
    
    def postInChunks(self, layer_name, reqType):
       # print(reqType)
       # print("xxx" + layer_name)
        if (reqType == "patch"):
            #url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layer_name.lower().replace(" ", "_")
            url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+self.removeUnacceptableChars(layer_name)
            r = requests.delete(url,headers = self.getAuthHeader(self.authCfg))
           
        
        self.registerLayer(layer_name)
        layer_name = self.removeUnacceptableChars(layer_name)
        filePath = os.path.join(tempfile.gettempdir(), "atlas_chunks" ) ## chunky se ukládají do adresáře v tempu
        print("chunk layer")
        if not (os.path.exists(filePath)):
            os.mkdir(filePath)
        file = self.getTempPath(layer_name) 
        f = open(file, 'rb')
        arr = []
        for piece in self.read_in_chunks(f):
            arr.append(piece)
       # layer_name = self.removeUnacceptableChars(layer_name)

        url = self.URI+'/rest/'+self.laymanUsername+'/layers/'+layer_name+'/chunk'     
        
        resumableFilename = layer_name+'.geojson'
        layman_original_parameter = "file"  
        resumableTotalChunks = len(arr)
        #print ("resumable" + resumableFilename)
        try:
            for i in range (1, len(arr)+1):  ##chunky jsou počítané od 1 proto +1  
                print("chunk" + str(i))
                file = arr[i-1] # rozsekaná část souboru
                resumableChunkNumber = i  # cislo casti
                payload = {
                'file' : "chunk"+str(i)+".geojson",
                'resumableFilename': resumableFilename,
                'layman_original_parameter': layman_original_parameter,
                'resumableChunkNumber': i,
                'resumableTotalChunks': resumableTotalChunks
                } 
         
                f = open(filePath + os.sep+"chunk"+str(i)+".geojson", "wb")
                f.write(bytearray(arr[i-1]))
                f.close()              
                files = {'file': (layer_name.lower().replace(" ", "_")+".geojson", open(filePath +os.sep+ "chunk"+str(i)+".geojson", 'rb')),}              
                response = requests.post(url, files = files, data=payload, headers = self.getAuthHeader(self.authCfg))

               # print(response.content)
               # print(layer_name)
            #iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer  " + layer_name + " was imported successfully."), Qgis.Success, duration=3)
        except:
            pass
            #iface.messageBar().pushWidget(iface.messageBar().createMessage("Import:", " Layer  " + layer_name + " was not imported successfully!"), Qgis.Warning, duration=3)


    def is_admin(self):
        try:
            return ctypes.windll.shell32.IsUserAnAdmin()
        except:
            return False
    def install(self):
        if self.locale == "cs":
            msgbox = QMessageBox(QMessageBox.Question, "Import Map", "Plugin vyžaduje instalaci následujících python modulů: \n\nFlask 1.1.1 \nWerkzeug 0.16.0 \nItsDangerous 1.1.0 \nClick 7.0 \n\nInstalace vyžaduje administrátorská práva. \nChcete provést instalaci modulů?")
        else:
            msgbox = QMessageBox(QMessageBox.Question, "Import Map", "Plugin requires installation following python modules: \n\nFlask 1.1.1 \nWerkzeug 0.16.0 \nItsDangerous 1.1.0 \nClick 7.0 \n\nInstalation requires administrator permissions. \nDo you want install the packages?")
        msgbox.addButton(QMessageBox.Yes)
        msgbox.addButton(QMessageBox.No)
        msgbox.setDefaultButton(QMessageBox.No)
        reply = msgbox.exec()
        if (reply == QMessageBox.Yes):
            path = QgsApplication.prefixPath().replace("apps/qgis","apps") + "/Python37/lib/site-packages"


            if self.is_admin():
                print("xx")# Code of your program here
            else:
                # Re-run the program with admin rights
                program = self.plugin_dir + os.sep + "dependencies" + os.sep + "LaymanDependencies.exe"
                
                if not os.path.exists(path):
                    path = path.replace("apps-ltr","apps")
               # print(path)
                print(ctypes.windll.shell32.ShellExecuteW(None, "runas", program, path, None, 1))
                self.dlg.close()
                self.disableEnvironment()
                QMessageBox.information(None, "Layman", "Layman plugin was updated. Please restart QGIS.")
              #  ctypes.windll.shell32.ShellExecuteW(None, "runas", "notepad.exe", self.plugin_dir + os.sep + "Layman.py", None, 1)
############################################# auth part############################
    def startThread(self): 
        self.thread1 = threading.Thread(target=self.refreshToken)
        self.thread1.start()

    def refreshToken(self):
        #self.expires_in = 60
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "tsts.txt" 
        i = 0
        #tokenEndpoint = "https://www."+self.liferayServer+"/o/oauth2/token"
        tokenEndpoint = self.liferayServer+"/o/oauth2/token"
        while (i < self.expires_in):        
            f = open(path, "a")
            f.write(str(i))

            f.close()            
            time.sleep(1)         
            if i == self.expires_in - 4:
            
               
                data = {'grant_type':'refresh_token',
                        'refresh_token': self.refresh_token,
                        'client_id': self.client_id,   ##'id-3462f94b-875c-9185-4ced-b69841f24b3', 
                        'redirect_uri':'http://localhost:3857/client/authn/oauth2-liferay/callback', 
                        'code_verifier':self.code_verifier  ##'test'
                        } 
                
                r = requests.post(url = tokenEndpoint, data = data, headers = self.getAuthHeader(self.authCfg)) 
                res = self.fromByteToJson(r.content)
                self.access_token = res['access_token']
                self.refresh_token = res['refresh_token']
                self.expires_in = res['expires_in']
                print(self.access_token)
                self.setAuthHeader()
                i = 0
            else:
                i += 1
        

    def authOptained (self):        
        try:
            self.dlg.pushButton_Continue.setEnabled(True)
            self.dlg.pushButton_Connect.setEnabled(False) 
        except:
            pass

        self.menu_Connection.setEnabled(True)
        self.menu_saveLocalFile.setEnabled(False)
        self.menu_loadJson.setEnabled(True)
        self.menu_ImportLayerDialog.setEnabled(True)
        self.menu_AddLayerDialog.setEnabled(True) 
        self.menu_AddMapDialog.setEnabled(True)       
        self.menu_ImportLayerDialog.setEnabled(True)
        #self.menu_ImportMapDialog.setEnabled(False)       
     #   self.menu_DeleteMapDialog.setEnabled(True)
    #    self.menu_CreateCompositeDialog.setEnabled(True)
        self.menu_UserInfoDialog.setEnabled(True)
        self.menu_CurrentCompositionDialog.setEnabled(True)
        
        #self.textbox.setText("Layman: Logged user")
    def getAuthHeader(self, authCfg):  
        print(self.isAuthorized)
        if self.isAuthorized:
            config = QgsAuthMethodConfig()
            url = QUrl(self.URI+ "/rest/current-user")
            xx = QNetworkRequest(url)
           # print(xx.header(QNetworkRequest.KnownHeaders(-2)))
            i = 0
            success = (QgsApplication.authManager().updateNetworkRequest(xx, authCfg))
            #print(success[0])
            if success[0] == False:
                success  = (QgsApplication.authManager().updateNetworkRequest(xx, authCfg))
            #while (success[0] == False or i < 30):
            #    success  = (QgsApplication.authManager().updateNetworkRequest(xx, authCfg))
            #    time.sleep(0.5)
            #    i = i + 1
            #print(xx.header(QNetworkRequest.KnownHeaders.ContentDispositionHeader))
            if success[0] == True:
                header = (xx.rawHeader(QByteArray(b"Authorization")))
                #print(header)
                authHeader ={
                  "Authorization": str(header, 'utf-8')           
                } 
                return authHeader
            else:
                if self.locale == "cs":
                    QMessageBox.information(None, "Message", "Autorizace nebyla úspěšná! Prosím zkuste to znovu.")
                else:
                    QMessageBox.information(None, "Message", "Autorization was not sucessfull! Please try it again.")
                return False
        else:        
           
            return ""
            
    def getCodeVerifier(self):
        code_verifier = base64.urlsafe_b64encode(os.urandom(40)).decode('utf-8')
        code_verifier = re.sub('[^a-zA-Z0-9]+', '', code_verifier)
        self.code_verifier = code_verifier
        return (code_verifier)
      
    def getCodeChallenge(self, code_verifier):
        code_challenge = hashlib.sha256(code_verifier.encode('utf-8')).digest()
        code_challenge = base64.urlsafe_b64encode(code_challenge).decode('utf-8')
        code_challenge = code_challenge.replace('=', '')
        self.code_challenge = code_challenge
        return (code_challenge)        

    def printVariables(self):
        print (self.access_token)
        print(self.refresh_token)
        print(self.getAuthHeader(self.authCfg))
        print(self.laymanUsername)

    def getAuthCode(self):
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt"        
        f = open(path, "r")
        ret =  f.read()
        f.close()
        return ret

    def getToken(self):
        self.saveIni()      
        
        #tokenEndpoint = "https://www."+self.liferayServer+"/o/oauth2/token"
        tokenEndpoint = self.liferayServer+"/o/oauth2/token"
        # data to be sent to api 
        data = {'grant_type':'authorization_code', 
                'client_id': self.client_id, 
                'redirect_uri':'http://localhost:3857/client/authn/oauth2-liferay/callback', 
                'code_verifier': self.code_verifier, 
                'code': self.getAuthCode()} 
  
        # sending post request and saving response as response object 
        print(tokenEndpoint)
        print(self.getAuthHeader(self.authCfg))
        print(data)
        r = requests.post(url = tokenEndpoint, data = data, headers = self.getAuthHeader(self.authCfg)) 
        print (r.content)
        res = self.fromByteToJson(r.content)
        print (res)
        try:
            print(res['access_token'])
            print(res['expires_in'])
            print(res['refresh_token'])
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Message", "Autorizace nebyla úspěšná! Prosím zkuste to znovu.")
            else:
                QMessageBox.information(None, "Message", "Autorization was not sucessfull! Please try it again.")
            return
        self.access_token = res['access_token']
        self.refresh_token = res['refresh_token']
        self.expires_in = res['expires_in']
        self.setAuthHeader()
        data ={
            'access_token': res['access_token'], 
            'refresh_token': res['refresh_token'],
            'expires_in':res['expires_in']
            }
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "tokens.json"        
        with open(path, 'w') as outfile:
            json.dump(data, outfile)
        #self.dlg.progressBar.show()
        self.registerUserIfNotExists()        
        self.startThread()   
        #self.loadAllCompositesT()
        

        #threading.Thread(target=self.loadAllCompositesT).start() ## načteme kompozice do pole ve vláknu 
       
        ### authconfig
        authcfg_id = self.authCfg
        if authcfg_id not in QgsApplication.authManager().availableAuthMethodConfigs():
            QgsApplication.authManager().clearAllCachedConfigs()
            self.setup_oauth(self.authCfg, self.liferayServer)

        ##authconfig end
        self.dlg.close()
        
        
        
    def setAuthHeader(self):
        self.authHeader ={
          "Authorization": "Bearer " + self.access_token, 
          "AuthorizationIssUrl" : self.liferayServer+'/o/oauth2/authorize'
        } 
 
    def beforeAmp(self, s):
        ret = ""
        print(len(s))
        for i in (s):
            if i == "@":
                break
            ret = ret + i      
        print(ret)
        return ret
    def registerUserIfNotExists(self):
        print(self.URI)            
        userEndpoint = self.URI+ "/rest/current-user"   
        #self.laymanUsername = self.dlg.lineEdit_userName.text()
        print(userEndpoint)
        print(self.Agrimail)
        login = self.beforeAmp(self.Agrimail)
        print(login)
        id = self.client_id.replace('-', '')
        login = login.replace(".","_")
        self.laymanUsername = login
        user = {'username':login}  
        #user = {'username':'vrobel_hanz'}  
        #user =  self.Agrimail                
        print("authheader: "+ str(self.getAuthHeader(self.authCfg)))
       
        r = requests.patch(url = userEndpoint, data = user, headers = self.getAuthHeader(self.authCfg))
        res = r.text
        try:
            res = self.fromByteToJson(r.content)
            print (res)
            print(user)
            print(res)
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Layman server neodpověděl!") 
            else:
                QMessageBox.information(None, "Error", "Layman server not respond!")
            self.disableEnvironment()
            return        
       
        try:
           # if res['message'] == 'User already reserved username.': # res['code'] == 34, code 35 je pokud již jiný uživatel má účet, který chceme registrovat
           if res['code'] == 34: # res['code'] == 34, code 35 je pokud již jiný uživatel má účet, který chceme registrovat (code 35 pravděpodobně nemůže nastat)

                print("user exists")
               
                self.laymanUsername = res['detail']['username']
                print("username is: " + self.laymanUsername )
                self.textbox.setOpenExternalLinks(True)
                url = self.liferayServer.replace('https:\\','').replace('.cz','').replace('http:\\','').replace('www.','').replace('.com','')
                self.textbox.setText('<a href="'+self.liferayServer+"/home"'">' + url + '</a>')
           if res['code'] == 32:
                self.disableEnvironment()
                if self.locale == "cs":
                    QMessageBox.information(None, "Error", "Oauth2 autorizace nebyla úspěšná!") 
                else:
                    QMessageBox.information(None, "Error", "Oauth2 authorization was not successfull!") 
                self.textbox.setText("Layman")
                return False
            #self.laymanUsername = res['username']
            #else:
            #    self.laymanUsername =  user['username']
        except:
            try:
                print("creating new user: " + res['username'])
                self.laymanUsername =  res['username']
                url = self.liferayServer.replace('https:\\','')
                self.textbox.setText('<a href="'+self.liferayServer+"/home"'">' + url + '</a>')
                ##self.textbox.setText("Connected to: " + self.liferayServer.replace("https:\\","").replace(".cz","").replace("http:\\","").replace("www.","").replace(".com",""))
            except:
                print("Komunikace s Liferay nefunguje")
                
                if self.locale == "cs":
                    QMessageBox.information(None, "Error", "Komunikaci se serverem nelze navázat!") 
                else:
                    QMessageBox.information(None, "Error", "Communication with the server cannot be established!")
                self.logout()
                return False
        return True
    def checkAuthChange(self):
        i = 0
        path = tempfile.gettempdir() + os.sep + "atlas" + os.sep + "auth.txt" 
        #print("thread is running")
        #print(self.authFileTime)
        #print(os.path.getmtime(path))
        while(i < 500):
            if self.authFileTime == os.path.getmtime(path):
                pass
            else:
                self.authFileTime = os.path.getmtime(path)
                QgsMessageLog.logMessage("authOptained")
                #self.authOptained()
                i = i + 500
                #print("obtained code")
            i = i +1
            time.sleep(0.5)
    def getUserName(self):
        userEndpoint = self.URI+ "/rest/current-user"   
        r = requests.get(url = userEndpoint, headers = self.getAuthHeader(self.authCfg))
        res = self.fromByteToJson(r.content)
        print(res)
        return res['claims']['name']
    def connectionLost(self):      
        print("connection lost")
        self.disableEnvironment()      
        #userEndpoint = self.URI+ "/rest/current-user"    
        #r = requests.delete(url = userEndpoint, headers = self.getAuthHeader(self.authCfg))
        #QgsApplication.authManager().clearCachedConfig(self.authCfg)      
        self.textbox.setText("Layman")
        ## flush variables
        self.loadedInMemory = False
        #QgsApplication.authManager().clearCachedConfig("")
        self.menu_UserInfoDialog.setEnabled(True)
        self.laymanUsername = ""
        self.isAuthorized = False
        self.current = None
        self.liferayServer = None
        #self.menu_Connection.setEnabled(True)
        self.compositeList = []
        self.compositeListOld = []       
    def openAuthLiferayUrl2(self):
        self.dlg.pushButton_Connect.setEnabled(False)
        #self.authCfg = self.client_id[-7:]
        #authcfg_id = self.client_id[-7:]
        self.isAuthorized = True
        authcfg_id = self.authCfg
        #if authcfg_id not in QgsApplication.authManager().availableAuthMethodConfigs():
        print(self.setup_oauth(authcfg_id, self.liferayServer))
        authHeader = self.getAuthHeader(self.authCfg)
        print(authHeader)
        if (authHeader):
            if self.registerUserIfNotExists():
                #threading.Thread(target=self.loadAllCompositesT).start() ## načteme kompozice do pole ve vláknu 
                self.saveIni() 
                self.name = self.getUserName()


                 ## layman version
            
                url = self.URI+ "/rest/about/version"   
                print(url)
                r = requests.get(url = url)
                #print (r.content)
                try:
                    res = self.fromByteToJson(r.content)
                    print(res['about']['applications']['layman']['version'])
                    self.laymanVersion = res['about']['applications']['layman']['version']
                except:
                    self.laymanVersion = "0.0.0"
                ##
                ### authconfig
                #authcfg_id = self.client_id[-7:]
                #if authcfg_id not in QgsApplication.authManager().availableAuthMethodConfigs():
                #    self.setup_oauth(self.client_id[-7:], self.liferayServer)
                ##authconfig end
                ## check for new version
           
                versionCheck = self.checkVersion()
                if versionCheck[0] == False:
                    if self.locale == "cs":
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "Nová verze pluginu Layman k dispozici."), Qgis.Success, duration=15)
                    else:
                        iface.messageBar().pushWidget(iface.messageBar().createMessage("Layman", "New version of Layman plugin available."), Qgis.Success, duration=15)

                ##

                self.authHeader = authHeader
                self.authOptained()
                #self.menu_Connection.setEnabled(False)
                self.dlg.pushButton_logout.setEnabled(True)
                self.dlg.pushButton_NoLogin.setEnabled(False)
                self.dlg.pushButton_Connect.setEnabled(False)
                self.dlg.close()
                
                ## zjištení výpadku spojeni
                #QgsApplication.authManager().masterPasswordVerified.connect(self.connectionLost)

                ## liferay cache
                #self.timerLayer = QTimer()
                #self.timerLayer.setInterval(10000)
                #self.timerLayer.timeout.connect(lambda: self.rebuildLiferayCache()) 
                #self.timerLayer.start()
                threading.Thread(target=lambda: self.fillCompositionDict()).start()
    def download_url(self, url, save_path, chunk_size=128):
        r = requests.get(url, stream=True)
        with open(save_path, 'wb') as fd:
            for chunk in r.iter_content(chunk_size=chunk_size):
                fd.write(chunk)
    def copytree(self, src, dst, symlinks=False, ignore=None):      
        try:
            shutil.rmtree(dst)
            os.mkdir(dst)
        except:
            if self.locale == "cs":
                QMessageBox.information(None, "Error", "Plugin nebyl aktualizován!") 
            else:
                QMessageBox.information(None, "Error", "Plugin was not updated!") 
            return
        for item in os.listdir(src):
            
            s = os.path.join(src, item)
            d = os.path.join(dst, item)
            if os.path.isdir(s):      
                shutil.copytree(s, d, symlinks, ignore)
            else:
                shutil.copy2(s, d)
    def updatePlugin(self, version):
        if (len(version.split(".")) > 2):
            if self.locale == "cs":
                msgbox = QMessageBox(QMessageBox.Question, "Aktualizace pluginu", "Tato verze pluginu není v QGIS repozitáři a může obsahovat nové netestované funkcionality. Chcete opravdu instalovat tuto verzi?")
            else:
                msgbox = QMessageBox(QMessageBox.Question, "Plugin update", "This version of the plugin is not included in the QGIS repository and may contain new untested functionalities. Do you really want to install this version?")
            msgbox.addButton(QMessageBox.Yes)
            msgbox.addButton(QMessageBox.No)
            msgbox.setDefaultButton(QMessageBox.No)
            reply = msgbox.exec()
            if (reply == QMessageBox.No):
                return
        url = "https://gitlab.com/Vrobel/layman_qgis/-/archive/master/layman_qgis-master.zip" 
        save_path = tempfile.gettempdir() + os.sep + "layman.zip"
        self.download_url(url, save_path)

        with ZipFile(save_path, 'r') as zipObj:
           # Extract all the contents of zip file in different directory
           zipObj.extractall(tempfile.gettempdir())
        src = tempfile.gettempdir() + os.sep + "layman_qgis-master"                  
       
        self.copytree(src, self.plugin_dir)
        self.dlg.close()
        self.disableEnvironment()
        QMessageBox.information(None, "Layman", "Layman plugin was updated. Please restart QGIS.")
        
    def checkVersion(self):    
        r = requests.get("https://gitlab.com/Vrobel/layman_qgis/-/raw/master/metadata.txt?inline=false") 
       
        buf = io.StringIO(r.text)
        config = configparser.ConfigParser()
        config.read_file(buf)
        version = config.get('general', 'version')
        installedVersion = self.getVersion()
       
        if installedVersion == version:
            return [True, version]
        else:
            return [False, version]
    def appendIniItem(self, key, item):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep + 'layman_user.INI' 
        config = configparser.RawConfigParser()
        config.read(file)
        config.set('DEFAULT',key,item)                         
        cfgfile = open(file,'w')
        config.write(cfgfile, space_around_delimiters=False)  # use flag in case case you need to avoid white space.
        cfgfile.close()
    def getConfigItem(self, key):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep + 'layman_user.INI' 
        config = configparser.RawConfigParser()
        config.read(file)
        return config.get('DEFAULT',key)
    def saveIni(self):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep + 'layman_user.INI'  
        dir = os.getenv("HOME") + os.sep + ".layman"
        if not (os.path.isdir(dir)):
            try:  
                os.mkdir(dir)
            except OSError:  
                print ("vytváření adresáře selhalo")
        #config = configparser.ConfigParser()

        #config['DEFAULT']['login'] = self.Agrimail
        #config['DEFAULT']['id'] = self.client_id
        #print("server liferay" + self.liferayServer)
        #config['DEFAULT']['server'] = self.liferayServer
        #config['DEFAULT']['layman'] = self.URI
        self.appendIniItem('login',self.Agrimail)
        self.appendIniItem('id',self.client_id)
        self.appendIniItem('server',self.liferayServer)
        self.appendIniItem('layman',self.URI)
        

        #with open(file, 'w') as configfile:
        #    config.write(configfile)        
    def loadIni(self):
        file =  os.getenv("HOME") + os.sep + ".layman" + os.sep +'layman_user.INI'        
        config = configparser.ConfigParser()
        config.read(file)
        return config   

    def layerChanged(self):  
        
      
        if (iface.activeLayer() != None and isinstance(iface.activeLayer(), QgsVectorLayer)):
            self.menu_saveLocalFile.setEnabled(True)
        else:
            self.menu_saveLocalFile.setEnabled(False)
        try:
            layer = iface.activeLayer()
            self.layerOldName = layer.name()        
            self.focusedLayer = layer
        except:
            print("group is selected")
        
     
    def run(self):
        """Run method that loads and starts the plugin"""

        if not self.pluginIsActive:
            self.pluginIsActive = True

            #print "** STARTING Atlas"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = AtlasDockWidget()

            
            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)     
            
            self.dockwidget.pushButton.clicked.connect(self.sendLayer)   
            self.dockwidget.pushButton_2.clicked.connect(self.loadLocalFile) 
            self.dockwidget.pushButton_3.clicked.connect(self.saveLocalFile)
            self.dockwidget.pushButton_getLayers.clicked.connect(self.run_getLayer)            
            self.dlgGetLayers.pushButtonxx.clicked.connect(lambda: print(self.dlgGetLayers.items.currentItem().text()))          
            
            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.TopDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
       


        
    
   